/*
 * date    14 dec 2020
 * author  artur
 */
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace _
{
    class PLINQ
    {
        static void Main()
        {
            Console.WriteLine("***** PLINQ *****");

            Preview_Silent();
            Using();
            CancelIt();

            Console.ReadLine();
        }
        static void Preview_Silent()
        {
            Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Preview_Silent()\n");


            // Завершение исследования TPL мы отметим баловством с ещё одним способом встраивания параллельности в приложения .NET. Как ты
            //   помнишь, LINQ - это набор расширяющих методов в контейнерах, что используются для упращённой работы с сими (и ещё есть набор
            //   слов-операторов, за которые обычно и понимают LINQ. На самом деле это LINQ to Objects). Ну так вот, добавив всего одну деталь
            //   в привычном запросе, ты переведёшь этот запрос на польностью параллельную манеру. Уже чуешь весь профит, да? В должной среде
            //   это обеспечивает сильнейший буст по производительности. Запросы LINQ, что используют эту деталь, зовутся запросами
            //   Parallel LINQ (или PLINQ)
            // Инфраструктура PLINQ оптимизированна во многих отношениях. Например, PLINQ просто анализирует общую структуру запроса. Если есть
            //   достаточно большая вероятность того, что запрос выиграет от распараллеливания, он будет выполнятся параллельно (опция
            //   отключения распараллеливания вручную также есть). Да, когда возникает выбор между потенциально затратным в плане ресурсов
            //   параллельным алгоритмом и экономным последовательным, предпочтения (по умолчанию) отдаётся последовательному алгоритму
            // Необходимые для PLINQ расширяющие методы находятся в классе классе ParallelEnumerable из пространства System.Linq. Вот некоторые
            //   интересные представители оттуда:
            //
            //   > AsParallel()              -  указывает, что остаток запроса должен быть (если возможно) распараллелен
            //   > WithCancellation()        -  инфраструктура PLINQ дложна периодически отслеживать состояние признака отмены (т.е. объекта
            //                                  System.Threading.CancellationToken) и при получении этой команды отменить выполнение
            //   > WithDegreeOfParallelism() -  с помощью этого метода ты можешь указать максимальное кол-во (именно максимальное) потоков, что
            //                                  могуть быть задействованы инфраструктурой PLINQ для этого запроса
            //   > ForAll()                  -  этот расширяющий метод (кроме того, что выполняет заданное действие над элементами контейнера)
            //                                  вадаёт свой результат по частям. Он не выполняет "слияния" с потоком потребителя (т.е. не ждёт,
            //                                  пока его выходной контейнер не наполнится полностью), отдавая свой результат сразу и наполняя
            //                                  его со временем. Выход этого метода прекрасно работает с циклом foreach
            // Если расширяющие методы LINQ выдают объекты, реазилующие System.Collections.Generic.IEnumerable<>, то методы PLINQ оставят
            //   после себя System.Linq.ParallelQuery<> (и, кстати, каждый из них привнесёт в результат что-то своё. WithCancellation(),
            //   например, подключит проверку токена во всю цепь запроса после него)


            Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Preview_Silent()");
        }
        static void Using()
        {
            Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Using()\n");


            // В качестве демонстрации выступит код, что из сверхбольшого массива отсеивает числа кратные 3-ём

            int[] numbers = Enumerable.Range(1, 100_000_000).ToArray();  // System.Linq.Enumerable.Range() - как ты видишь, LINQ To Objects
            DateTime time;                                               //   умеет работать не только с имеющимеся контейнерами. Этот метод
                                                                         //   создаёт последовательность чисел от параметра start до параметра
                                                                         //   count (и умеет выбрасывать System.ArgumentOutOfRangeException)
                                                                         //   Ещё есть ..Enumerable.Empty() (для генерации пустого контейнера)
                                                                         //   и ..Enumerable.Repeat() (для контейнера с одинаковым числом)
                                                                         // time - мы будем сравнивать затраты процессорного времени

            time = DateTime.Now;
            int[] modThreeIsZero = (from num in numbers.AsParallel() where num % 3 == 0 select num).ToArray();
            Console.WriteLine("PLINQ: {0}", DateTime.Now - time);   // .. numbers.AsParallel() .. - чтобы дальнейший запрос шёл в многопоточной
                                                                    //   манере, достаточно вклинить в нужное место этот метод

            time = DateTime.Now;
            modThreeIsZero = (from num in numbers where num % 3 == 0 select num).ToArray();
            Console.WriteLine("LINQ: {0}", DateTime.Now - time);

            Console.WriteLine("There are {0} numbers that match the query!\n", modThreeIsZero.Count());


            Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Using()");
        }
        static void CancelIt()
        {
            Console.WriteLine(">->->->->->->->->->->->->->->->->->->   CancelIt()\n");


            // С помощью объекта CancellationTokenSource ты также можешь проинформировать запрос PLINQ о необходимости прекратить работу. Этот
            //   метод расширяет только объекты типа ParallelQuery (и, конечно, типы, являющиеся им)

            System.Threading.CancellationTokenSource cancelToken = new System.Threading.CancellationTokenSource();

            do
            {
                Console.Write("Press any key to start: ");
                Console.ReadLine();

                Console.WriteLine("Processing...");
                System.Threading.Tasks.Task.Factory.StartNew(
                    () => {
                        int[] modThreeIsZero = (from num in Enumerable.Range(1, 100_000_000).AsParallel().WithCancellation(cancelToken.Token)
                                                where num % 3 == 0 select num).ToArray();
                        Console.WriteLine("Done! There is {0} matched numbers", modThreeIsZero.Count());
                        Console.WriteLine("Press any other key to repeat:");
                    });

                Console.WriteLine("Press Q to stop:");
                if ("Q".Equals(Console.ReadLine(), System.StringComparison.OrdinalIgnoreCase))
                {
                    cancelToken.Cancel();
                    break;
                }
            } while (true);

            Console.WriteLine();


            Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   CancelIt()");
        }
    }





    class AsyncAwait
    {
        static void Main()
        {
            Console.WriteLine("***** AsyncAwait *****");

            Preview();
            Using();

            Console.ReadLine();
        }
        static void Preview()
        {
            Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Preview()\n");


            // На самом деле (как говорит автор) многое в этой (довольно длинной, кстати) главе было представленно в сжатом ввиде. Хотя
            //   использование делегатов, TPL и PLINQ нередко значительно упрощают жинзь программистам, они всё-таки должны знать детали
            //   различных расширенных приёмов
            // .NET 4.5 привнёс в C# (и ещё в VB) два новых ключевых слова: async и await. И да, они дополнительно упращают процесс написания
            //   асинхронного кода. По правде говоря, они (как и lock) просто переводятся компилятором в довольно цепочку команд (довольно
            //   большую), связанных с потоками. Там применяются многочисленные вызовы членов из System.Threading и System.Threading.Tasks


            Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Preview()");
        }
        static void Using()
        {
            Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Using()\n");


            // На деле, async - это приставка к объявлению метода, и оно ставится наряду с перед возвращающим типом. Сам по себе async не
            //   делает метод асинхронным (да, это так). Это просто указание компиялтору, что скорее всего в методе будет применено ключевое
            //   слово await
            // async может ставиться в объявлении только перед возвращаемым типом, а возвращающим типом должен быть Task, Task<>,
            //   IAsyncEnumerable<> или IAsyncEnumerator<> (VS не даст тебе забыть о этой части)
            // Ещё async применим ко всякого рода наслойкам на методы (вроде делегатов, анонимных методов, лямбда-выражений и локальных
            //   функций)
            // Основной же интерес представляет ключевое слово await. Суть такова: ты запускаешь async метод, он выполняется как обычный (т.е.
            //   тем же потоком), как только встречается вызов метода с await впереди, по задумке, начинается асинхронщина (но её начинает не
            //   await). await может применятся только с методом, что возвращает Task (или Task<>), и именно этот метод должен обеспечить
            //   создание нового потока (но, как ты понял, этого может и не происходить)
            // В качестве await метода обычно применяют ..Task.Run() (т.к. он заточен под это дело). Я не знаю как, но вызов ..Task.Run()
            //   сбрасывает текущий поток (что запустил async-метод) обратно вниз, после чего тот продолжает выполнять код, что находится за
            //   async-методом. Перед тем, как вылететь, поток успевает создать нового работника в ..Task.Run(), что и запускает делегат,
            //   посланный в ..Task.Run(). После выполнения этого задания второстепенный поток продолжает выполнять код за await-методом. Он
            //   может встретить дальше новые await-вызовы с ..Task.Run(), но это уже не заставляет его создавать новый поток, и он сам
            //   выполняет второй await-вызов, затем снова продолжив код в async-методе (на самом деле вызов вотрого await ..Task.Run() может
            //   привести к созданию уже 3-его потока. Всё зависит от настроения пула потоков)


          //System.Collections.Generic.List<int> l = default;  // default - как говорит автор, для того, чтобы всё заработало, проект должен
                                                               //   конфигурироваться под C# 7.1. На вермя написания книги (~2017 год) VS не
                                                               //   считала это изменение нужным, поэтому автор (уже Филипп Джепикс) применил в
                                                               //   коде эту приманку для подсказки (VS должна спросить тебя о переводе проекта
                                                               //   на C# 7.1, но в моём времени эта версия стоит по умолчанию)

            async Task<string> DoWorkAsync()              // async - мы даём понять компилятору, что эта локальная фукнция может
            {                                             //   рассинхрониться с текущим потоком (он выдаст предупреждение, если await'а
                                                          //   внутри таки не нашлось)
                                                          // Task<string> - страшный зверь, скрытый под капотом этих ключевых слов, даёт о себе
                                                          //   знать. Мы действительно возвращаем Task<string>. Вообще, объекты типа Task (и
                                                          //   Task<>) - это представители асинхронных операций (методов), что возвращают
                                                          //   значения (т.е. не void. Для void методов незачем создавать Task-объект, ведь
                                                          //   такой метод просто тихо завершится, никому ничего не оставив)
                Console.WriteLine("We are running it!");  // ..WriteLine() - эту команду выполнит старый поток, ведь здесь нет await (и быть не
                return await Task.Run(() =>               //   может, ведь метод - не async)
                    {                                     // await Task.Run() - здесь мы и разделим ход нашей реки. Текущий поток продолжит
                        Thread.Sleep(5_000);              //   выполнять команды, что находятся после вызова DoWorkAsync()
                        return "He have done work!";      // System.Threading.Tasks.Task.Run() - этот static (и async) метод запустит делегат
                    });                                   //   в новом потоке. Судя по описанию, он просто просто воспользуется пулом потоков.
            }                                             //   На деле, в нём создастся аж 2-а новых потока: 1-н для продолжения
                                                          //   Почти что сразу он возвратит нам объект Task<>

            Console.WriteLine("We are starting it");
            Console.WriteLine(DoWorkAsync().Result);   // ..WriteLine(DoWorkAsync()) - из объекта Task<> можно получить результат асинхронной
            Console.WriteLine("We are again here\n");  //   операции, (через свойство Result). Метод ToString() переопределён на вызов
                                                       //   ToString() из результата
                                                       // ..Result - если результат ещё не готов, потоку придётся подождать его (посмотреть
                                                       //   готовность можно через свойство Status, что хранит значение перечисления
                                                       //   System.Threading.Tasks.TaskStatus


            // Следует отметить, что async методы не могут иметь параметры с модификаторами out и ref
            // В .NET есть соглашение - асинхронные посредством async методы имеют в своём имени суффикс Async (в основном это члены классов
            //   для работы с файлами, сетью и базами данных)(обработчики события элементов управления GUI, вроде события Click кнопки, не
            //   следуют этому соглашения, хотя в них применяются async и await). Как видишь, мы его тоже выполнили
            // В подсказках методов, что имеют await в своём блоке, VS добавляет надпись    (awaitable)
            // Некоторые смотрят на async и await как на основной инструмент многопоточного проектирования в C#

            // Джепикс в книге пишет неправду, и код его неправильный

            // Ну и ещё кое-что. В случае нужности параллельщины, на данный момент везде применяется именно Класс Task (а точнее его метод
            //   Run()), ведь в нём уже всё продумано. Как говорилось в начале раздела, TPL очень прост в использовании, но не гибок


            Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Using()");
        }
    }
}
