/*
 * creation date  26 oct 2021
 * last change    26 oct 2021
 * author         artur
 */
using System;
using System.Threading;

class __SystemThreadingNamespaceExtra
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        SystemThreadingNamespaceExtra_Silent();

        Console.ReadLine();
    }
    static void SystemThreadingNamespaceExtra_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   SystemThreadingNamespaceExtra_Silent()\n");


        // TheProblem
        //
        //   Как ты понял, при построении многопоточного приложения ты должен избегать того, чтобы несколько потоков могли одновременно
        //     обратится к одной области памяти. Представь, что может
        //     произойти, если в твоём сверхнагруженном приложении все 10 потоков одновременно попытаются что-то записать в одну разделяемую
        //     переменную (а это может произойти, ведь планировщик потоков приостанавливает их случайным образом). Приложение потеряет данные
        //     , и много! А ведь потеря даже одного бита данных может пустить всё под крутейший откос
        //
        //   Для демонстрации похожей проблемы, давай попробуем заставить 3 потока выводить на экран числа от 1 до 7. Вот код:
        //
          void PrintNumbers()
          {
              for (int i = 0; i < 7; i++)
              {
                  Console.Write("{0} ", i);  // Console.Write() - этот метод (скорее всего) будет вызываться потоками в рандомном порядке, а
              }                              //   значит пользователь увидит солянку, а не 3 упорядоченных списка
          }                                  // Видимо, в функции Windows, что отвечает за вывод текста на консоль, есть некий ограничитель,
                                             //   что не даёт выводить в cmd больше одной строки за раз, т.к. мы не наблюдаем вставку одного
                                             //   сообщения в другом
        //
          Thread[] threads = new Thread[3];
          for (int i = 0; i < threads.Length; i++)                     // for - т.к. мы намерены присваивать что-то в ячейки массива, циклом
          {                                                            //   foreach мы воспользоваться не можем
              threads[i] = new Thread(new ThreadStart(PrintNumbers));  // new Thread() - напомню, что массив изначально хранит просто ссылки,
          }                                                            //   а значит нужно вызывать конструктор к каждому элементу
                                                                       // PrintNumbers - и все эти потоки будут запускать один метод
        //
          foreach (Thread curr in threads)
          {
              curr.Start();     // Start() - и стартуем мы их всех здесь, примерно в одно время
          }
        //
          foreach (Thread curr in threads)
          {
              curr.Join();      // curr.Join() - чтобы идти дальше, нам следует подождать завершения того, что уже началось
          }
          Console.Write("\n\n");
        //
        //   При запуске ты увидишь, что выводится не три аккуратных последовательности, а винегрет из чисел. Причём в каждом новом запуске
        //     винегрет будет перемешан по-другому (если ты всё-таки увидишь 3 последовательности - считай, что ты везунчик)
        //   Чтобы решить эту проблему, нужно нивелировать шалости планировщика потоков. Как и можно было ожидать, System.Threading
        //     предлагает несколько типов, что служат для синхронизации доступа к разделяемым ресурсам 
        //                                              Эти типы, кстати, были описаны
        //                                              ещё в начале метода о SystemThreadingNamespace_..()
        //    . Даже в самом C# предусмотрено специальное ключевое слово lock, и всё это ты увидишь
        //


        // Synchronization with lock
        //
        //   Это первый приём, что можно применять для синхронизации потоков. С помощью lock {} ты можешь выделить блок операторов, что
        //     никогда не должены выполнятся более чем одним потоком. Ещё слово lock требует указания "маркера" (ссылки на какой-нибудь
        //     объект), который будет использовать как отличительный маркер. Он будет как-бы закрываться, когда его занимают, и освобождаться
        //     , когда поток покидает его зону. Этот объект-маркер можно использовать сразу во многих lock {}
        //   Вот как это выглядит:
        //
          object threadLock = new object();  // threadLock - мы будем использовать этот локальный объект (а точнее ссылку на него) в lock. Да
                                             //   , если наш метод SystemThreadingNamespaceExtra_...() будет вызван двумя разными потоками,
                                             //   каждый из
                                             //   них получит свой собственный маркер threadLock (ссылки у них будут разными), а значит оба
                                             //   они всё-таки смогут работать в lock {} одновременно. Но для демонстрации - сойдёт
                                             // ****вроде как не обязательно нужен именно объект, нужна всего лишь ссылка, т.е. переменная
                                             //   threadLock сама по себе
        //
          void PrintNumbers1()                    // PrintNumbers() - на этот раз метод будет иметь защиту от проблемы многопоточности. Этой
          {                                      //   защитой будет синхронизация его кода с помощью lock
              lock (threadLock)                  // lock(threadLock) - если lock {} с этим маркером не запущен где-то ещё, то значит он
              {                                  //   открыт, и его можно занять. Как только поток входит в блок, lock {} с этим маркером
                  for (int i = 0; i < 7; i++)    //   блокируется. Как только поток завершает этот блок, lock {} с этим маркером открывается
                  {                              // Console.WriteLine() - этот метод теперь никогда не будет работать в двух потоках
                      Console.Write("{0} ", i);  //   одновременно (если все потоки попытаются войти в lock {} с одинаковым маркером)
                  }                              // {} - если нужно синхронизировать только одну команду, то, как и везде, скобки можно не
              }                                  //   писать
          }
        //
          Thread[] threads1 = new Thread[3];         // threads1 - те же 3 потока
          for (int i = 0; i < threads1.Length; i++)
          {
              threads1[i] = new Thread(new ThreadStart(PrintNumbers1));
          }
        //
          foreach (Thread curr in threads1)
          {
              curr.Start();                         // curr.Start() - они также стартуют почти одновременно (дальше всё зависит от настроения
          }                                         //   планировщика потоков)
        //
          foreach (Thread curr in threads1)
          {
              curr.Join();
          }
          Console.Write("\n\n");
        //
        //   Если ты запустишь именно этот метод, то увидишь желанные 3 аккуратные последовательности, а значит, наши 3 потока, что были
        //     посланы выполнять функцию PrintMessages1(), действительно выполнили его, не мешая друг другу
        //   Автор рекомендует использовать в качестве маркера в закрытых методах ссылку на сам объект (т.е. this), а для открытых - создать
        //     специальное закрытое поле-заглушку, и использовать его, т.к., как он говорит, так безопаснее (ведь маркер не должен быть
        //     общедоступен. Если он будет заблокирован в другом, неконтролируемом этой программой участком кода, то он может дальше вообще
        //     не разблокироваться. На самом деле в одной статье говорится, что по этой же причине больше не рекомендуется использовать даже
        //     this в качестве маркера). Для статических членов рекомендуется создать закрытое статическое поле типа object
        //


        // Synchronization with System.Threading.Monitor
        //
        //   Как оказалось, оператор lock языка C# - это всего лишь сокращение для работы со статическим классом System.Threading.Monitor.
        //     Так, инструкция
        //  
        //         lock (x)
        //         {
        //             //...
        //         }
        //  
        //     переводится компилятором в:
        //  
        //         object __lockObj = x;
        //         bool __lockWasTaken = false;
        //         try
        //         {
        //             System.Threading.Monitor.Enter(__lockObj, ref __lockWasTaken);    // ..Monitor.Enter() - именно здесь и застревают
        //             //...                                                             //   потоки в случае, если lock {} заблокирован
        //         }
        //         finally
        //         {
        //             if (__lockWasTaken) System.Threading.Monitor.Exit(__lockObj);     // ..Monitor.Exit() - а здесь lock {} разблокируется
        //         }                                                                     //   (т.к. finally, даже в случае исключения, маркер
        //                                                                               //   будет разблокирован)
        //  
        //     (это легко проверить через ilasm.exe)
        //   До C# 4.0 компилятор переводил lock в немного другие инструкции (раньше не создавался __lockWasTaken, и Monitor.Enter()
        //     нахоидлся перед try {})
        //   Как ты видишь, напрямую использовать System.Threading.Monitor нет необходимости. Тем не менее с ним ты получишь большую степень
        //     контроля над кодом. Например, с помощью System.Threading.Monitor.Wait() ты можешь разблокировать маркер и заставить ждать
        //     текущий поток до тех пор,
        //     пока кто-нибудь снова не заблокирует объект (т.е. первый поток просто ждёт, пока кто-нибудь другой не зайдёт в гости),
        //     System.Threading.Monitor.Pulse() уведомляет один поток из очереди с заданным маркером, что можно приступать к делу
        //     (..PulseAll() уведомляет всех), и т.д.
        //


        // Synchronization with System.Threading.Interlocked
        //
        //   Человеку, не испробовавшему CIL-код, трудно поверить, что операция присваивания и простые арифметические операции не атомарны
        //     (т.е. не цельны, а значит подержаны проблеме многопотока). По этой причине создатели .NET решили предоставить тип, который
        //     должен атомарно оперировать одиночными элементами данных (без этого класса всем бы пришлось применять lock {} на каждый чих с
        //     данными). Вот некоторые члены статического класса System.Threading.Interlocked (кроме стадантрых)(что и стал этим подарком
        //     богов):
        //  
        //         CompareExchange<T>()  - проверяет два значения на равенство, и, если они равны, то заменяет первое третьим (его 
        //                                 протоипа - T ..<T>(ref T, T, T)). Ещё есть не
        //                                 обобщённые версии этого метода, работающие с числами, IntPtr и object
        //         Decrement()           - уменьшает int объект на 1 (или long во второй версии)
        //         Exchange<T>()         - присваивает левому объекту правое. Тоже имеет необобщённые версии
        //         Increment()           - увеличивает int объект на 1 (или long во второй версии)
        //  
        //     Все эти операции не боятся проблемы многопотока. Хотя это сразу не видно (так говорит автор), но атомарные изменения отдельных
        //     объектов довольно часто применяется в многопоточной среде
        //   Вот несколько примеров:
        //
          int intVal = 83;
          int newIntVal = 20;
          Console.WriteLine("intVal is {0}, newIntVal is {1}", intVal, newIntVal);
        //
          newIntVal = Interlocked.Increment(ref intVal);                                            // .. = ..Increment() - как и настоящий
          Console.WriteLine("After increment intVal is {0}, newIntVal is {1}", intVal, newIntVal);  //  постфиксный инкремент (..++),
                                                                                                    //  возвращает получившийся результат
        //
          newIntVal = Interlocked.Exchange(ref intVal, 83);                                         // .. = ..Exchange() - уже не похож на
          Console.WriteLine("After Exchange intVal is {0}, newIntVal is {1}\n", intVal, newIntVal); //   настоящюю операцию присваивания,
                                                                                                    //   т.к. возвращает оригинальное
                                                                                                    //   значение
        //
        //


        // Synchronization with System.Runtime.Remoting.Contexts.Synchronization
        //
        //   Последний из примитивов синхронизации, что мы здесь рассмотрим, - атрибут [Synchronization], что находится в пространстве имён
        //     System.Runtime.Remoting.Contexts. Да он уже был упомянут при рассмотрении контекстов (там ты
        //     узнал, как он работает)
        //   Синхронизацию кода посредством [Synchronization] по праву можно назвать способом для ленивых, т.к. одной строки кода достаточно,
        //     чтобы в дальнейшем не иметь никаких проблем с потоками во всех членах класса. Даже несмотря на то, что подвержеными проблеме
        //     многопотока может быть только парочка из них
        //


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   SystemThreadingNamespaceExtra_Silent()");
    }
}