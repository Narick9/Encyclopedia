/*
 * creation date  21 aug 2021
 * last change    01 sep 2021
 * author         artur
 */
using System;

class _Git_ASPNETPreview
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        Git_Silent();
        ASPNETPreview_Silent();

        Console.ReadLine();
    }
    static void Git_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Git_Silent()\n");


        // What It Is
        //
        //   Ты, наверное, часто слышал об этой штуке. Работадатели уверяют, что знание git'а - это большой плюс для них
        //     
        //   git - "тот самый простетский хранитель начинки" (так написано в оффициальной man-странице). В общем и целом,
        //     он может просто делать снимок какой-нибудь директории, и сохранять его в компактный .git файл. Если ты захочешь
        //     откатить свою работу, ты можешь восстановить всю директорию из этого снимка
        //     
        //   Git быстр и масштабируем (в смысле, что его работа не зависит от размеров твоего проекта), и с помощью него ты можешь держать
        //      много версий своего решения
        //     
        //     
        //   Первый версии git писал сам Линус Торвальдс. Вот что он сам говорит о git'е:
        //     
        //         We will hereby start scouring the net for people 
        //         who say git is hard to understand and use, 
        //         and just kill them. 
        //         They clearly are just polluting the gene pool. 
        //         
        //          --Linus Torvalds
        //     


        // Commands (sections)
        //     
        //   У git'а есть набор подразделов (комманд)(как и у dotnet cli)
        //     
        //
        //   git help
        //     
        //     Первый, и самый нужный, - это раздел git help. Синопсис таков:
        //     
        //             git help [options] [<command|guide>]
        //     
        //         На место <command|guide> ты подставляешь нужный тебе раздел (****или какой-то гайд), и тебе откроется man-страница с нужной
        //         инфой
        //     
        //     На самом деле ты можешь открыть те же man-страницы, используя саму утилиту man. Это выглядит примерно так:
        //     
        //             man git-<command|guide>
        //     
        //         Например,    man git-log    выведет тебе ровно ту же инфу, что и    git help log
        //     
        //     ****у git help есть ещё много опций
        //     
        //     
        //   git config
        //     
        //     Если ты прочёл документацию git'а (хотя-бы man-страницу gittutorial), то знаешь, что первым делом лучше сконфигурировать его.
        //         Как минимум нужно создать свой git-профиль. Вот самый простой способ сделать это:
        //      
        //             git config --global user.name "YourName"
        //             git config --global user.email "your@email.com"
        //         
        //     Все опции выглядят так:
        //         --global  - записывает опции в общий для юзера ~/.gitconfig
        //                     /////////after reading: git init/////////////////////////////////////////////////////////////
        //                     // , а не в репозиторий ./.git/config
        //                     /////////////////////////////////////////////////////////////////////////////////////////////
        //                     . Если файла ~/.gitconfig нету, записывает опции в $XDG_CONFIG_HOME/git/config
        //                     
        //         --
        //         --
        //         --
        //         --
        //         --
        //         --
        //         --
        //         --****
        //       
        //     git построен так, чтобы читать некоторые $переменные окружения. Вот они:
        //             GIT_AUTHOR_NAME
        //             GIT_AUTHOR_EMAIL
        //             GIT_AUTHOR_DATE
        //             GIT_COMMITTER_NAME
        //             GIT_COMMITTER_EMAIL
        //             GIT_COMMITER_DATE
        //             XDG_CONFIG_HOME
        //             GIT_EDITOR
        //         Эти переменные (если они определены) находятся в приоритете у всех команд git'а
        //       
        //       
        //       
        //       
        //       
        //       
        //   git init
        //        
        //     Этот подраздел создан для инициализации репозитория (или переинициализации уже имеющегося). Синопсис прост:
        //        
        //            git init [options] [<pathToDir>]
        //        
        //         Если ты просто введёшь git init, то прямо в текущей папке создастся директория ./.git/, гордо именуемая "репозиторием"
        //         (если задана переменная $GIT_DIR, то ./.git/ создана не будет, а весь репозиторий создастся по адресу в ней).
        //         Эта директория сразу будет имет каркас в виде:
        //             ./.git/branches/    -
        //             ./.git/config       -
        //             ./.git/description  -
        //             ./.git/HEAD         -
        //             ./.git/hooks/       -
        //             ./.git/info/        -
        //             ./.git/objects/     - ****для чего-то
        //                                   Если задана переменная $GIT_OBJECT_DIRECTORY, то директории sha1 (****что это?) будут создаваться
        //                                   по адресу в ней. А так, используется директория $GIT_DIR/objects (если переменная $GIT_DIR задана)
        //             ./.git/refs/        -
        //         
        //     Прописывать git init в директории с уже существующем репозиторием безопасно, ничего перезаписано не будет. Эта переинициализация
        //       полезна тем, что с ней репозиторий подбирает недавно добавленные шаблоны (****что это?)
        //        
        //     Из [options] здесь выбор такой:
        //             --  -
        //             --  -
        //             --  -
        //             --  -
        //             --  -
        //        
        //         
        //   git add
        //         
        //     Наконец, если ты хочешь сделать снимок своей директории, используй этот подраздел. Синопсис таков:
        //         
        //             git add [options] <.../*.*> ..
        //         
        //         Как видишь, ты можешь задать регулярное выражение для тех файлов, что ты хочешь добавить в снимок. Снимок будет сохранён
        //         в temporary staging area, что прозвали "index"эом. Ты можешь постоянно добавлять в этот снимок всё больше новых файлов,
        //         вводя    git add <..>    
        //         /////////after reading: git rm///////////////////////////////////////////////////////////////
        //         // (а также можешь удолять, вводя    git rm <..>    )
        //         /////////////////////////////////////////////////////////////////////////////////////////////
        //         /////////after reading: git commit///////////////////////////////////////////////////////////
        //         // . Сохранить снимок действтительно надолго ты можешь, задействовав подраздел git commit
        //         /////////////////////////////////////////////////////////////////////////////////////////////
        //         Несмотря на название, temporary staging area не забывает твои снимки. Можно считать, что это просто буффером, снимок
        //         которого ты можешь постоянно изменять
        //         
        //     Git tracks content not files. Многих сбивает с толку эта фраза (а именно тех, кто не понял сходу что значит отслеживать
        //         контент). Многие другие подобные программы также имеют у себя подобие раздела add. В них этот раздел говорит системе начать
        //         записывать найденные изменения в отдельный файл. Git пошёл другим путём: команда    git add    при встречи с новыми или
        //         недавно изменёнными файлами делает их снимки, и затем эти снимки целиком помещает в temporary staging area
        //         ****насколько я понял
        //         
        //         
        //   git commit (commit - с англ. совершить)
        //         
        //     Этот подраздел сделан для сохранения временных снимков в репозиторий в виде commit'ов. Сделай это, как только ты решишь, что
        //         твой временный снимок готов к увековечиванию. Каждый commit кроме своей начинки имеет ещё hash (что служит ему id) и
        //         message (сообщение, что ещё зовут комментарием). Из таких commit'ов собирается ветка - история изменений разработки. У
        //         каждой ветки есть своё название. Репозиторий может содержать в себе несколько веток:
        //         
        //                           ┌─────┐
        //                           │ C0  |
        //                           └──┬──┘
        //                              │
        //                              │
        //                              │
        //                              V
        //                           ┌──┴──┐
        //                           │ C1  ├───┐
        //                           └──┬──┘   │
        //                              │      V
        //                              │    ┌─┴───┐
        //                              │    │ C3  │ <──(But Fix)
        //                              V    └──┬──┘
        //                           ┌──┴──┐    │
        //                           │ C2  │    │
        //                           └──┬──┘    │
        //                              │       │      
        //                              │       │      
        //                              │       │      
        //                              │       │      
        //                           ┌──┴──┐    │
        //                           │ C4  ├─<──┘
        //                           └─────┘
        //         
        //     Новый сommit обычно делают после какого-то большого изменения (вроде добавления нового функционала, исправления бага. иногда
        //         просто в качестве завершения рабочего дня)
        //         
        //     Синопсис, кстати, таков:
        //         
        //             ****здесь должен быть синопсис. строка ниже - продолжение
        //         
        //         Выполнить    git commit    не удастся, если ты ещё не представился git'у (ему нужна инфа $GIT_AUTHOR_NAME,
        //         $GIT_AUTHOR_EMAIL, $GIT_CIMMITTER_NAME и $GIT_COMMITTER_EMAIL. эту инфу также можно задать через подраздел git config)
        //         
        //     Выполнив команду    git commit    , тебе откроется prompt с текущим снимком (prompt здесь - это как-бы файл, что откроется в
        //         редакторе. будет использован редакторе, что назначен в $GIT_EDITOR. если такая переменная окружения не назначена, откроется
        //         в редакторе , что назначен в $EDITOR). В этом prompt'е тебе ты
        //         можешь оставить сообщение, описывающее изменения в этом commit'е по сравнению с предыдущими (хорошой привычкой считается
        //         первыми строчками оставить общую сводку об изменениях, не больше 50 символов)
        //     В этом promp'е уже будет достаточно подробно расписаны детальные логи о том, что будет добавлено или
        //         изменено, но все эти строчки закоментированны. Закоментированные строчки будут пропущенны, так что ты сам решаешь, что
        //         добавить в сообщение. Составив сообщение, тебе следует сохранить этот файл, этим ты совершишь commit
        //     Есть такая утилита, git-format-patch. Её суть в том, что она упаковывает commit в email. Первые строчки она использует в качестве
        //         загаловка к email-сообщению, а весь последующий текст помещает в тело
        //         
        //     Стартовая ветка по умолчанию зовётся "master"
        //         
        //     Некоторые [options] здесь действительно полезны:
        //             --all, -a        с этим флагом команда    git commit    сама заметит изменения файлов в проекте и за'commit'ит
        //                              получившийся снимок (но новые файлы в снимок добавленны не будут)(используй этот флаг, если тебе не
        //                              нужно точечно выбирать файлы через раздел git add)
        //             --
        //             --
        //             --
        //             --
        //         
        //         
        //   git diff and git status
        //         
        //     Перед тем, как сделать очередной commit из снимока, ты можешь захотеть посмотреть на то, чем он отличается от предыдущих
        //         commit'ов. Для этого действия создатели выделили раздел git diff. Синопсис таков:
        //         
        //             git diff [options] ****не полный синопсис
        //         
        //         Простой ввод git diff отправит тебя в read-only prompt, где будут описаны отличия текущего снимка от прошлого commit'а (всё
        //         это в текстовом виде. будут показаны отличающиеся файлы и отличающиеся строчки в каждом файле)(prompt будет открыт в утилите
        //         less)
        //         
        //         
        //    Если ты всего лишь хочешь получить краткую сводку об изменениях со времён последнего commit'а, воспользуйся подразделом
        //         git status. Простой ввод    git status    выдаст тебе список модифицированных файлов
        //         
        //         
        //   git log
        //         
        //     Историю commit'ов ты можешь посмотреть, используя этот раздел. Синопсис прост:
        //         
        //             git log [options] ...(непонятный синопсис)
        //         
        //     Каталог [options] очень обширен:
        //         
        //             --patch, -u, -p          вывести полный список изменений между каждым commit'ом (как если бы ты прописывал git diff
        //                                      между ними)
        //         
        //         
        //   git branch and git switch and git merge
        //         
        //     Как уже говорилось, git репозиторий может хранить в себе несколько веток разработки. Работать с ветками можно средствами раздела
        //         git branch. Синопсис раздела прост:
        //         
        //             git branch [options] [<branchName>]
        //         
        //     Как видишь, чтобы создать новую ветку, достаточно ввести имя для неё. Допустим, мы хотим создать ответвление "experimental"
        //         
        //             git branch experimental
        //         
        //     Если ты введёшь просто    git branch    , то получишь список существующих веток. Выглядит это так:
        //         
        //               experimental
        //             * master
        //         
        //         Как ты понял, звёздочкой помечена текущая ветка
        //         
        //     Сменить текущую ветку можно, используя раздел git switch. Синопсис у этого раздела простетский:
        //         
        //             git switch [options] <branch>
        //         
        //     Мы переходим в ветку experimental, введя    git switch experimental    . Эта команда своим выхлопом покажет, какие файлы были
        //         изменены, но таки неза'commit'чены в предыдущей ветке. У меня выхлоп выглядил так:
        //         
        //             M	44-_Git_ASPNETPreview.cs
        //             M	6-ClassAndInterface_StructAndOOPAndSystemNullable.cs
        //             M	changelog.txt
        //             Switched to branch 'experimental'
        //         
        //     Теперь можно сделать несколько изменений и не беспокоится о их последствиях, ведь мы сейчас в ветке "experimental" (а она живёт
        //         отдельно от основной ветки "master". За'commit'им эти изменения, запустив команду    git commit -a    . Вернёмся снова на
        //         ветку "master", запустив это:
        //         
        //             git switch master
        //         
        //         Если у тебя были неза'commit'ченные изменения в файлах, git switch вежливо тебе скажет об этом, и прервёт выполнение. Вот
        //         что получил я:
        //         
        //             error: Your local changes to the following files would be overwritten by checkout:
        //             44-_Git_ASPNETPreview.cs
        //             Please commit your changes or stash them before you switch branches.
        //             Aborting
        //         
        //         После за'commit'чивания этих изменений и таки выполнения команды    git switch master    ты моментально заметишь, что
        //         файлы стали перезаписаны. Они так вернулись в то состояние, в котором ты их заснял последним commit'ом в ветке "master"
        //         
        //     На данный момент мы имеет две ветки, и начинка в них различается. Чтобы слить их воедино, нам следует воспользоваться разделом
        //         git merge    . Синопсис прост:
        //         
        //             git merge [options] <branch>
        //         
        //     Соединим наши ветки, введя    git merge experimental    . Т.к. конфилктов в начинке у нас не было, слияние произошло. Выхлоп
        //         был такой:
        //         
        //             Updating 317c4ba..b1dcaa5
        //             Fast-forward
        //              44-_Git_ASPNETPreview.cs                           | 182 +++++++++++++++++---
        //              ...ssAndInterface_StructAndOOPAndSystemNullable.cs |   6 +-
        //              changelog.txt                                      |  37 +++-
        //              3 files changed, 195 insertions(+), 30 deletions(-)
        //         
        //         Если конфликты таки были бы, операция бы не произошла. В этом случае тебе вручную следовало пройтись по проблемным файлам
        //         (которые git merge оставляет в выхлопе) с помощью git diff
        //         
        //         






        // Options
        //
        //   
        //     
        //     
        //     


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Git_Silent()");
    }
    static void ASPNETPreview_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   ASPNETPreview_Silent()\n");


        // WhatItIs
        //
        //   ASP.NET Core - он мощен, эффективен, oper source'ен и cross-platform'енен. Собственно, на нём и строятся всё web'евское, вроде
        //     всеми любимых интернет сервисов
        //   На этой штуке, кстати, крутиться половина вакансий C#'овцев
        //   На момент 21 aug 2021, актуальна версия ASP.NET Core 5
        //
        //   Вообще, ASP - это Active Server Pages
        //
        //   В ASP.NET'е строится как UI, так и API (т.е. весь твой сайтик целиком может быть в одном проекте)
        //   ASP.NET конструировался так, чтоб его легко могли тестировать
        //
        //   ASP.NET Core - быстрейший веб-фреймворк на планете
        //     (пруф - https://www.techempower.com/benchmarks/#section=data-r19&hw=ph&test=plaintext&a=2?azure-portal=true)! Точнее, был
        //     какое-то время
        

        // ASP.NET History
        //
        //   В старые до'.NET'ные времена (времена Windows NT) эта штука (тогда ещё звавшаяся ASP) была аддоном (и ставилась отдельно) к
        //     Internet Information Server. Когда .NET релизнули, из этого add-on'а и сделали ASP.NET
        //   Как и многие другие составные части .NET'а, ASP.NET (на протяжении лет) как минимум несколько раз сильно менял свою форму
        //  
        //   Изначально был ASP.NET Web Forms, где разработчики писали код и скрипты, чтоб затем этот движок перевёл код в HTML
        //   Затем, в 2009-ом был релизнут ASP.NET MVC, и это сильно всех потрясло. MVC (Model-View-Controller, о нём ниже)
        //     появился именно в то время. На таком ASP.NET'е мы сейчас и живём
        //
        //   В самом начала назревания cross-platform революции (2016 год) Micro$oft'цы, в паре с .NET Core 1.0, выпустили ASP.NET Core 1.0
        //     (а иначе кто бы вообще перезаживался на .NET Core?). Конечно, как ты помнишь, эти индусы взяли фактически уже готовый продукт
        //     , что разработали чуваки для проекта Mono
        //
        //   До cross-platform революции ASP.NET звался ASP.NET 4.x (да и вообще тогда весь .NET Framework был версии 4.x), после он
        //     переименовался в ASP.NET Core. Новая редизайненная версия оказалась чуть стройнее и модульнее. Алсо, Microsoft, ставши
        //     community-ориентированной Корпорацией Зла, запустила .NET Live TV (нет, правда, https://dotnet.microsoft.com/live)(хотя
        //     напоминает это всё детский сад. маскот-робот присутствует)


        // MVC
        //
        //   Допустим, мы пишем сайт, где клиенты могут покупать какие-то вещи. Эти самые товары - это Models (модели). На сайт заходит клиент,
        //     он смотрит товары, получает инфо о них, складывает в корзину. Эти действия - Controllers, т.е. эти действия для управления
        //     моделями (попросить модель выдать инфу, заставить модель перейти в корзину, попросить модель о скидке). Пользователь, конечно,
        //     видит все изменения товаров у себя на экране (инфу о модели, скидку, ...) - эта часть зовётся View
        //
        //   Ну т.е. понимаешь, да?
        //
        //       > Model - представляет данные, реагируют на команды контроллера, изменяя своё состояние
        //       > View - отвечает за отображение модели пользователю, реагируя на изменение модели
        //       > Controller - интерпретирует действия пользователя, оповещяя модель о необходимости измений
        //
        //   MVC, как ты понял - шаблон (pattern). Он описывает только общее положение дел. А это значит, что нет никакой разницы в том, на
        //     каком языке этот шаблон реализован
        //
        //   Вся фишка MVC в том, что он разделяет всё приложение на 3-и большие части, полностью независимые друг от друга. Это даёт
        //     сильнейший плюс к тестируемости


        // Alternatives
        //
        //   Silverlight
        //  
        //       На самом деле, кроме ASP.NET'а существовало ещё несколько задумок для web-базы. Например, Silverlight, который шёл как плагин
        //           к браузерам. Идея состояла в том, что, раз уж браузеры так сильно ограничивают код в себе (привет, интернет-игрушки!),
        //           почему бы не построить мост за пределы браузера?
        //       Пользоваться этим, правда, никто не стал. На сегодняшний день Silverlight считается заброшенным
        //  
        //   Windows 8's app model
        //  
        //       По этой модели разработчикам следовало писать GUI приложения, использующие HTML для разметки графики. Да, это вообще не
        //           касается настоящего web'а ****но Прайс почему-то решил написать об этом. Эта модель также оказалась почти никем не
        //           тронута, ведь запуск Windows 8 был полным провалом (и люди туда не шли)


        // Where you can put it
        //
        //   > Kestrel
        //   > IIS
        //   > HTTP.sys
        //   > Nginx
        //   > Apache
        //   > Docker
        //


        // How web works
        //
        //   Если в кратце, то твой шлюз в интерент - браузер. Он может связывать с серверами по провадам или как-то ещё. Ты открываешь его,
        //     открываешь какой-то сайт. Он, получив из имени этого сайта IP код (те самые 122.00.4), пытается достучатся до этого сервера.
        //     Сервер откликается, шлёт свою картинку (и какую-то логику) в ответ (предварительно разложив это всё в пакеты). Ты, видя
        //     кнопки/ссылки/что-тоЕщё, конечно, можешь нажать на них, и запустить какую-то связанную логику. Логика может попросить бразуер
        //     снова связаться с сервером, чтоб получить новый пакет с нужной сейчас инфой. Примерно так
        //
        //   На самом деле браузер - это не единственный шлюз в интернет. Он просто был сделан одним из первых, т.к. все изначально решили, что
        //     сайтики - прекрасная вещь
        //


        // HTTP, www  //after How web works
        //
        //   HTTP - Hyper Text Transfer Protocol. Это как раз тот протокол (т.е. набор соглашений), по которому перемещаются пакеты между
        //     клиентами и серверами. Именно HTTP определил для всех, какой вид должны иметь пакеты с данными, как они должны отправляться, как
        //     они должны идти и как они должны приниматься
        //   ASP.NET, конечно, работает с HTTP искаропки. Это очень хорошо, ведь получается, что данные проходят весь путь от конца к концу
        //     в виде неприступных HTTP пакетов
        //     /////////after reading: HTTPS////////////////////////////////////////////////////////////////
        //     // (на самом деле обычные http пакеты очень даже приступны. если хочешь обезопаситься, юзай
        //     // https пакеты)
        //     /////////////////////////////////////////////////////////////////////////////////////////////
        //
        //   www - World Wide Web. Эта штука связывает клиенты (компьютеры пользователей) с серверами
        //   


        // HTTPS!
        //   
        //   HTTPS - то же, что HTTP, но Secure. Имея солидный опыт сёрфинга инета, ты давно понял, что следует заходить только на
        //     https://-сайты
        //   Если говорить поподробнее, то HTTPS защитит твои пакеты от атак перехватичков между сервером и клиентом. Точнее, перехватить они
        //     такие пакеты всё ещё смогут, но вот получить инфу - нет
        //   
        //   Помнишь флаг --no-https, что ставиться при создании webapi приложений через утилиту dotnet (полная команда выглядит так:
        //         dotnet new webapi --no-https    )? Как ты понял ещё тогда, по умолчанию dotnet создаёт проекты с HTTPS сертификатом
        //


        // REST  //after HTTP
        //
        //   REST - Representational State Transfer (надмозг. переноситель репрезентативного состояния). Если вкратце, то это такой стиль
        //     построения web-сервиса (иначе говоря, web-службы, или web API). REST запросы (****что это?) строятся на HTTP, т.е. они
        //     описываются на том же синтаксисе, на котором браузеры принимают и отправляют пакеты из интернета
        //     
        //   Вот некоторые слова из синтаксиса HTTP:
        //       > GET     - инструкция для получения данных из web-сервиса 
        //       > POST    - создать новый пакет в web-сервисе
        //       > PUT     - обновить пакет в web-сервисе
        //       > PATCH   - обновить пакет в web-сервисе, отправив набор инструкция для него
        //       > DELETE  - удалить пакет в web-сервисе
        //     
        //   Web-сервисы, что построены в соостветствии с REST, зовутся RESTful APIs
        //  
        //   Всякая RESTful web-сервисная API строится из:
        //  
        //       > Базового URL
        //       > HTTP инструкций
        //       > Каких-нибудь файлов с данными (вроде JSON'ов или XML)
        //
        //****ничего не понятно, ты должен знать больше!
        

        // .NET HTTP REPL
        //    
        //    Традиционно вебсайты тестировались их создателями прямо в браузере. Но индусы из Microsoft решили сделать более удобную штуку -
        //      .NET HTTP REPL (Read-Eval-Print-Loop). Это такая cmd утилитка для тестирования каждой фишки твоего будущего сайта
        //      (****но это не точно)


        // Create your own webapp
        //     
        //   Простенький сайт делается этой командой:
        //     
        //         dotnet new webapp
        //     
        //     Я создал директорию ./SimpleWebApp_ASP.NET/, и произвёл эту инструкцию там
        //
        //   Если ты раньше не создавал никаких ASP.NET проектов, то dotnet cli установит в себя новый .NET runtime -
        //     Microsoft.AspNetCore.App (все runtime'ы ты можешь посмотреть, введя dotnet --info). Также dotnet cli обзаведётся новыми
        //     подкатегориями параметров. Вот они (****возможно, они не относятся к ASP.NET'у):
        //         > dev-certs                             - ****
        //         > fsi                                   - ****
        //         > sql-cache                             - ****
        //         > user-secrets                          - ****
        //         > watch <program>                       - запускать file watcher, что запустит программу, как только файлы изменятся. Можно
        //                                                   использовать в паре с run (вводя    dotnet watch run ...    ), и dotnet cli
        //                                                   будет запускать проект по новой при изменениях в нём (****я так понял)
        //                                                   
        //                                                   
        //
        //   ****нужно как-то сделать https сертификат для dotnet cli
        //     
        //   Запустить этот проект лучше, задействовав подраздел watch:
        //
        //         dotnet watch run
        //     
        //     Сделав это, ты увидешь, что (..) ничего не происходит (кроме выплёскивание логов в терминал). Но на самом деле твой сайт
        //     запустился на Kestrel web сервере (****но это не точно****а что это?), ты просто не открыл его. https://localhost:5001 - вот где
        //     хостится твой первый вебсайт
        //     
        //   В этом проекте есть директория ./SimpleWebApp_ASP.NET/Pages/, файлы в ней описывают то, как страницы этого сайта должны выглядеть.
        //     По умолчанию рисуется вполне симпатичная страница, хоть она и содержит в себе всего несколько элементов. Ты можешь открыв
        //     https://localhost:5001 и посмотреть на неё сам
        //     
        //     Razor page
        //     
        //          Файл ./../Pages/Index.cshtml задаёт вид главной страницы. В этом файле имеются мои комментарии
        //          
        //          
        //          


        // Create your own webapi
        //     
        //   Простетский проект web-сервиса создаётся так:
        //     
        //         dotnet new webapi --no-https
        //     
        //     Ты уже знаком с этой командой. Выполнив её, ты получишь некоторые незнакомые тебе файлы и директории. Если конкретно, эти
        //     (я создал директорию ./ContosoPizza_ASP.NET/, и выполнил команду в ней):
        //     
        //       > ./Controllers/                - здесь храниться класс WeatherForecastController, определяющий в себе HTTP инструкцию GET
        //                                         (в виде C#-повского метода Get() с атрибутом [HttpGet])
        //       > Program.cs                    - собственно, стартовая точка программы. Метод Main() создаёт хост
        //       > Startup.cs                    - а этот метод конфигурирует твой хост при старте****но это не точно
        //       > appsettings.Development.json  - ****
        //       > appsettings.json              - ****
        //       > WeatherForecast.cs            - здесь хранится сам класс ContosoPizza_ASP.NET.WeatherForecast, его объекты будут хранить
        //                                         данные о прогнозах погоды
        //     
        //   Компилирование и запуска проекта производится этим:
        //         
        //         dotnet run
        //
        //     ****ты перенёс отсюда большой кусок текста в блок о webapp
        //     (но это не ссылка на страницу сайта. если ты откроешь её, твой браузер не найдёт ничего)(если бы мы не прописали
        //     флаг --no-https, сайт бы хостился на https://localhost:5001). Перейди по ссылке http://localhost:5000/weatherforecast, чтобы
        //     действительно посмотреть на результат. Ты увидишь начинку json-файла (хоть и в неудобном оформлении)! Именно в
        //     этот json файл и были упакованы объекты типа ContosoPizza_ASP.NET.WeatherForecast
        //     
        //****что такое webapi?


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   ASPNETPreview_Silent()");
    }
}