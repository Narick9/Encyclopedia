/*
 * creation date  21 aug 2021
 * last change    14 sep 2021
 * author         artur
 */
using System;

class _Git_ASPNETPreview
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        Git_Silent();
        ASPNETPreview_Silent();

        Console.ReadLine();
    }
    static void Git_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Git_Silent()\n");


        // What It Is
        //
        //   Ты, наверное, часто слышал об этой штуке. Работадатели уверяют, что знание git'а - это большой плюс для них
        //     
        //   git - "тот самый простетский хранитель начинки" (так написано в оффициальной man-странице). В общем и целом,
        //     он может просто делать снимок какой-нибудь директории, и сохранять его в компактный .git файл. Если ты захочешь
        //     откатить свою работу, ты можешь восстановить всю директорию из этого снимка
        //     
        //   Git быстр и масштабируем (в смысле, что его работа не зависит от размеров твоего проекта), и с помощью него ты можешь держать
        //      много версий своего решения
        //     
        //     
        //   Первый версии git писал сам Линус Торвальдс. Вот что он сам говорит о git'е:
        //     
        //         We will hereby start scouring the net for people 
        //         who say git is hard to understand and use, 
        //         and just kill them. 
        //         They clearly are just polluting the gene pool. 
        //         
        //          --Linus Torvalds
        //     


        // Commands (sections)
        //     
        //   У git'а есть набор подразделов (комманд)(как и у dotnet cli)
        //     
        //


        //   git help
        //       
        //       Первый, и самый нужный, - это раздел git help. Синопсис таков:
        //       
        //               git help [options] [<command|guide>]
        //       
        //           На место <command|guide> ты подставляешь нужный тебе раздел (****или какой-то гайд), и тебе откроется man-страница с
        //           нужной инфой
        //       
        //       На самом деле ты можешь открыть те же man-страницы, используя саму утилиту man. Это выглядит примерно так:
        //       
        //               man git-<command|guide>
        //       
        //           Например,    man git-log    выведет тебе ровно ту же инфу, что и    git help log
        //       
        //       ****у git help есть ещё много опций
        //       
        //       


        //   git config
        //       
        //       Если ты прочёл документацию git'а (хотя-бы man-страницу gittutorial), то знаешь, что первым делом лучше сконфигурировать его.
        //           Как минимум нужно создать свой git-профиль. Вот самый простой способ сделать это:
        //        
        //               git config --global user.name "YourName"
        //               git config --global user.email "your@email.com"
        //           
        //       Все опции выглядят так:
        //           --global  - записывает опции в общий для юзера ~/.gitconfig
        //                       /////////after reading: git init/////////////////////////////////////////////////////////////
        //                       // , а не в репозиторий ./.git/config
        //                       /////////////////////////////////////////////////////////////////////////////////////////////
        //                       . Если файла ~/.gitconfig нету, записывает опции в $XDG_CONFIG_HOME/git/config
        //                       
        //           --
        //           --
        //           --
        //           --
        //           --
        //           --
        //           --
        //           --****
        //         
        //       git построен так, чтобы читать некоторые $переменные окружения. Вот они:
        //               GIT_AUTHOR_NAME
        //               GIT_AUTHOR_EMAIL
        //               GIT_AUTHOR_DATE
        //               GIT_COMMITTER_NAME
        //               GIT_COMMITTER_EMAIL
        //               GIT_COMMITER_DATE
        //               XDG_CONFIG_HOME
        //               GIT_EDITOR
        //           Эти переменные (если они определены) находятся в приоритете у всех команд git'а
        //         
        //         
        //         
        //         
        //         
        //         


        //   git init
        //          
        //       Этот подраздел создан для инициализации репозитория (или переинициализации уже имеющегося). Синопсис прост:
        //          
        //              git init [options] [<path-to-dir>]
        //          
        //           Если ты просто введёшь git init, то прямо в текущей папке создастся директория ./.git/, гордо именуемая "репозиторием"
        //           (если задана переменная $GIT_DIR, то ./.git/ создана не будет, а весь репозиторий создастся по адресу в ней).
        //           Эта директория сразу будет имет каркас в виде:
        //               ./.git/branches/    -
        //               ./.git/config       -
        //               ./.git/description  -
        //               ./.git/HEAD         -
        //               ./.git/hooks/       -
        //               ./.git/info/        -
        //               ./.git/objects/     - ****для чего-то
        //                                     Если задана переменная $GIT_OBJECT_DIRECTORY, то директории sha1 (****что это?) будут
        //                                     создаваться по адресу в ней. А так, используется директория $GIT_DIR/objects (если переменная
        //                                     $GIT_DIR задана)
        //               ./.git/refs/        -
        //           
        //       Прописывать git init в директории с уже существующем репозиторием безопасно, ничего перезаписано не будет. Эта
        //           переинициализация полезна тем, что с ней репозиторий подбирает недавно добавленные шаблоны (****что это?)
        //          
        //       Из [options] здесь выбор такой:
        //               --bare               - создать голый репозиторий (т.е. новоиспечённый репозиторий развернётся не в директории ./.git/,
        //                                      а прямо в текущей папке. если задана GIT_DIR, то генерироваться репа будет там)
        //               --  -
        //               --  -
        //               --  -
        //               --  -
        //          
        //           


        //   git add
        //           
        //       Наконец, если ты хочешь сделать снимок своей директории, используй этот подраздел. Синопсис таков:
        //           
        //               git add [<options>] <./../*.*> ..
        //           
        //           Как видишь, ты можешь задать регулярное выражение для тех файлов, что ты хочешь добавить в снимок. Снимок будет сохранён
        //           в temporary staging area, что прозвали "index"эом. Ты можешь постоянно добавлять в этот снимок всё больше новых файлов,
        //           вводя    git add <..>    
        //           /////////after reading: git rm///////////////////////////////////////////////////////////////
        //           // (а также можешь удолять, вводя    git rm <..>    )
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           /////////after reading: git commit///////////////////////////////////////////////////////////
        //           // . Сохранить снимок действтительно надолго ты можешь, задействовав подраздел git commit
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           Несмотря на название, temporary staging area не забывает твои снимки. Можно считать, что это просто буффером, снимок
        //           которого ты можешь постоянно изменять
        //           
        //       Git tracks content not files. Многих сбивает с толку эта фраза (а именно тех, кто не понял сходу что значит отслеживать
        //           контент). Многие другие подобные программы также имеют у себя подобие раздела add. В них этот раздел говорит системе
        //           начать записывать найденные изменения в отдельный файл. Git пошёл другим путём: команда    git add    при встречи с новыми
        //           или недавно изменёнными файлами делает их снимки, и затем эти снимки целиком помещает в temporary staging area
        //           ****насколько я понял
        //           
        //       Как же выглядит index (он же temporary staging area)? Добавленные через git add файлы хранятся в папке
        //           ./.git/objects/xx/yyyyyyyy/ (xx - хеш-значение директории файла, yyyyyyyy - хеш имени файла. хешы xx идут по порядку, т.е.
        //           00, 01, .. 09, 0a, 0b .. 0e, 0f, 10, 11, ..). Например, какой-нибудь файл может хранится так:
        //           
        //               ./.git/objects/9f/2422325cef705b7682418d05a538d891bad5c8
        //           
        //           Получается, что полный хеш этого файла - 9f2422325cef705b7682418d05a538d891bad5c8 (ты и сам можешь посмотреть свою
        //           staging area, используя ls). Сам файл ./.git/../2422325cef705b7682418d05a538d891bad5c8 - это архив
        //           /////////after reading git cat-file//////////////////////////////////////////////////////////
        //           // (его легко распаковать и вывести на экран через раздел git cat-file)(git cat-file говорит
        //           // , что объекты, т.е. архивы таких файлов имеют тип "blob", что с англ. "капля", "клякса")
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       Не хочешь, чтобы в index попадали какие-то файлы (например временные файлы *.o)? Это легко сделать, создав файл ./.gitignore !
        //           Просто занеси в него строчки с фильтрами для отсеивания неугодных файлов (например, добавь строчку с *.o)
        //           
        //       Вот [<options>] этого раздела:
        //               --all              - добавить всю директорию
        //               --
        //               --
        //           


        //   git commit (commit - с англ. совершить)
        //           
        //       Этот подраздел сделан для сохранения временных снимков в репозиторий в виде commit'ов. Сделай это, как только ты решишь, что
        //           твой временный снимок готов к увековечиванию. Каждый commit кроме своей начинки имеет ещё hash (что служит ему id) и
        //           message (сообщение, что ещё зовут комментарием). Из таких commit'ов собирается ветка - история изменений разработки. У
        //           каждой ветки есть своё название. Репозиторий может содержать в себе несколько веток:
        //           
        //                             ┌─────┐
        //                             │ C0  |
        //                             └──┬──┘
        //                                │
        //                                │
        //                                │
        //                                V
        //                             ┌──┴──┐
        //                             │ C1  ├───┐
        //                             └──┬──┘   │
        //                                │      V
        //                                │    ┌─┴───┐
        //                                │    │ C3  │ <──(But Fix)
        //                                V    └──┬──┘
        //                             ┌──┴──┐    │
        //                             │ C2  │    │
        //                             └──┬──┘    │
        //                                │       │      
        //                                │       │      
        //                                │       │      
        //                                │       │      
        //                             ┌──┴──┐    │
        //                             │ C4  ├─<──┘
        //                             └─────┘
        //           
        //       Новый сommit обычно делают после какого-то большого изменения (вроде добавления нового функционала, исправления бага. иногда
        //           просто в качестве завершения рабочего дня)
        //           
        //       Синопсис, кстати, таков:
        //           
        //               ****здесь должен быть синопсис. строка ниже - продолжение
        //           
        //           Выполнить    git commit    не удастся, если ты ещё не представился git'у (ему нужна инфа $GIT_AUTHOR_NAME,
        //           $GIT_AUTHOR_EMAIL, $GIT_CIMMITTER_NAME и $GIT_COMMITTER_EMAIL. эту инфу также можно задать через подраздел git config)
        //           
        //       Выполнив команду    git commit    , тебе откроется prompt с текущим снимком (prompt здесь - это как-бы файл, что откроется в
        //           редакторе. будет использован редакторе, что назначен в $GIT_EDITOR. если такая переменная окружения не назначена,
        //           откроется в редакторе , что назначен в $EDITOR). В этом prompt'е тебе ты
        //           можешь оставить сообщение, описывающее изменения в этом commit'е по сравнению с предыдущими (хорошой привычкой считается
        //           первыми строчками оставить общую сводку об изменениях, не больше 50 символов)
        //       В этом promp'е уже будет достаточно подробно расписаны детальные логи о том, что будет добавлено или
        //           изменено, но все эти строчки закоментированны. Закоментированные строчки будут пропущенны, так что ты сам решаешь, что
        //           добавить в сообщение. Составив сообщение, тебе следует сохранить этот файл, этим ты совершишь commit
        //       Есть такой раздел, git format-patch. Его суть в том, что она упаковывает commit'ы в email (о ней есть инфо ниже). Первые
        //           строчки она использует в качестве загаловка к email-сообщению, а весь последующий текст помещает в тело
        //           
        //       Стартовая ветка по умолчанию зовётся "master"
        //           
        //       Ты можешь удивится, но commit'ы сохраняются также в индексе. Т.е. commit на деле может выглядить так:
        //           
        //               ./.git/objects/9f/2422325cef705b7682418d05a538d891bad5c8
        //           
        //           /////////after reading: git cat-file/////////////////////////////////////////////////////////
        //           // Такой объект (т.е. файл commit'а) имееют тип "commit".
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           К каждому commit'у приставлен ещё один объект - типа "tree" (например,
        //           
        //               ./../da/c6721c3b75fcb3c9d87b18ba4cef2e15e0a3d3
        //           
        //           )
        //           
        //       Некоторые [options] здесь действительно полезны:
        //               --all, -a                    - с этим флагом команда    git commit    сама заметит изменения файлов в проекте и
        //                                              за'commit'ит получившийся снимок (но новые файлы в снимок добавленны не будут)
        //                                              (используй этот флаг, если тебе не нужно точечно выбирать файлы через раздел git add)
        //               --message=<msg>, -m=..       - задать сообщение <msg>. С этим параметром ты пропускаешь часть с prompt'ом
        //               --signoff, --no-signoff, -s  - добавить (или не добавить) в конец сообщения роспись. Значение этой росписи заранее
        //                                              декларируется командой разработки. Например, она может значить, что committer имеет
        //                                              права на размещение своих работ в этом проекте под определённой лицензией
        //                                              (****я так понял)
        //               --amend                      - заменить последний commit новым, вовлекая те же файлы, но оставив message (amend - с
        //                                              англ. исправить, чинить, улучшить)
        //               --no-edit                    - не входить в prompt для правки message'а (****почему-то часто используется вместе с
        //                                              --amend)
        //               --
        //           
        //           


        //   git status
        //           
        //       Если ты всего лишь хочешь получить краткую сводку об изменениях со времён последнего commit'а, воспользуйся подразделом
        //           git status. Простой ввод
        //           
        //               git status    
        //           
        //           выдаст тебе список модифицированных файлов
        //           
        //           


        //   git diff 
        //           
        //       git diff - посмотреть отличия текущей директории от текущего снимка в index'е. Ты, возможно, хочешь сделать это перед тем, как
        //           сделать очередной commit из этого снимка. Синопсис таков:
        //           
        //               git diff [options] ****не полный синопсис
        //           
        //           Простой ввод git diff отправит тебя в read-only prompt, где будут описаны отличия текущего состояния директории от
        //           staged снимка в index'е
        //           (всё это в текстовом виде. будут показаны отличающиеся файлы и отличающиеся строчки в каждом файле)(prompt будет открыт в
        //           утилите less)
        //           
        //       У раздела git diff имеются такие [otpions]:
        //               --cached           - выдать отличия между текущим индексом и последним commit'ом
        //               HEAD               - выдать отличия между всем рабочим древом и последним commit'ом
        //           
        //           


        //   git log - посмотреть историю commit'ов
        //           
        //       Историю commit'ов ты можешь посмотреть, используя этот раздел. Синопсис прост:
        //           
        //               git log [options] [tag..tag] [<path>...]
        //           
        //       По умолчанию будут выводится лишь messag'ы commit'ов
        //           
        //       /////////after reading: git tag///////////////////////////////////////////////////////////////
        //       // Помнишь про таги? По ним ты можешь ориентироваться в истории commit'ов. Например, ты
        //       //     можешь ввести это:
        //       //   
        //       //         git log v2.23..
        //       //   
        //       //     , и тебе выведут те коммиты, что были созданы после такого тага
        //       //   
        //       //   
        //       /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       Если история логов полностью поместится в один экран твоего терминала, выхлоп будет стандартный. Если история длиннее, то
        //           будет задействован prompt
        //           
        //       Каталог [options] очень обширен:
        //           
        //               --patch, -u, -p                  - вывести полный список изменений между каждым commit'ом (как если бы ты прописывал
        //                                                  git diff между ними)
        //               --since=<date>, --after=<date>   - показать логи, созданные после заданной даты (<date> может быть "3 days ago",
        //                                                  "2005-12-10")(после означает после начала дня. т.е. если ты напишешь
        //                                                      ..-after="2021-09-03..    , то тебе выйдут и commit'ы за этот день)
        //               --until=<date>, --before=<date>  - показать логи, созданные до заданной даты (формы <date> те же, что и у --since)
        //                                                  (эти параметры часто комбинируются с --since, --after)
        //               --oneline                        - уменьшить количество печатаемой информации. С этим ключом каждый commit будет
        //                                                  показан в одну строчку (в виде его хеш-значения и message'а), примерно так:
        //                                                      
        //                                                      2b82e80 You added graphical functions
        //                                                      657ab4c Initial commit
        //           
        //                                                  ****почему у этих commit'ов короткое хеш-значение?
        //               --
        //           


        //   git branch and git switch and git merge
        //           
        //       Как уже говорилось, git репозиторий может хранить в себе несколько веток разработки. Работать с ветками можно средствами
        //           раздела git branch. Синопсис раздела прост:
        //           
        //               git branch [options] [<branch-name>]
        //           
        //       Как видишь, чтобы создать новую ветку, достаточно ввести имя для неё. Допустим, мы хотим создать ответвление "experimental"
        //           
        //               git branch experimental
        //           
        //       Если ты введёшь просто    git branch    , то получишь список существующих веток. Выглядит это так:
        //           
        //                 experimental
        //               * master
        //           
        //           Как ты понял, звёздочкой помечена текущая ветка
        //           
        //       Сменить текущую ветку можно, используя раздел git switch. Синопсис у этого раздела простетский:
        //           
        //               git switch [options] <branch>
        //           
        //       Мы переходим в ветку experimental, введя    git switch experimental    . Эта команда своим выхлопом покажет, какие файлы были
        //           изменены, но таки неза'commit'чены в предыдущей ветке. У меня выхлоп выглядил так:
        //           
        //               M	44-_Git_ASPNETPreview.cs
        //               M	6-ClassAndInterface_StructAndOOPAndSystemNullable.cs
        //               M	changelog.txt
        //               Switched to branch 'experimental'
        //           
        //       Теперь можно сделать несколько изменений и не беспокоится о их последствиях, ведь мы сейчас в ветке "experimental" (а она
        //           живёт отдельно от основной ветки "master". За'commit'им эти изменения, запустив команду    git commit -a    . Вернёмся
        //           снова на ветку "master", запустив это:
        //           
        //               git switch master
        //           
        //           Если у тебя были неза'commit'ченные изменения в файлах, git switch вежливо тебе скажет об этом, и прервёт выполнение. Вот
        //           что получил я:
        //           
        //               error: Your local changes to the following files would be overwritten by checkout:
        //               44-_Git_ASPNETPreview.cs
        //               Please commit your changes or stash them before you switch branches.
        //               Aborting
        //           
        //           После за'commit'чивания этих изменений и таки выполнения команды    git switch master    ты моментально заметишь, что
        //           файлы стали перезаписаны. Они так вернулись в то состояние, в котором ты их заснял последним commit'ом в ветке "master"
        //           
        //       На данный момент мы имеет две ветки, и начинка в них различается. Влить в текущую ветку master наработки ветки experimental,
        //           нам следует воспользоваться разделом    git merge    . Синопсис прост:
        //           
        //               git merge [options] <branch>
        //           
        //       Соединим наши ветки, введя    git merge experimental    . Т.к. конфилктов в начинке у нас не было, слияние произошло. Выхлоп
        //           был такой:
        //           
        //               Updating 317c4ba..b1dcaa5
        //               Fast-forward
        //                44-_Git_ASPNETPreview.cs                           | 182 +++++++++++++++++---
        //                ...ssAndInterface_StructAndOOPAndSystemNullable.cs |   6 +-
        //                changelog.txt                                      |  37 +++-
        //                3 files changed, 195 insertions(+), 30 deletions(-)
        //           
        //           Если конфликты бы таки были, операция бы не произошла. В этом случае тебе вручную следовало пройтись по проблемным файлам
        //           (которые git merge оставляет в выхлопе) с помощью git diff. В итоге зако'commit'им новую версию ветки master, введя
        //               git commit -a    . Введя    git branch    ты увидишь, что в репозитории попрежднему 2'е ветки (master и experimental)
        //           
        //       git branch имеет такие [options]:
        //               --delete, -d <branch>          - удалить ветку <branch> из репозитория. Перед удалением эта ветка должна быть влита в
        //                                                ветку master (или какую-нибудь другую upstream ветку****что такое upstream ветка?)
        //               --force, -f                    - стандартная опция утилит unix для выполнения действия несмотря ни на что
        //               -D                             - shortcut для --delete --force
        //           
        //       git switch имеет эти [options]:
        //               --create, -c <branch>  [<from-this-branch>]  - перейти в ветку, что создатся прям сейчас (если <branch> уже есть -
        //                                                              процесс остановится). ****можно задать вторую ветку
        //                                                              [<from-this-brachn>] (возможно, чтобы конкретно указать откуда вывести
        //                                                              ветку)
        //               --force-create, C <branch>                   - то же, что и --create, но теперь, если <branch> уже имеется, процесс не
        //                                                              остановится


        //   git restore
        //           
        //           



        //   git clone
        //         
        //       Это тот самый раздел git, что ты часто использовал в своих приключениях по миру GNU/Linux. Суть проста - ты просто клонируешь
        //           чей-то репозиторий себе в уютное место. Синопсис прост:
        //           
        //               git clone [options] <dir-with-repo> <target-dir>
        //           
        //           Просто подставь в <dirWithRepo> путь к директории с проектом и нужным репозиторием (т.е. с папкой .git), а в <targetDir> -
        //           директорию, куда этот проект в итоге будет клонирован (клонируется даже .git)
        //         
        //         


        //   git fetch
        //           
        //       Загружает commit'ы, файлы и ссылки из удалённого репозитория в наш текущий, но
        //           /////////after reading: git pull/////////////////////////////////////////////////////////////
        //           // (в отличие от git pull)
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           не смешивает их. Эти загруженные объекты остаются изолированными от твоих локальных файлов, поэтому они совершенно не
        //           мешают твоей работе. Используй этот раздел, когда ты хочешь посмотреть над чем работают твои товарищи. Синопсис у раздела
        //           git fetch такой:
        //           
        //               git fetch [<options>] [<repo> [<what-to-fetch>]]
        //           
        //           Используй этот раздел, находясь в своём локальном репозитории, и объекты будут загружаться туда. В <repo> можешь вставить
        //           просто путь к директории с нужным репозиторием (т.е. с ./.git/)
        //           /////////after reading: git remote///////////////////////////////////////////////////////////
        //           // или имя этой нужной репы, имеющейся у тебя в списке с remote'ами
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       Если ты не задашь [<what-to-fetch>], то ты загрузишь всё содержимое репозитория (что находится в <repo>)
        //
        //       /////////after reading: git checkout/////////////////////////////////////////////////////////
        //       // Чтобы посмотреть за'fetch'енные данные, использую раздел git checkout
        //       /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       /////////after reading: git pull/////////////////////////////////////////////////////////////
        //       // Можешь считать раздел git fetch безопасным вариантом раздела git pull. С git fetch ты
        //       // легко можешь сначала оценить то, что получаешь
        //       /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       Что ты можешь запросить? Вот список:
        //               > <branch>
        //               >
        //               >****что ещё можно?
        //         
        //       Что делает простая команда    git fetch    ?
        //         
        //       Вот имеюищиеся [<options>]:
        //           --all              - получить всё содержимое репозитория по <dir-with-repo>
        //           
        //           

        
        //   git pull (pull - с англ. тянуть)
        //         
        //       Если кто-то clone'ировал и модифицировал твой проект, и ты хочешь официально внести эти модификации, тебе как раз
        //           следует воспользоваться этим разделом. В git pull ты найдёшь набор инструментов нужный для получения и интегрирования
        //           чужих репозиториев (или местных веток). Синопсис, конечно, несложен:
        //           
        //               git pull [options] [<repo>] [<branch>]
        //           
        //           Под <repo> и <branch> подставляй нужный репозиторий (/путь/к/нему/) и его ветку, откуда хочешь стянуть модификации
        //           /////////after reading: git remote///////////////////////////////////////////////////////////
        //           // (в <repo> также можно подставить имя одного из remote'ов)
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       Сама по себе команда    git pull    - это просто shortcut для этих 2'ух команд:
        //           
        //               git fetch
        //               git merge FETCH_HEAD
        //           
        //           Как видишь, git pull, получив объекты, сразу юзает команду    git merge    , сливая их с твоими локальными файлами
        //           
        //       Допустим, мы хотим за'pull'ить себе поправки какой-нибудь Alice. Мы сделаем это, перейдя в свой проект и применив git pull:
        //           
        //               git pull /home/alice/project/ master
        //           
        //           Эта команда фактически за'merge'ит её ветку master в нашу текущую ветку (сейчас у нас также master). В случае конфликтов
        //           файлов, тебе следует их разрешить
        //           
        //           

        
        //   git rebase
        //           
        //       Поддерживает topic ветки
        //           
        //           

        
        //   git tag
        //           
        //       Создаёт пометки. Синопсис таков:
        //           
        //               git tag [options] [<tag>]
        //           
        //           В разделе git log ты затем сможешь оринетироваться по этим меткам кода (также там есть специальные опции)
        //           
        //       Например, давай оставим пометку текущего времени в качестве тага (таг назавём dddate)
        //           
        //               git tag --message="3 sep 2021" dddate
        //           
        //       [options] имеются такие:
        //               --list, -l           выдать список имеющихся тагов
        //               --delete, -d         удалить заданные <tag>
        //               --
        //               --
        //           
        //           

        
        //   git format-patch
        //           
        //       Подгатавливает email представление нужной тебе ветки (да, упоминание об этой утилитке есть выше)
        //       . Синопсис таков:
        //           
        //               git format-patch [<options>] [<common diff options>] [<since> | <revision-range>]
        //           
        //       Хочешь подготовить к отправке ветку master? Просто введи это:
        //           
        //               git format-patch master
        //           
        //           ****что-то произойдёт, но вывода не будет
        //           
        //           

        
        //   git send-email
        //           
        //       Отправляет подгатовленное email представление (что ты сделал через git format-patch). Email отправляется без порчи по твоему
        //           MUA (****что такое MUA?). Синопсиса аж целых 2-а (но они простые):
        //           
        //               git send-email [<options>] <file|directory|revision-list options>…​      //****revision-list - что это?
        //               git send-email --dump-aliases
        //           
        //           . Как ты понял, этот раздел берёт заданные патчи и email'ит их.
        //           
        //       Если ты решишь отослать ревизии, то может быть задействован формат, принятый через git format-patch
        //           
        //       [<options>] имеются такие:
        //               --to=<address>, ...         - отправить email по этому адресу. <address> может быть "person artur@redhat.com"
        //           
        //           
        //           

        
        //   git-request-pull
        //           
        //       Создаёт сводку из изменений
        //           
        //           
        //           
        //           


        //   git ls-remote
        //           
        //       Выводит список ссылок (в смысле имён или тагов) в каком-нибудь отдалённом репозитории. Синопсис такой:
        //           
        //               git ls-remote [<options>] [<dir-with-repo>] [<refs>...]
        //           
        //       Выбор из [<options>] небольшой:
        //               --heads, -h, --tags, -t  - вывести только сылки и head ****что это?
        //               --
        //               --
        //               --
        //           


        //   git cat-file
        //           
        //       Выводит содержимое и всякую инфу объектов, хранящихся в репозитории. Синопсис таков:
        //           
        //           git cat-file [<options>] <object>
        //           
        //           
        //       [<options>] имеются такие: 
        //               -p               - выводит в удобном виде начинку <object>'а, основываясь на его типе
        //               -t               - вывести тип <object>'а (может быть "commit")
        //               --
        //           


        //   git rm
        //           
        //       Удаляет файлы из директории проекта и из index'а. Синопсис несложен:
        //           
        //           git rm [<options>] [<./../*.*>...]
        //           
        //           
        //       [<options>] этого раздела такие:
        //               --cached              - удалить файл <./../*.*> из index'а
        //               --
        //               --
        //               --
        //           


        //   git show
        //           
        //       Посмотреть изменения, внесённые последним commit'ом. Получается что-то вроде git log'а между двумя последними разделами.
        //           Синопсис очень прост:
        //           
        //               git show [<options>] [<object>...]
        //           
        //           Под <object>... подставляй хеш-значения нужных commit'ов
        //           
        //       Если ты просто введёшь
        //           
        //               git show
        //           
        //           , то выведется полный список изменений по каждому файлу
        //           
        //       Имеет такие [<options>]:
        //               --name-only                    - показать только имена изменённых файлов
        //               --
        //               --
        //           


        //   git reset
        //           
        //       Отменяет последний commit (не работает для первого commit'а). Синопсисы у раздела git reset такие:
        //           
        //               git reset [<options>] [--] <./../*.*>...
        //               git reset [<options>] [<tree-ish>]
        //               git reset [<options>] [--] [<./../*.*>...]
        //               git reset [<options>] [<commit>]
        //           
        //           
        //           


        //   git clean
        //           
        //       Удаляет файлы из директории проекта, что не включены в репозиторий (т.е. что не отслеживаются им). Синопсис очень прост:
        //           
        //               git clean [<options>] [--] <./../>...
        //           
        //           Хоть параметр <./../> и выглядит обязательным, его ты можешь не указывать (****почему в man-странице он не помещён в []?).
        //           В этом случае    git clean    будет рыскать лишь в текущей директории (./), не залазя во вложенные
        //           
        //       По умолчанию команды раздела git clean предохраняются от удаления этих самых неотслеживаемых файлов. Снять этот предохранитель
        //           ты можешь или используя некоторые параметры, или задава переменную clean.requireForce в true (****как задавать
        //           переменные?)
        //           
        //       Выбор из [<options>] здесь небольшой:
        //               -d                 - если <./../> не указан, то рыскать и удалять неотслеживаемые файлы во всех поддиректориях. При
        //                                    заданных <./../>... этот параметр эффекта не имеет
        //               --force, -f        - удалять файлы несмотря ни на что
        //               --
        //           


        //   git remote
        //           
        //       Управляет набором удалённых репозиториев, к которым ты имеешь доступ. Да, каждый репозиторий может имеет ссылки на
        //           какие-нибдудь другие (например, чтобы загрузить в один из них последние изменения твоего текущего). Этот раздел имеет свои
        //           подразделы, а у него самого почти нет собственных параметров (кроме параметра [-v | --verbose], что можно поставить перед
        //           парочкой разделов)
        //           
        //       Если ты просто введёшь
        //           
        //               git remote
        //           
        //           , то тебе выведится список имеющихся "remote"'ов (имеющихся ссылок)
        //           
        //       Remote'ы сами по себе - это скорее shortcut'ы для неудобных url. Хранятся они в ./.git/config файле
        //           
        //       Git, вообще, может воспринимает много всяческих ссылок. Из-за лёгкости наиболее распространены 2-а способа - через HTTP и
        //           через SSH протокол. HTTP-ссылка, как ты знаешь, выглядит так:
        //           
        //               http://host/path/to/.git
        //           
        //           . Ты можешь указать её и легко пользоваться репозиторием анонимно (read-only!). Только вот этим репозиторием также легко
        //           может пользоваться и любой другой анонимус. Для read-write доступа с аутентификацией тебе следует использовать SSH. Ccылки
        //           по этому протоколу выглядят так:
        //           
        //               ssh://user@host/path/to/.git
        //           
        //           Тебе, конечно, предварительно стоит иметь готовый SSH аккаунт для такого
        //           
        //       Вот все подразделы и инфо о них:
        //           
        //               git remote add [-t <branch>] [-m <master>] [-f] [--[no-]tags] [--mirror=(fetch|push)] <name> <url>
        //                                                    - добавить remote с именем <name>, указывающий на репозиторий по адресу <url>.
        //                                                      Вот описание всех [опций]:
        //                                                          -f      - после добавления сразу сделать    git fetch    из этого уже
        //                                                                    remote'а
        //                                                          --tags  - сразу сделать    git fetch    для получения тагов
        //               git remote rename <old> <new>
        //                                                    -  
        //               git remote remove <name>
        //               git remote set-head <name> (-a | --auto | -d | --delete | <branch>)
        //               git remote set-branches [--add] <name> <branch>...
        //               git remote get-url [--push] [--all] <name>
        //                                                    - вывести URL этого remote'а с таким именем. Опции у этого подраздела такие:
        //                                                          --push  - ****
        //                                                          --all   - вывести все URL, которым этот remote служит shortcut'ом
        //               git remote set-url [--push] <name> <newurl> [<oldurl>]
        //               git remote set-url --add [--push] <name> <newurl>
        //               git remote set-url --delete [--push] <name> <url>
        //               git remote [-v | --verbose] show [-n] <name>...
        //                                                    - вывести общую инфу о remote'е
        //               git remote prune [-n | --dry-run] <name>...
        //                                                    - удалить все локальные branch'и, которых нет в этом remote'е
        //               git remote [-v | --verbose] update [-p | --prune] [(<group> | <remote>)...]
        //               
        //               
        //               
        //               
        //               
        //               
        //               
        //           
        //           

        
        //   git push
        //           
        //       Загрузить начинку локального репозитория на удалённый репозиторий. Т.е. это как git fetch, но наоборот. Внести начинки ты
        //           можешь в те репозитории, что ты уже добавил через git remote. Вот синопсис:
        //           
        //               git push [<options>] [<remote>] [<what-to-push>]
        //           
        //           В <what-to-push> ты можешь подставить любой объект (будь то commit, целую branch, файлы, ..)
        //           
        //       Если ты решишь отправить branch, то в destination remote она будет числится так, как и все другие branch'и. Все необходимые
        //           commit'ы и связанные объекты также окажутся в этом branch'е
        //       Если такой branch в remote'е уже имелся, он обновиться до твоей версии
        //           
        //       Такой push'инг может перезаписать данные, так что будь аккуратен (это случится, когда в целевом репозитории уже есть этот
        //           branch, но другой версии). Но git push по умолчанию стоит на предохранителе (который можно снять одной опцией)
        //           
        //       Заметь, git push'инг - это в сущности то же, как если бы ты запустил git merge из этого удалённого репозитория
        //           
        //       Раздел git hub наиболее часто используют для сохранения изменений в каком-нибудь центральном репозитории (в github'е,
        //           например)
        //           
        //       ****Разделу git push, как и git fetch и git pull, можно указывать просто путь до директории с репозиторием
        //           
        //       Список [<options>] здесь не очень большой:
        //               --force, -f        - снять предохранитель
        //               --all              - за'push'ить всю начинку локального репозитория в <remote>
        //               --
        //           
        //           
        //           
        //           


        // Options
        //
        //   
        //     
        //     
        //     


        // You got info from these resources
        //     
        //     > Изначально из man-страниц git'а, но там слишком много инфы (а gittutorial объяснял очень поверхностно)
        //     > Позже я полез в интернет, и нашёл прекрасный сайт https://www.atlassian.com/git/tutorials/syncing, где поясняется немного
        //       (самое основное), но поясняется очень глубоко


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Git_Silent()");
    }
    static void ASPNETPreview_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   ASPNETPreview_Silent()\n");


        // WhatItIs
        //
        //   ASP.NET Core - он мощен, эффективен, oper source'ен и cross-platform'енен. Собственно, на нём и строятся всё web'евское, вроде
        //     всеми любимых интернет сервисов
        //   На этой штуке, кстати, крутиться половина вакансий C#'овцев
        //   На момент 21 aug 2021, актуальна версия ASP.NET Core 5
        //
        //   Вообще, ASP - это Active Server Pages
        //
        //   В ASP.NET'е строится как UI, так и API (т.е. весь твой сайтик целиком может быть в одном проекте)
        //   ASP.NET конструировался так, чтоб его легко могли тестировать
        //
        //   ASP.NET Core - быстрейший веб-фреймворк на планете
        //     (пруф - https://www.techempower.com/benchmarks/#section=data-r19&hw=ph&test=plaintext&a=2?azure-portal=true)! Точнее, был
        //     какое-то время
        

        // ASP.NET History
        //
        //   В старые до'.NET'ные времена (времена Windows NT) эта штука (тогда ещё звавшаяся ASP) была аддоном (и ставилась отдельно) к
        //     Internet Information Server. Когда .NET релизнули, из этого add-on'а и сделали ASP.NET
        //   Как и многие другие составные части .NET'а, ASP.NET (на протяжении лет) как минимум несколько раз сильно менял свою форму
        //  
        //   Изначально был ASP.NET Web Forms, где разработчики писали код и скрипты, чтоб затем этот движок перевёл код в HTML
        //   Затем, в 2009-ом был релизнут ASP.NET MVC, и это сильно всех потрясло. MVC (Model-View-Controller, о нём ниже)
        //     появился именно в то время. На таком ASP.NET'е мы сейчас и живём
        //
        //   В самом начала назревания cross-platform революции (2016 год) Micro$oft'цы, в паре с .NET Core 1.0, выпустили ASP.NET Core 1.0
        //     (а иначе кто бы вообще перезаживался на .NET Core?). Конечно, как ты помнишь, эти индусы взяли фактически уже готовый продукт
        //     , что разработали чуваки для проекта Mono
        //
        //   До cross-platform революции ASP.NET звался ASP.NET 4.x (да и вообще тогда весь .NET Framework был версии 4.x), после он
        //     переименовался в ASP.NET Core. Новая редизайненная версия оказалась чуть стройнее и модульнее. Алсо, Microsoft, ставши
        //     community-ориентированной Корпорацией Зла, запустила .NET Live TV (нет, правда, https://dotnet.microsoft.com/live)(хотя
        //     напоминает это всё детский сад. маскот-робот присутствует)


        // MVC
        //
        //   Допустим, мы пишем сайт, где клиенты могут покупать какие-то вещи. Эти самые товары - это Models (модели). На сайт заходит клиент,
        //     он смотрит товары, получает инфо о них, складывает в корзину. Эти действия - Controllers, т.е. эти действия для управления
        //     моделями (попросить модель выдать инфу, заставить модель перейти в корзину, попросить модель о скидке). Пользователь, конечно,
        //     видит все изменения товаров у себя на экране (инфу о модели, скидку, ...) - эта часть зовётся View
        //
        //   Ну т.е. понимаешь, да?
        //
        //       > Model - представляет данные, реагируют на команды контроллера, изменяя своё состояние
        //       > View - отвечает за отображение модели пользователю, реагируя на изменение модели
        //       > Controller - интерпретирует действия пользователя, оповещяя модель о необходимости измений
        //
        //   MVC, как ты понял - шаблон (pattern). Он описывает только общее положение дел. А это значит, что нет никакой разницы в том, на
        //     каком языке этот шаблон реализован
        //
        //   Вся фишка MVC в том, что он разделяет всё приложение на 3-и большие части, полностью независимые друг от друга. Это даёт
        //     сильнейший плюс к тестируемости


        // Alternatives
        //
        //   Silverlight
        //  
        //       На самом деле, кроме ASP.NET'а существовало ещё несколько задумок для web-базы. Например, Silverlight, который шёл как плагин
        //           к браузерам. Идея состояла в том, что, раз уж браузеры так сильно ограничивают код в себе (привет, интернет-игрушки!),
        //           почему бы не построить мост за пределы браузера?
        //       Пользоваться этим, правда, никто не стал. На сегодняшний день Silverlight считается заброшенным
        //  
        //   Windows 8's app model
        //  
        //       По этой модели разработчикам следовало писать GUI приложения, использующие HTML для разметки графики. Да, это вообще не
        //           касается настоящего web'а ****но Прайс почему-то решил написать об этом. Эта модель также оказалась почти никем не
        //           тронута, ведь запуск Windows 8 был полным провалом (и люди туда не шли)


        // Where you can put it
        //
        //   > Kestrel
        //   > IIS
        //   > HTTP.sys
        //   > Nginx
        //   > Apache
        //   > Docker
        //


        // How web works
        //
        //   Если в кратце, то твой шлюз в интерент - браузер. Он может связывать с серверами по провадам или как-то ещё. Ты открываешь его,
        //     открываешь какой-то сайт. Он, получив из имени этого сайта IP код (те самые 122.00.4), пытается достучатся до этого сервера.
        //     Сервер откликается, шлёт свою картинку (и какую-то логику) в ответ (предварительно разложив это всё в пакеты). Ты, видя
        //     кнопки/ссылки/что-тоЕщё, конечно, можешь нажать на них, и запустить какую-то связанную логику. Логика может попросить бразуер
        //     снова связаться с сервером, чтоб получить новый пакет с нужной сейчас инфой. Примерно так
        //
        //   На самом деле браузер - это не единственный шлюз в интернет. Он просто был сделан одним из первых, т.к. все изначально решили, что
        //     сайтики - прекрасная вещь
        //


        // HTTP, www  //after How web works
        //
        //   HTTP - Hyper Text Transfer Protocol. Это как раз тот протокол (т.е. набор соглашений), по которому перемещаются пакеты между
        //     клиентами и серверами. Именно HTTP определил для всех, какой вид должны иметь пакеты с данными, как они должны отправляться, как
        //     они должны идти и как они должны приниматься
        //   ASP.NET, конечно, работает с HTTP искаропки. Это очень хорошо, ведь получается, что данные проходят весь путь от конца к концу
        //     в виде неприступных HTTP пакетов
        //     /////////after reading: HTTPS////////////////////////////////////////////////////////////////
        //     // (на самом деле обычные http пакеты очень даже приступны. если хочешь обезопаситься, юзай
        //     // https пакеты)
        //     /////////////////////////////////////////////////////////////////////////////////////////////
        //
        //   www - World Wide Web. Эта штука связывает клиенты (компьютеры пользователей) с серверами
        //   


        // HTTPS!
        //   
        //   HTTPS - то же, что HTTP, но Secure. Имея солидный опыт сёрфинга инета, ты давно понял, что следует заходить только на
        //     https://-сайты
        //   Если говорить поподробнее, то HTTPS защитит твои пакеты от атак перехватичков между сервером и клиентом. Точнее, перехватить они
        //     такие пакеты всё ещё смогут, но вот получить инфу - нет
        //   
        //   Помнишь флаг --no-https, что ставиться при создании webapi приложений через утилиту dotnet (полная команда выглядит так:
        //         dotnet new webapi --no-https    )? Как ты понял ещё тогда, по умолчанию dotnet создаёт проекты с HTTPS сертификатом
        //


        // REST  //after HTTP
        //
        //   REST - Representational State Transfer (надмозг. переноситель репрезентативного состояния). Если вкратце, то это такой стиль
        //     построения web-сервиса (иначе говоря, web-службы, или web API). REST запросы (****что это?) строятся на HTTP, т.е. они
        //     описываются на том же синтаксисе, на котором браузеры принимают и отправляют пакеты из интернета
        //     
        //   Вот некоторые слова из синтаксиса HTTP:
        //       > GET     - инструкция для получения данных из web-сервиса 
        //       > POST    - создать новый пакет в web-сервисе
        //       > PUT     - обновить пакет в web-сервисе
        //       > PATCH   - обновить пакет в web-сервисе, отправив набор инструкция для него
        //       > DELETE  - удалить пакет в web-сервисе
        //     
        //   Web-сервисы, что построены в соостветствии с REST, зовутся RESTful APIs
        //  
        //   Всякая RESTful web-сервисная API строится из:
        //  
        //       > Базового URL
        //       > HTTP инструкций
        //       > Каких-нибудь файлов с данными (вроде JSON'ов или XML)
        //
        //****ничего не понятно, ты должен знать больше!
        

        // .NET HTTP REPL
        //    
        //    Традиционно вебсайты тестировались их создателями прямо в браузере. Но индусы из Microsoft решили сделать более удобную штуку -
        //      .NET HTTP REPL (Read-Eval-Print-Loop). Это такая cmd утилитка для тестирования каждой фишки твоего будущего сайта
        //      (****но это не точно)


        // Create your own webapp
        //     
        //   Простенький сайт делается этой командой:
        //     
        //         dotnet new webapp
        //     
        //     Я создал директорию ./SimpleWebApp_ASP.NET/, и произвёл эту инструкцию там
        //
        //   Если ты раньше не создавал никаких ASP.NET проектов, то dotnet cli установит в себя новый .NET runtime -
        //     Microsoft.AspNetCore.App (все runtime'ы ты можешь посмотреть, введя dotnet --info). Также dotnet cli обзаведётся новыми
        //     подкатегориями параметров. Вот они (****возможно, они не относятся к ASP.NET'у):
        //         > dev-certs                             - ****
        //         > fsi                                   - ****
        //         > sql-cache                             - ****
        //         > user-secrets                          - ****
        //         > watch <program>                       - запускать file watcher, что запустит программу, как только файлы изменятся. Можно
        //                                                   использовать в паре с run (вводя    dotnet watch run ...    ), и dotnet cli
        //                                                   будет запускать проект по новой при изменениях в нём (****я так понял)
        //                                                   
        //                                                   
        //
        //   ****нужно как-то сделать https сертификат для dotnet cli
        //     
        //   Запустить этот проект лучше, задействовав подраздел watch:
        //
        //         dotnet watch run
        //     
        //     Сделав это, ты увидешь, что (..) ничего не происходит (кроме выплёскивание логов в терминал). Но на самом деле твой сайт
        //     запустился на Kestrel web сервере (****но это не точно****а что это?), ты просто не открыл его. https://localhost:5001 - вот где
        //     хостится твой первый вебсайт
        //     
        //   В этом проекте есть директория ./SimpleWebApp_ASP.NET/Pages/, файлы в ней описывают то, как страницы этого сайта должны выглядеть.
        //     По умолчанию рисуется вполне симпатичная страница, хоть она и содержит в себе всего несколько элементов. Ты можешь открыв
        //     https://localhost:5001 и посмотреть на неё сам
        //     
        //     Razor page
        //     
        //          Файл ./../Pages/Index.cshtml задаёт вид главной страницы. В этом файле имеются мои комментарии
        //          
        //          
        //          


        // Create your own webapi
        //     
        //   Простетский проект web-сервиса создаётся так:
        //     
        //         dotnet new webapi --no-https
        //     
        //     Ты уже знаком с этой командой. Выполнив её, ты получишь некоторые незнакомые тебе файлы и директории. Если конкретно, эти
        //     (я создал директорию ./ContosoPizza_ASP.NET/, и выполнил команду в ней):
        //     
        //       > ./Controllers/                - здесь храниться класс WeatherForecastController, определяющий в себе HTTP инструкцию GET
        //                                         (в виде C#-повского метода Get() с атрибутом [HttpGet])
        //       > Program.cs                    - собственно, стартовая точка программы. Метод Main() создаёт хост
        //       > Startup.cs                    - а этот метод конфигурирует твой хост при старте****но это не точно
        //       > appsettings.Development.json  - ****
        //       > appsettings.json              - ****
        //       > WeatherForecast.cs            - здесь хранится сам класс ContosoPizza_ASP.NET.WeatherForecast, его объекты будут хранить
        //                                         данные о прогнозах погоды
        //     
        //   Компилирование и запуска проекта производится этим:
        //         
        //         dotnet run
        //
        //     ****ты перенёс отсюда большой кусок текста в блок о webapp
        //     (но это не ссылка на страницу сайта. если ты откроешь её, твой браузер не найдёт ничего)(если бы мы не прописали
        //     флаг --no-https, сайт бы хостился на https://localhost:5001). Перейди по ссылке http://localhost:5000/weatherforecast, чтобы
        //     действительно посмотреть на результат. Ты увидишь начинку json-файла (хоть и в неудобном оформлении)! Именно в
        //     этот json файл и были упакованы объекты типа ContosoPizza_ASP.NET.WeatherForecast
        //     
        //****что такое webapi?


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   ASPNETPreview_Silent()");
    }
}