/*
 * creation date  21 aug 2021
 * last change    17 nov 2021
 * author         artur
 */
using System;

class _Git_ASPNETPreview
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        Git_Silent();
        ASPNETPreview_Silent();

        Console.ReadLine();
    }
    static void Git_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Git_Silent()\n");


        // What It Is
        //
        //   Ты, наверное, часто слышал об этой штуке. Работодатели уверяют, что знание git'а - это большой плюс для них
        //     
        //   git - "тот самый простетский хранитель начинки" (так написано в оффициальной man-странице). В общем и целом,
        //     он может просто делать снимки какой-нибудь директории и сохранять их у себя дома, т.е. в директории ./.git/. Если ты захочешь
        //     откатить свою работу, ты можешь восстановить всю директорию из какого-нибудь прошлого снимка
        //     
        //   Git быстр и масштабируем (в смысле, что его работа не зависит от размеров твоего проекта), и с помощью него ты можешь держать
        //      много версий своего решения
        //     
        //     
        //   Первую версию git писал сам Линус Торвальдс. Вот что он сам говорит о git'е:
        //     
        //         We will hereby start scouring the net for people 
        //         who say git is hard to understand and use, 
        //         and just kill them. 
        //         They clearly are just polluting the gene pool. 
        //         
        //          --Linus Torvalds
        //     
        //   Source code managment (SCM) - одна из часто используемых аббревиатур
        //
        //   /////////after reading: git remote///////////////////////////////////////////////////////////
        //   // В отличие от VCS'а (Version System Controll, была такая до'git'овская утилита), Git не
        //   //   различает локальные и удалённые репозитории
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //     
        //
        //     
        // У git'а есть набор подразделов (комманд)(как и у dotnet cli)
        //


        //   git help
        //       
        //       Первый, и самый нужный, - это раздел git help. Синопсис таков:
        //       
        //               git help [options] [<command|guide>]
        //       
        //           На место <command|guide> ты подставляешь нужный тебе раздел (****или какой-то гайд), и тебе откроется man-страница с
        //           нужной инфой
        //       
        //       На самом деле ты можешь открыть те же man-страницы, используя саму утилиту man. Это выглядит примерно так:
        //       
        //               man git-<command|guide>
        //       
        //           Например,    man git-log    выведет тебе ровно ту же инфу, что и    git help log    
        //       
        //       ****у git help есть ещё много опций
        //       
        //       


        //   git config
        //       
        //       Если ты прочёл документацию git'а (хотя-бы man-страницу gittutorial), то знаешь, что первым делом лучше сконфигурировать его.
        //           Как минимум нужно создать свой git-профиль. Вот самый простой способ сделать это:
        //        
        //               git config --global user.name "YourName"
        //               git config --global user.email "your@email.com"
        //           
        //       Git хранит config-опции в 3-ёх разных файлах:
        //               > ./.git/config   - config-файл текущего репозитория
        //               > ~/.gitconfig    - config-файл текущего пользователя
        //               > /etc/gitconfig  - system-wide config-файл
        //           Если опции конфликтуют (если одна опция определена в нескольких config-файлах), то в приоритете окажется более локальный
        //           config-файл (./.git/config <- ~/.gitconfig <- /etc/gitconfig)
        //           
        //       На самом деле ты можешь задать абсолютно любую опцию (например, cat.tosya). Git не имеет чёткой чёткого списка заранее
        //           определённых переменных. Он лишь следит, не объявили ли какую-нибудь user.name в этот раз
        //           
        //       Все опции выглядят так:
        //           --global [<key> <value>]            - записывает опции в общий для юзера ~/.gitconfig
        //                                                 . Если файла ~/.gitconfig нету, записывает опции в $XDG_CONFIG_HOME/git/config
        //           --local [<key> <value>]             - записывает опции в локальный репозиториевский ./.git/config
        //                                                 . На самом деле --local можно даже не использовать
        //           --system [<key> <value>]            - записывает опции в общесистемный /etc/gitconfig
        //           [--global|--local|--system] --edit  - открывает редактор для редактирования ./.git/config, ~/.gitconfig или
        //                                                 /etc/gitconfig файла
        //           --
        //           --
        //           --
        //           --****
        //         
        //       git построен так, чтобы читать некоторые $переменные окружения. Вот они:
        //               GIT_AUTHOR_NAME
        //               GIT_AUTHOR_EMAIL
        //               GIT_AUTHOR_DATE
        //               GIT_COMMITTER_NAME
        //               GIT_COMMITTER_EMAIL
        //               GIT_COMMITER_DATE
        //               XDG_CONFIG_HOME
        //               GIT_EDITOR
        //           Эти переменные (если они определены) находятся в приоритете у всех команд git'а
        //         
        //       /////////after reading: Git commit///////////////////////////////////////////////////////////
        //       // С помощью git config можно создавать alias'ы (shortcut'ы) для git команд. Например,
        //       //     
        //       //         git config --local alias.pushDev push collaborate-snake dev
        //       //     
        //       //     сократит создат shortcut pushDev для команды    git push collaborate-snake dev    
        //       //     ****нужно ли писать git alias.pushDev, или можно просто git pushDev?
        //       //     ****надо ли обернуть параметры    push collaborate-snake dev    в ""'ки?
        //       /////////////////////////////////////////////////////////////////////////////////////////////
        //       
        //       
        //       
        //       


        //   git init
        //          
        //       Этот подраздел создан для инициализации репозитория (или переинициализации уже имеющегося). Синопсис прост:
        //          
        //              git init [options] [<path-to-dir>]
        //          
        //           Если ты просто введёшь git init, то прямо в текущей папке создастся директория ./.git/, гордо именуемая "репозиторием"
        //           (если задана переменная $GIT_DIR, то ./.git/ создана не будет, а весь репозиторий создастся по адресу в ней).
        //           Эта директория сразу будет имет каркас в виде:
        //               ./.git/branches/    -
        //               ./.git/config       - уже знаком (из блока git config)
        //               ./.git/description  -
        //               ./.git/HEAD         - ссылка на твой последний бэкап
        //                                     /////////after reading:git add///////////////////////////////////////////////////////////////
        //                                     // Об этом написано в части про git branch
        //                                     /////////////////////////////////////////////////////////////////////////////////////////////
        //               ./.git/hooks/       -
        //               ./.git/info/        -
        //               ./.git/objects/     - как-бы место, куда складируются все твои забэкапенные файлы
        //                                     /////////after reading:git add///////////////////////////////////////////////////////////////
        //                                     // Больше инфо написано в блоке git add
        //                                     /////////////////////////////////////////////////////////////////////////////////////////////
        //                                     /////////after reading:git commit////////////////////////////////////////////////////////////
        //                                     // Если задана переменная $GIT_OBJECT_DIRECTORY, то директории индекса (00, 01, ...) будут
        //                                     //   размещатся по адресу в ней. А так, используется директория $GIT_DIR/objects (если
        //                                     //   переменная $GIT_DIR задана)
        //                                     /////////////////////////////////////////////////////////////////////////////////////////////
        //               ./.git/refs/        - /////////after reading:git commit////////////////////////////////////////////////////////////
        //                                     // Об этом написано в части про git branch
        //                                     /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       Прописывать git init в директории с уже существующем репозиторием безопасно, ничего перезаписано не будет. Эта
        //           переинициализация полезна тем, что с ней репозиторий подбирает недавно добавленные шаблоны (****что это?)
        //          
        //       Из [options] здесь выбор такой:
        //               --bare               - создать голый репозиторий (т.е. новоиспечённый репозиторий развернётся не в директории ./.git/,
        //                                      а прямо в текущей папке. если задана $GIT_DIR, то генерироваться репа будет там)
        //               --  -
        //               --  -
        //               --  -
        //               --  -
        //          
        //           


        //   git add
        //           
        //       Наконец, если ты хочешь сделать снимок своей директории, используй этот подраздел. Синопсис таков:
        //           
        //               git add [<options>] <./../*.*> ..
        //           
        //           Как видишь, ты можешь задать регулярное выражение для тех файлов, что ты хочешь добавить в снимок. Снимок будет сохранён
        //           в temporary staging area, что прозвали "index"эом. Ты можешь постоянно добавлять в этот снимок всё больше новых файлов,
        //           вводя    git add <..>    
        //           /////////after reading: git rm///////////////////////////////////////////////////////////////
        //           // (а также можешь удолять, вводя    git rm <..>    )
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           /////////after reading: git commit///////////////////////////////////////////////////////////
        //           // . Сохранить снимок действтительно надолго ты можешь, задействовав подраздел git commit
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           Несмотря на название, temporary staging area не забывает твои снимки. Можно считать, что это просто буффером, снимок
        //           которого ты можешь постоянно изменять
        //           
        //       Git tracks content not files. Многих сбивает с толку эта фраза (а именно тех, кто не понял сходу что значит отслеживать
        //           контент). Многие другие подобные программы также имеют у себя подобие раздела add. В них этот раздел говорит системе
        //           начать записывать найденные изменения в отдельный файл. Git пошёл другим путём: команда    git add    при встречи с новыми
        //           или недавно изменёнными файлами делает их снимки, и затем эти снимки целиком помещает в temporary staging area
        //           ****насколько я понял
        //           
        //       Как же выглядит index (он же temporary staging area)? Добавленные через git add файлы хранятся в папке
        //           ./.git/objects/xx/yyyyyyyy/ (xx - хеш-значение директории файла, yyyyyyyy - хеш имени файла. хешы xx идут по порядку, т.е.
        //           00, 01, .. 09, 0a, 0b .. 0e, 0f, 10, 11, ..). Например, какой-нибудь файл может хранится так:
        //           
        //               ./.git/objects/9f/2422325cef705b7682418d05a538d891bad5c8
        //           
        //           Получается, что полный хеш этого файла - 9f2422325cef705b7682418d05a538d891bad5c8 (ты и сам можешь посмотреть свою
        //           staging area, используя ls). Сам файл ./.git/../2422325cef705b7682418d05a538d891bad5c8 - это архив
        //           /////////after reading git cat-file//////////////////////////////////////////////////////////
        //           // (его легко распаковать и вывести на экран через раздел git cat-file)(git cat-file говорит
        //           // , что объекты, т.е. архивы таких файлов имеют тип "blob", что с англ. "капля", "клякса")
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       Не хочешь, чтобы в index попадали какие-то файлы (например временные файлы *.o)? Это легко сделать, создав файл ./.gitignore !
        //           Просто занеси в него строчки с фильтрами для отсеивания неугодных файлов (например, добавь строчку с *.o)
        //           
        //       Вот [<options>] этого раздела:
        //               --all              - добавить всю директорию
        //               --
        //               --
        //           


        //   git commit (commit - с англ. совершить)
        //           
        //       Этот подраздел сделан для сохранения временных снимков в репозиторий в виде commit'ов. Сделай это, как только ты решишь, что
        //           твой временный снимок готов к увековечиванию. Каждый commit кроме своей начинки имеет ещё hash (что служит ему id) и
        //           message (сообщение, что ещё зовут комментарием). Из таких commit'ов собирается ветка - история изменений разработки. У
        //           каждой ветки есть своё название. Репозиторий может содержать в себе несколько веток:
        //           
        //                             ┌─────┐
        //                             │ C0  |
        //                             └──┬──┘
        //                                │
        //                                │
        //                                │
        //                                V
        //                             ┌──┴──┐
        //                             │ C1  ├───┐
        //                             └──┬──┘   │
        //                                │      V
        //                                │    ┌─┴───┐
        //                                │    │ C3  │ <──(But Fix)
        //                                V    └──┬──┘
        //                             ┌──┴──┐    │
        //                             │ C2  │    │
        //                             └──┬──┘    │
        //                                │       │      
        //                                │       │      
        //                                │       │      
        //                                │       │      
        //                             ┌──┴──┐    │
        //                             │ C4  ├─<──┘
        //                             └─────┘
        //           
        //       Новый сommit обычно делают после какого-то большого изменения (вроде добавления нового функционала, исправления бага. иногда
        //           просто в качестве завершения рабочего дня)
        //           
        //       Синопсис, кстати, таков:
        //           
        //               ****здесь должен быть синопсис. строка ниже - продолжение
        //           
        //           Выполнить    git commit    не удастся, если ты ещё не представился git'у (ему нужна инфа $GIT_AUTHOR_NAME,
        //           $GIT_AUTHOR_EMAIL, $GIT_CIMMITTER_NAME и $GIT_COMMITTER_EMAIL. эту инфу также можно задать через подраздел git config)
        //           
        //       Выполнив команду    git commit    , тебе откроется prompt с текущим снимком (prompt здесь - это как-бы файл, что откроется в
        //           редакторе. будет использован редакторе, что назначен в $GIT_EDITOR. если такая переменная окружения не назначена,
        //           откроется в редакторе , что назначен в $EDITOR). В этом prompt'е тебе ты
        //           можешь оставить сообщение, описывающее изменения в этом commit'е по сравнению с предыдущими (хорошой привычкой считается
        //           первыми строчками оставить общую сводку об изменениях, не больше 50 символов)
        //       В этом promp'е уже будет достаточно подробно расписаны детальные логи о том, что будет добавлено или
        //           изменено, но все эти строчки закоментированны. Закоментированные строчки будут пропущенны, так что ты сам решаешь, что
        //           добавить в сообщение. Составив сообщение, тебе следует сохранить этот файл, этим ты совершишь commit
        //       Есть такой раздел, git format-patch. Его суть в том, что она упаковывает commit'ы в email (о ней есть инфо ниже). Первые
        //           строчки она использует в качестве загаловка к email-сообщению, а весь последующий текст помещает в тело
        //           
        //       Стартовая ветка по умолчанию зовётся "master"
        //           
        //       Ты можешь удивится, но commit'ы сохраняются также в индексе. Т.е. commit на деле может выглядить так:
        //           
        //               ./.git/objects/9f/2422325cef705b7682418d05a538d891bad5c8
        //           
        //           /////////after reading: git cat-file/////////////////////////////////////////////////////////
        //           // Такой объект (т.е. файл commit'а) имееют тип "commit".
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           К каждому commit'у создаёт ещё один объект - типа "tree" (например,
        //           
        //               ./../da/c6721c3b75fcb3c9d87b18ba4cef2e15e0a3d3
        //           
        //           ). Каждый commit'ы в себе содержит имя своего tree, а каждый объект tree в свою очередь ссылается на уже обычные объекты
        //           файлов. Всё вместе выглядит так:
        //                             
        //                      ┌────────────────────────────────────────────────────────────────────────────────────────────┐
        //                      │ ./.git/objects/ (index)                                                                    │
        //                      │                                                                                            │
        //                      │       ┌──────────────────────┐     ┌──────────┐               ┌──────────────────────┐     │
        //                      │       │        COMMIT        │     │   TREE   └───────────┐ ┌>│ Id: fd3c069          │     │
        //                      │       ├──────────────────────┤  ┌─>│ Id: f58da9a          │ │ ├──────────────────────┤     │
        //                      │       │ Id      e695606      │  │  ├──────────────────────┤ │ │ Contents...          │     │
        //                      │       │ Tree    f58da9a      ├──┘  │ []                   │ │ │                      │     │
        //                      │     ┌─┤ Parent  a0c641e      │     │ ├──░ welcome.txt     │ │ │                      │     │
        //                      │     │ │ Author  Cave Johnson │     │ │  │                 │ │ └──────────────────────┘     │
        //                      │     │ └──────────────────────┘     └────┼─────────────────┘ │                              │
        //                      │     │                                   └───────────────────┘                              │
        //                      │     │                                                                                      │
        //                      │     │ ┌──────────────────────┐     ┌──────────┐               ┌──────────────────────┐     │
        //                      │     │ │        COMMIT        │     │   TREE   └───────────┐ ┌>│ Id: *******          │     │
        //                      │     │ ├──────────────────────┤  ┌─>│ Id: *******          │ │ ├──────────────────────┤     │
        //                      │     └>│ Id      a0c64le      │  │  ├──────────────────────┤ │ │ Contents...          │     │
        //                      │       │ Tree    l90d840      ├──┘  │ []                   │ │ │                      │     │
        //                      │       │ Parent  9e8a761      │     │ ├──░ ***********     │ │ │                      │     │
        //                      │       │ Author  Cave Johnson │     │ │  │                 │ │ └──────────────────────┘     │
        //                      │       └──────────────────────┘     └────┼─────────────────┘ │                              │
        //                      │                                         └───────────────────┘                              │
        //                      │                                                                                            │
        //                      │                                                                                            │
        //                      └────────────────────────────────────────────────────────────────────────────────────────────┘
        //           
        //           
        //           
        //       Некоторые [options] здесь действительно полезны:
        //               --all, -a                    - с этим флагом команда    git commit    сама заметит изменения файлов в проекте и
        //                                              за'commit'ит получившийся снимок (но новые файлы в снимок добавленны не будут)
        //                                              (этакий обход использования раздела git add)
        //               --message=<msg>, -m=..       - задать сообщение <msg>. С этим параметром ты пропускаешь часть с prompt'ом
        //               --signoff, --no-signoff, -s  - добавить (или не добавить) в конец сообщения роспись. Значение этой росписи заранее
        //                                              декларируется командой разработки. Например, она может значить, что committer имеет
        //                                              права на размещение своих работ в этом проекте под определённой лицензией
        //                                              (****я так понял)
        //               --amend                      - заменить последний commit новым, вовлекая те же файлы, но оставив message (amend - с
        //                                              англ. исправить, чинить, улучшить)
        //               --no-edit                    - не входить в prompt для правки message'а. Часто используется вместе с --amend)
        //               --
        //           
        //           


        //   git status
        //           
        //       Если ты всего лишь хочешь получить краткую сводку об изменениях со времён последнего commit'а, воспользуйся подразделом
        //           git status. Простой ввод
        //           
        //               git status    
        //           
        //           выдаст тебе список модифицированных файлов
        //           
        //           


        //   git diff 
        //           
        //       git diff - посмотреть отличия текущей директории от текущего снимка в index'е. Ты, возможно, хочешь сделать это перед тем, как
        //           сделать очередной commit из этого снимка. Синопсис таков:
        //           
        //               git diff [options] ****не полный синопсис
        //           
        //           Простой ввод git diff отправит тебя в read-only prompt, где будут описаны отличия текущего состояния директории от
        //           staged снимка в index'е
        //           (всё это в текстовом виде. будут показаны отличающиеся файлы и отличающиеся строчки в каждом файле)(prompt будет открыт в
        //           утилите less)
        //           
        //       У раздела git diff имеются такие [otpions]:
        //               --cached           - выдать отличия между текущим индексом и последним commit'ом
        //               HEAD               - выдать отличия между всем рабочим древом и последним commit'ом
        //           
        //           


        //   git log - посмотреть историю commit'ов
        //           
        //       Историю commit'ов ты можешь посмотреть, используя этот раздел. Синопсис прост:
        //           
        //               git log [options] [tag..tag] [<path>...]
        //           
        //       По умолчанию будут выводится лишь messag'ы commit'ов
        //           
        //       /////////after reading: git tag///////////////////////////////////////////////////////////////
        //       // Помнишь про таги? По ним ты можешь ориентироваться в истории commit'ов. Например, ты
        //       //     можешь ввести это:
        //       //   
        //       //         git log v2.23..
        //       //   
        //       //     , и тебе выведут те коммиты, что были созданы после такого тага
        //       //   
        //       //   
        //       /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       Если история логов полностью поместится в один экран твоего терминала, выхлоп будет стандартный. Если история длиннее, то
        //           будет задействован prompt
        //           
        //       Каталог [options] очень обширен:
        //           
        //               --patch, -u, -p                  - вывести полный список изменений между каждым commit'ом (как если бы ты прописывал
        //                                                  git diff между ними)
        //               --since=<date>, --after=<date>   - показать логи, созданные после заданной даты (<date> может быть "3 days ago",
        //                                                  "2005-12-10")(после означает после начала дня. т.е. если ты напишешь
        //                                                      ..-after="2021-09-03..    , то тебе выйдут и commit'ы за этот день)
        //               --until=<date>, --before=<date>  - показать логи, созданные до заданной даты (формы <date> те же, что и у --since)
        //                                                  (эти параметры часто комбинируются с --since, --after)
        //               --oneline                        - уменьшить количество печатаемой информации. С этим ключом каждый commit будет
        //                                                  показан в одну строчку (в виде его хеш-значения и message'а), примерно так:
        //                                                      
        //                                                      2b82e80 You added graphical functions
        //                                                      657ab4c Initial commit
        //           
        //                                                  ****почему у этих commit'ов здесь короткое хеш-значение?
        //               --
        //           


        //   git branch and git switch and git merge
        //           
        //       Как уже говорилось, git репозиторий может хранить в себе несколько веток разработки. Работать с ветками можно средствами
        //           раздела git branch. Синопсис раздела прост:
        //           
        //               git branch [options] [<branch-name>]
        //           
        //       Как видишь, чтобы создать новую ветку, достаточно ввести имя для неё. Допустим, мы хотим создать ответвление "experimental"
        //           
        //               git branch experimental
        //           
        //       Если ты введёшь просто    git branch    , то получишь список существующих веток. Выглядит это так:
        //           
        //                 experimental
        //               * master
        //           
        //           Как ты понял, звёздочкой помечена текущая ветка
        //           
        //       Сменить текущую ветку можно, используя раздел git switch. Синопсис у этого раздела простетский:
        //           
        //               git switch [options] <branch>
        //           
        //       Мы переходим в ветку experimental, введя    git switch experimental    . Эта команда своим выхлопом покажет, какие файлы были
        //           изменены, но таки неза'commit'чены в предыдущей ветке. У меня выхлоп выглядил так:
        //           
        //               M	44-_Git_ASPNETPreview.cs
        //               M	6-ClassAndInterface_StructAndOOPAndSystemNullable.cs
        //               M	changelog.txt
        //               Switched to branch 'experimental'
        //           
        //       Теперь можно сделать несколько изменений и не беспокоится о их последствиях, ведь мы сейчас в ветке "experimental" (а она
        //           живёт отдельно от основной ветки "master". За'commit'им эти изменения, запустив команду    git commit -a    . Вернёмся
        //           снова на ветку "master", запустив это:
        //           
        //               git switch master
        //           
        //           Если у тебя были неза'commit'ченные изменения в файлах, git switch вежливо тебе скажет об этом, и прервёт выполнение. Вот
        //           что получил я:
        //           
        //               error: Your local changes to the following files would be overwritten by checkout:
        //               44-_Git_ASPNETPreview.cs
        //               Please commit your changes or stash them before you switch branches.
        //               Aborting
        //           
        //           После за'commit'чивания этих изменений и таки выполнения команды    git switch master    ты моментально заметишь, что
        //           файлы стали перезаписаны. Они так вернулись в то состояние, в котором ты их заснял последним commit'ом в ветке "master"
        //           
        //       На данный момент мы имеет две ветки, и начинка в них различается. Чтобы влить в текущую ветку master наработки ветки
        //           experimental, нам следует воспользоваться разделом    git merge    . Синопсис прост:
        //           
        //               git merge [options] <branch>
        //           
        //       Соединим наши ветки, введя    git merge experimental    . Т.к. конфилктов в начинке у нас не было, слияние произошло. Выхлоп
        //           был такой:
        //           
        //               Updating 317c4ba..b1dcaa5
        //               Fast-forward
        //                44-_Git_ASPNETPreview.cs                           | 182 +++++++++++++++++---
        //                ...ssAndInterface_StructAndOOPAndSystemNullable.cs |   6 +-
        //                changelog.txt                                      |  37 +++-
        //                3 files changed, 195 insertions(+), 30 deletions(-)
        //           
        //           Если конфликты бы таки были, операция бы не произошла. В этом случае тебе вручную следовало пройтись по проблемным файлам
        //           (которые git merge оставляет в выхлопе) с помощью git diff (****githowto говорит, что при открытии файла в нём сразу
        //           будет инфо о том, что следует изменить. примерно такая:
        //           
        //           
        //               <!-- Author: Alexander Shvets (alex@githowto.com) -->
        //               <html>
        //                 <head>
        //               <<<<<<< HEAD
        //                   <link type="text/css" rel="stylesheet" media="all" href="style.css" />
        //               =======
        //                   <!-- no style -->
        //               >>>>>>> master
        //                 </head>
        //                 <body>
        //                   <h1>Hello,World! Life is great!</h1>
        //                 </body>
        //               </html>
        //           
        //           ). В итоге зако'commit'им новую версию ветки master, введя     git commit -a    . Снова введя    git branch    ты увидишь,
        //           что в репозитории попрежднему 2'е ветки (master и experimental)
        //           
        //           
        //       Как именно выглядят branch'и? Как ты уже мог видеть, branch'и - всего-лишь цепочка commit'ов. Сам по себе branch - это
        //           файл в директории ./.git/refs/heads/. ls -l этой директории может выглядеть так:
        //           
        //               ls -l ./.git/refs/heads/
        //               main
        //               feature1
        //               debug2
        //           
        //           Открыв любой из них, ты увидишь всего-лишь hash-значение, что ссылает на последний commit этой ветки (Git при
        //           надобности просто найдёт commit ./.git/objects/ по этому hash'у). Дальше по ветке ты можешь идти паровозиком по ссылкам от
        //           одного commit'а к другому. Вот и весь секрет
        //       Ещё есть файл ./.git/HEAD - это просто ссылка на текущую ветку. Внутри выглядит примерно так:
        //           
        //               ref: refs/heads/main
        //           
        //           
        //       git branch имеет такие [options]:
        //               --delete, -d <branch>          - удалить ветку <branch> из репозитория. Перед удалением эта ветка должна быть влита в
        //                                                ветку master (или какую-нибудь другую upstream ветку****что такое upstream ветка?)
        //               --force, -f                    - стандартная опция утилит unix для выполнения действия несмотря ни на что
        //               -D                             - shortcut для --delete --force
        //               --move <branch>                - двинуть/переименовать (как утилита mv) ветку <branch> и её барохло. Если <branch>
        //                                                не существует, ничего не произойдёт (даже выхлопа не будет)
        //               -M                             - shortcut для --move --force
        //           
        //           
        //       git switch имеет эти [options]:
        //               --create, -c <branch>  [<from-this-branch>]  - перейти в ветку, что создатся прям сейчас (если <branch> уже есть -
        //                                                              процесс остановится). ****можно задать вторую ветку
        //                                                              [<from-this-brachn>] (возможно, чтобы конкретно указать откуда вывести
        //                                                              ветку)
        //               --force-create, C <branch>                   - то же, что и --create, но теперь, если <branch> уже имеется, процесс не
        //                                                              остановится
        //           /////////after reading: git checkout/////////////////////////////////////////////////////////
        //           // Ты часто можешь видеть, что для смены branch'ей используется раздел git checkout
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //           
        //       При merge'е 
        //           
        //       git merge имеет эти [options]:
        //               ****
        //           


        //   git restore
        //           
        //           



        //   git clone
        //         
        //       Это тот самый раздел git, что ты часто использовал в своих приключениях по миру GNU/Linux. Суть проста - ты просто клонируешь
        //           чей-то репозиторий себе в уютное место. Синопсис прост:
        //           
        //               git clone [options] <dir-with-repo> <target-dir>
        //           
        //           Просто подставь в <dirWithRepo> путь к директории с проектом и нужным репозиторием (т.е. с папкой .git), а в
        //           <target-dir> - директорию, куда этот проект в итоге будет клонирован (клонируется даже .git)
        //         
        //       Если окажется, что в <target-dir> уже имеется ./.git/ репозиторий, то git clone добавит remote, указывающий на
        //           <dir-with-repo>
        //         


        //   git fetch
        //           
        //       Загружает commit'ы, файлы и ссылки (****что есть ссылки в Git'е?) из удалённого репозитория в наш текущий, но
        //           /////////after reading: git pull/////////////////////////////////////////////////////////////
        //           // (в отличие от git pull)
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           не смешивает их. Эти загруженные объекты остаются изолированными от твоих локальных файлов, поэтому они совершенно не
        //           мешают твоей работе. Используй этот раздел, когда ты хочешь посмотреть над чем работают твои товарищи. Синопсис у раздела
        //           git fetch такой:
        //           
        //               git fetch [<options>] [<repo> [<what-to-fetch>]]
        //           
        //           Используй этот раздел, находясь в своём локальном репозитории. В <repo> можешь вставить
        //           просто путь к директории с нужным репозиторием (т.е. с директорией ./.git/), откуда <what-to-fetch> и будут стягиваться
        //           /////////after reading: git remote///////////////////////////////////////////////////////////
        //           // . Под <repo> ты также можешть вставлять имена имеющихся remote'ов
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       Если ты не задашь [<what-to-fetch>], то ты загрузишь всё содержимое репозитория (что находится в <repo>)
        //           
        //       В Git хранилище для объектов одно - ./.git/objects/, так что за'fetch'енные объекты складируются тоже там. Как Git
        //           различает локальные и нелокальные ветки? По ссылкам в ./.git/refs/heads/****?
        //           
        //       /////////after reading: git checkout/////////////////////////////////////////////////////////
        //       // Чтобы посмотреть за'fetch'енные данные, использую раздел git checkout
        //       /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       /////////after reading: git pull/////////////////////////////////////////////////////////////
        //       // Можешь считать раздел git fetch безопасным вариантом раздела git pull. С git fetch ты
        //       //     легко можешь сначала оценить то, что получаешь
        //       /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       Что ты можешь запросить (какие объекты)? Вот список:
        //               > branch'и
        //               > файлы
        //               > remote'ы (****но это не точно)
        //               >****что ещё можно?
        //         
        //       Что делает простая команда    git fetch    ?****
        //         
        //       Вот имеюищиеся [<options>]:
        //           --all              - получить всё содержимое репозитория по <dir-with-repo> (но можно просто не задавать <what-to-fetch>)
        //           
        //           

        
        //   git pull (pull - с англ. тянуть)
        //         
        //       Если кто-то clone'ировал и модифицировал твой проект, и ты хочешь официально внести эти модификации, тебе как раз
        //           следует воспользоваться этим разделом. В git pull ты найдёшь набор инструментов нужный для получения и интегрирования
        //           чужих репозиториев (или местных веток). Синопсис, конечно, несложен:
        //           
        //               git pull [options] [<repo>] [<branch>]
        //           
        //           Под <repo> и <branch> подставляй нужный репозиторий (/путь/к/нему/) и его ветку, откуда хочешь стянуть модификации
        //           /////////after reading: git remote///////////////////////////////////////////////////////////
        //           // (в <repo> также можно подставить имя одного из remote'ов)
        //           /////////////////////////////////////////////////////////////////////////////////////////////
        //           
        //       Сама по себе команда    git pull    - это просто shortcut для этих 2'ух команд:
        //           
        //               git fetch
        //               git merge FETCH_HEAD
        //           
        //           Как видишь, git pull, получив объекты, сразу юзает команду    git merge    , сливая их с твоими локальными файлами
        //           
        //       Допустим, мы хотим за'pull'ить себе поправки какой-нибудь Alice. Мы сделаем это, перейдя в свой проект и применив git pull:
        //           
        //               git pull /home/alice/project/ master
        //           
        //           Эта команда фактически за'merge'ит её ветку master в нашу текущую ветку (сейчас у нас также master). В случае конфликтов
        //           файлов, тебе следует их разрешить
        //           
        //           

        
        //   git rebase
        //           
        //       Поддерживает topic ветки
        //           
        //           

        
        //   git tag
        //           
        //       Создаёт пометки. Синопсис таков:
        //           
        //               git tag [options] [<tag>]
        //           
        //           В разделе git log ты затем сможешь оринетироваться по этим меткам кода (также там есть специальные опции)
        //           
        //       Например, давай оставим пометку текущего времени в качестве тага (таг назавём dddate)
        //           
        //               git tag --message="3 sep 2021" dddate
        //           
        //       [options] имеются такие:
        //               --list, -l           выдать список имеющихся тагов
        //               --delete, -d         удалить заданные <tag>
        //               --
        //               --
        //           
        //           

        
        //   git format-patch
        //           
        //       Подгатавливает email представление нужной тебе ветки (да, упоминание об этой утилитке есть выше)
        //       . Синопсис таков:
        //           
        //               git format-patch [<options>] [<common diff options>] [<since> | <revision-range>]
        //           
        //       Хочешь подготовить к отправке ветку master? Просто введи это:
        //           
        //               git format-patch master
        //           
        //           ****что-то произойдёт, но вывода не будет
        //           
        //           

        
        //   git send-email
        //           
        //       Отправляет подгатовленное email представление (что ты сделал через git format-patch). Email отправляется без порчи по твоему
        //           MUA (****что такое MUA?). Синопсиса аж целых 2-а (но они простые):
        //           
        //               git send-email [<options>] <file|directory|revision-list options>…​      //****revision-list - что это?
        //               git send-email --dump-aliases
        //           
        //           . Как ты понял, этот раздел берёт заданные патчи и email'ит их.
        //           
        //       Если ты решишь отослать ревизии, то может быть задействован формат, принятый через git format-patch
        //           
        //       [<options>] имеются такие:
        //               --to=<address>, ...         - отправить email по этому адресу. <address> может быть "person artur@redhat.com"
        //           
        //           
        //           

        
        //   git-request-pull
        //           
        //       Создаёт сводку из изменений
        //           
        //           
        //           
        //           


        //   git ls-remote
        //           
        //       Выводит список ссылок (в смысле имён или тагов) в каком-нибудь отдалённом репозитории. Синопсис такой:
        //           
        //               git ls-remote [<options>] [<dir-with-repo>] [<refs>...]
        //           
        //       Выбор из [<options>] небольшой:
        //               --heads, -h, --tags, -t  - вывести только сылки и head ****что это?
        //               --
        //               --
        //               --
        //           


        //   git cat-file
        //           
        //       Выводит содержимое и всякую инфу объектов, хранящихся в репозитории. Синопсис таков:
        //           
        //           git cat-file [<options>] <object>
        //           
        //           
        //       [<options>] имеются такие: 
        //               -p               - выводит в удобном виде начинку <object>'а, основываясь на его типе
        //               -t               - вывести тип <object>'а (может быть "commit")
        //               --
        //           


        //   git rm
        //           
        //       Удаляет файлы из директории проекта и из index'а. Синопсис несложен:
        //           
        //           git rm [<options>] [<./../*.*>...]
        //           
        //           
        //       [<options>] этого раздела такие:
        //               --cached              - удалить файл <./../*.*> из index'а
        //               --
        //               --
        //               --
        //           


        //   git show
        //           
        //       Посмотреть изменения, внесённые последним commit'ом. Получается что-то вроде git log'а между двумя последними разделами.
        //           Синопсис очень прост:
        //           
        //               git show [<options>] [<object>...]
        //           
        //           Под <object>... подставляй хеш-значения нужных commit'ов
        //           
        //       Если ты просто введёшь
        //           
        //               git show
        //           
        //           , то выведется полный список изменений по каждому файлу
        //           
        //       Имеет такие [<options>]:
        //               --name-only                    - показать только имена изменённых файлов
        //               --
        //               --
        //           


        //   git reset
        //           
        //       Отменяет последний commit (не работает для первого commit'а). Синопсисы у раздела git reset такие:
        //           
        //               git reset [<options>] [--] <./../*.*>...
        //               git reset [<options>] [<tree-ish>]
        //               git reset [<options>] [--] [<./../*.*>...]
        //               git reset [<options>] [<commit>]
        //           
        //           (****последний commit у меня команда    git reset    не отменила.    git reset <commit>    тоже ничего не сделал)
        //           
        //       [options] здесь таковы:
        //               --hard  -
        //           
        //           
        //           


        //   git clean
        //           
        //       Удаляет файлы из директории проекта, что не включены в репозиторий (т.е. что не отслеживаются им). Синопсис очень прост:
        //           
        //               git clean [<options>] [--] <./../>...
        //           
        //           Хоть параметр <./../> и выглядит обязательным, его ты можешь не указывать (****почему в man-странице он не помещён в []?).
        //           В этом случае    git clean    будет рыскать лишь в текущей директории (./), не залазя во вложенные
        //           
        //       По умолчанию команды раздела git clean предохраняются от удаления этих самых неотслеживаемых файлов. Снять этот предохранитель
        //           ты можешь или используя один небезызвестный параметр (--force), или задав переменную clean.requireForce в true (задаются
        //           они, как ты знаешь, через раздел git config)
        //           
        //       Выбор из [<options>] здесь небольшой:
        //               -d                 - если <./../> не указан, то рыскать и удалять неотслеживаемые файлы во всех поддиректориях. При
        //                                    заданных <./../>... этот параметр эффекта не имеет
        //               --force, -f        - удалять файлы несмотря ни на что
        //               --
        //           


        //   git remote
        //           
        //       Управляет набором удалённых репозиториев, к которым ты имеешь доступ. Да, каждый репозиторий может имеет ссылки на
        //           какие-нибдудь другие (например, чтобы загрузить в один из них последние изменения твоего текущего). Этот раздел имеет свои
        //           подразделы, а у него самого почти нет собственных параметров (кроме параметра [-v | --verbose], что можно поставить перед
        //           парочкой разделов)
        //           
        //       Если ты просто введёшь
        //           
        //               git remote
        //           
        //           , то тебе выведится список имеющихся "remote"'ов (имеющихся ссылок)
        //           
        //       Remote'ы сами по себе - это скорее shortcut'ы для неудобных url. Хранятся они в ./.git/config файле
        //           
        //       Git, вообще, может воспринимает много всяческих ссылок. Из-за лёгкости наиболее распространены 2-а способа - через HTTP и
        //           через SSH протокол. HTTP-ссылка, как ты знаешь, выглядит так:
        //           
        //               http://host/path/to/.git
        //           
        //           . Ты можешь указать её и легко пользоваться репозиторием анонимно (read-only!). Только вот этим репозиторием также легко
        //           может пользоваться и любой другой анонимус. Для read-write доступа с аутентификацией тебе следует использовать SSH. Ccылки
        //           по этому протоколу выглядят так:
        //           
        //               ssh://user@host/path/to/.git
        //           
        //           Тебе, конечно, предварительно стоит иметь готовый SSH аккаунт для такого
        //           
        //       Вот все подразделы и инфо о них:
        //           
        //               git remote add [-t <branch>] [-m <master>] [-f] [--[no-]tags] [--mirror=(fetch|push)] <name> <url>
        //                                                    - добавить remote с именем <name>, указывающий на репозиторий по адресу <url>.
        //                                                      Вот описание всех [опций]:
        //                                                          -f      - после добавления сразу сделать    git fetch    из этого уже
        //                                                                    remote'а
        //                                                          --tags  - сразу сделать    git fetch    для получения тагов
        //               git remote rename <old> <new>
        //                                                    -  
        //               git remote remove <name>
        //               git remote set-head <name> (-a | --auto | -d | --delete | <branch>)
        //               git remote set-branches [--add] <name> <branch>...
        //               git remote get-url [--push] [--all] <name>
        //                                                    - вывести URL этого remote'а с таким именем. Опции у этого подраздела такие:
        //                                                          --push  - ****
        //                                                          --all   - вывести все URL, которым этот remote служит shortcut'ом
        //               git remote set-url [--push] <name> <newurl> [<oldurl>]
        //               git remote set-url --add [--push] <name> <newurl>
        //               git remote set-url --delete [--push] <name> <url>
        //               git remote [-v | --verbose] show [-n] <name>...
        //                                                    - вывести общую инфу о remote'е
        //               git remote prune [-n | --dry-run] <name>...
        //                                                    - удалить все локальные branch'и, которых нет в этом remote'е
        //               git remote [-v | --verbose] update [-p | --prune] [(<group> | <remote>)...]
        //               
        //               
        //               
        //               
        //               
        //               
        //               
        //           
        //           

        
        //   git push
        //           
        //       Загрузить начинку локального репозитория на удалённый репозиторий. Т.е. это как git fetch, но наоборот. Внести начинки ты
        //           можешь в те репозитории, что ты уже добавил через git remote. Вот синопсис:
        //           
        //               git push [<options>] [<remote>] [<what-to-push>]
        //           
        //           В <what-to-push> ты можешь подставить любой объект (будь то commit, целую branch, файлы, ..)
        //           
        //       Если ты решишь отправить branch, то в destination remote она будет числится так, как и все другие branch'и. Все необходимые
        //           commit'ы и связанные объекты также окажутся в этом branch'е
        //       Если такой branch в remote'е уже имелся, он обновиться до твоей версии
        //           
        //       Такой push'инг может перезаписать данные, так что будь аккуратен (это случится, когда в целевом репозитории уже есть этот
        //           branch, но другой версии). Но git push по умолчанию стоит на предохранителе (который можно снять одной опцией)
        //           
        //       Заметь, git push'инг - это в сущности то же, как если бы ты запустил git merge из этого удалённого репозитория
        //           
        //       Раздел git hub наиболее часто используют для сохранения изменений в каком-нибудь центральном репозитории (в github'е,
        //           например)
        //           
        //       ****Разделу git push, как и git fetch и git pull, можно указывать просто путь до директории с репозиторием
        //           
        //       Список [<options>] здесь не очень большой:
        //               --force, -f         - снять предохранитель
        //               --all               - за'push'ить всю начинку локального репозитория в <remote>
        //               --set-upstream, -u  - сделать заданный <remote> upstream'ом (т.е. remote'ом по умолчанию) для <branch>'а. После
        //                                     задания такого upstream'а ты можешь не задавать аргумент <remote>
        //               --
        //           
        //           
        //           
        //           


        //   git checkout
        //           
        //       Переключиться между разными версиями одного и того же объекта.  Вот как выглядят все сценарии использования (представленные в
        //           man-странице):
        //           
        //               git checkout [-q] [-f] [-m] [<branch>]
        //               git checkout [-q] [-f] [-m] --detach [<branch>]
        //               git checkout [-q] [-f] [-m] [--detach] <commit>
        //               git checkout [-q] [-f] [-m] [ [-b|-B|--orphan] <new_branch> ] [<start_point>]
        //               git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>...
        //               git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] --pathspec-from-file=<file> [--pathspec-file-nul]
        //               git checkout (-p|--patch) [<tree-ish>] [--] [<pathspec>...]
        //               
        //           (сценарии не все, т.к. есть и другие [опции])
        //               
        //       На самом деле этот раздел по большей своей части устарел. В версии Git 2.23 (2019-ый год) создатели решили выделить обе
        //           его функционалости в разные разделы - git switch и git restore:
        //               > git switch   - для смены branch'ей
        //               > git restore  - для ****
        //               
        //       Раздел git checkout работает только с 3-емя типами объектов:
        //               > файлами
        //               > commit'ами
        //               > branch'ами
        //           
        //       Хочешь switch'нутся в другую ветку? Просто введи это:
        //           
        //               git checkout <branch>
        //           
        //       Этот раздел меняет всю рабочую директорию, показывая тебе то, что ты хочешь check out'ить
        //           
        //       ****Git отслеживает историю checkout-операций в неком reflog. есть такой раздел - git reflog
        //           
        //       Раздел git checkout часто используется для просмотра за'fetch'енной начинки с какого-нибудь удалённого репозитория. В отличии
        //           от git switch, git checkout видит все полученные branch'и (****во время написании змейки только checkout смог увидеть
        //           ветку dev). Выглядит это так:
        //           
        //               git checkout <remote-branch>
        //           
        //           Как видишь, для него нет разницы, откуда этот branch
        //           
        //                   В более старых версия Git'а так разница между remote branch'ем и обычным branch'ем была.
        //                       Приходилось создавать отдельный
        //                       локальный branch и привязывать его к желанному <remote-branch>'у:
        //                       
        //                           git checkout -b <remote-branch> <remote>/<remote-branch>
        //                       
        //                   Есть ещё один способ:
        //                      
        //                           git checkout -b <branch>
        //                           git reset --hard <remote>/<branch>
        //                    
        //       Выбор из [options], как видишь, небольшой:
        //               --quiet, -q                -
        //               --progress, --no-progress  -
        //               --force                    -
        //               --ours, --theirs           -
        //               -b                         - создать новый <branch> и переключиться на него. ****также что-то про <start_point>
        //               -B                         - 
        //               --merge, -m                - ****
        //               --
        //           


        // Options
        //
        //   
        //     
        //     
        //     


        // You got info from these resources
        //     
        //     > Изначально из man-страниц git'а, но там слишком много инфы (а gittutorial объяснял очень поверхностно)
        //     > Позже я полез в интернет, и нашёл прекрасный сайт https://www.atlassian.com/git/tutorials/syncing, где поясняется немного
        //       (самое основное), но поясняется очень глубоко


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Git_Silent()");
    }
    static void AWordAboutPatterns_Silent()
    {
        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   AWordAboutPatterns_Silent()\n");


        // Со слов Adam'а Freeman'а
        //     
        //     Паттерны - это лишь решения других людей для проблем, что они встретили в своих проектах. Знание этих решений может помочь тебе
        //         решить твою проблему, если она похожа ни ихнюю. Но это не значит, что ты должен следовать их паттерну безукоризненно в
        //         случае, если ты и сам понимаешь всю суть и последствия. Если паттерн нацелен на то, чтобы сделать проект более manageable, и
        //         ты решаешь отклониться от него, то да, твой проект в итоге может оказаться более сложным в управлении. Но знай, что если бы
        //         ты решил следовать паттерну до конца, всё могло быть даже хуже. Иногда полное следование паттерну оказывается хуже, чем
        //         неследование ему
        //     
        //     Мой совет - это использовать паттерны свободно, адаптируя их, если необходимо, и игнорировать конченных фанатиков, что путают
        //     паттерны с заповедьми
        //     


        // С Лурка
        //     
        //      Лурк говорит, что паттерновая болезнь рапространена в программистком мирке даже больше, чем быдлодейвайская в мирке гаджетов.
        //      Серьёзно, примерно половина погромистов, ещё не познавших дзен сеньоризма, на полном серьёзе суют паттерны в проекте до 10000
        //      строк кода, раздувая тем самым его в 3-4 раза (понтуются, может)
        //     


        // Examples
        //     
        //      Если хочешь посмеятся, посмотри на Hello World! in de patterns


        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   AWordAboutPatterns_Silent()");
    }
    static void ASPNETPreview_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   ASPNETPreview_Silent()\n");


        // WhatItIs
        //       
        //   ASP.NET Core - он мощен, эффективен, open source'ен и cross-platform'енен. Собственно, на нём и строится всё web'евское, вроде
        //       всеми любимых интернет сервисов
        //   На этой штуке, кстати, крутиться половина вакансий C#'овцев
        //   На момент 21 aug 2021 актуальна версия ASP.NET Core 5
        //       
        //   Вообще, ASP - это Active Server Pages
        //       
        //   В ASP.NET'е строится как UI, так и API (т.е. в одном проекте целиком может уместится весь твой сайтик)
        //   ASP.NET конструировался так, чтоб его легко могли тестировать
        //       
        //   ASP.NET Core - быстрейший веб-фреймворк на планете (пруф -
        //       https://www.techempower.com/benchmarks/#section=data-r19&hw=ph&test=plaintext&a=2?azure-portal=true)! Точнее, был какое-то
        //       время
        //       
        //   Исходные коды ASP.NET Core с самого начала выклали на GitHub
        //       
        //   Как и весь .NET Core, ASP.NET Core - модульная платформа. Ты можешь использовать те модули (NuGet пакеты), что тебе нужны.
        //       В отличие от ASP.NET Classic, с ASP.NET Core нет необходимости использовать System.Web.dll
        //       
        //       
        //       
        

        // ASP.NET History
        //
        //   В старые до'.NET'ные времена (времена Windows NT) эта штука (тогда ещё звавшаяся ASP) была аддоном (и ставилась отдельно) к
        //       Internet Information Server (IIS)(веб-сервер). Когда .NET релизнули, из этого add-on'а и сделали ASP.NET
        //   Как и многие другие составные части .NET'а, ASP.NET (на протяжении лет) как минимум несколько раз сильно менял свою форму
        //  
        //   Изначально был ASP.NET Web Forms (2002 год), где разработчики писали код и скрипты, чтоб затем этот движок перевёл C#-код в HTML.
        //   
        //   Затем, в 2009-ом был релизнут ASP.NET MVC, и это сильно всех потрясло. MVC (Model-View-Controller, о нём ниже)
        //       появился именно в то время. На таком ASP.NET'е мы сейчас и живём
        //   
        //   ASP.NET MVC появился вместе с ASP.NET Web Pages (последний вышел чуть позже, в 2010-ом). В ASP.NET Web Pages страницы (также,
        //       как и в Web Forms) строились на C#'пе ****как я понял. Microsoft'цы сделали ставку именно на фреймворк Web Pages, переделав
        //       ASP.NET под него (и от этого ASP.NET MVC местами был костыльный)
        //
        //   В самом начале cross-platform революции (2016 год) Micro$oft'цы, в паре с .NET Core 1.0, выпустили ASP.NET Core 1.0.
        //       Конечно, как ты помнишь, эти индусы взяли фактически уже готовый продукт (что разработали чуваки для проекта Mono). На самом
        //       деле ASP.NET Core начали разрабатывать ещё в 2014-ом (тогда платформа условно называлась ASP.NET vNext)
        //
        //   До cross-platform революции ASP.NET звался ASP.NET 4.x (т.к. .NET Framework был версии 4.x), после его
        //       переименовали в ASP.NET Core. Новая редизайненная версия оказалась чуть стройнее и модульнее. Алсо, Microsoft, ставши
        //       community-ориентированной Корпорацией Зла, запустила .NET Live TV (нет, правда, https://dotnet.microsoft.com/live)(хотя
        //       напоминает это всё детский сад. маскот-робот присутствует)
        //  
        //  В ноябре 2020-го вышла версия ASP.NET Core 5.0
        //


        // ASP.NET Core and ASP.NET 4.x comparison  //before: MVC, Razor Pages, Web api, SignalR, WebHooks
        //   
        //   ASP.NET Core                                   ASP.NET 4.x
        //   
        //   Работает с Windows, macOS, и Linux             Работает с Windows
        //   
        //   /////////after reading/////////////////////    /////////after reading/////////////////////
        //   // Создаёт Web UI в основном с Razor Pages     // Используй Web Forms, SignalR,
        //   // (начиная с ASP.NET Core 2.x). Также         // MVC, Web API, WebHooks или Web Pages
        //   // доступны MVC, Web API и SignalR             //
        //   ///////////////////////////////////////////    ///////////////////////////////////////////
        //   
        //   Разрешены множество версий на одной            Только одна версия на одной машине
        //   машине
        //   
        //   Может разрабатываться с Visual Studio,         Может разрабатываться с Visual Studio
        //   Visual Studio for Mac, VS Code на C# и F#      на C#, VB и F#
        //   
        //   Производительность выше, чем у                 Хорошая производительность
        //   ASP.NET 4.x
        //   
        //   Использует .NET Core runtime                   Использует .NET Framework runtime
        //   
        //   Хранит зависимости в своём легковесном         Хранит зависимости в стороннем контейнере
        //   контейнере, может хранить в стороннем          (например, Autofac, Ninject)
        //   (****что такое контейнер?)
        //   
        //   /////////after reading: HTTP///////////////    /////////after reading/////////////////////
        //   // Использует новый конвейер запросов HTTP     // ****что использует?                     
        //   //                                             //                                         
        //   //                                             //
        //   ///////////////////////////////////////////    ///////////////////////////////////////////
        //   
        //   
        //   


        // How web works
        //
        //   Если в кратце, то твой шлюз в интерент - браузер. Он может связывать с серверами по провадам или как-то ещё. Ты открываешь его,
        //     открываешь какой-то сайт. Он, получив из имени этого сайта IP код (те самые 122.00.4), пытается достучатся до этого сервера.
        //     Сервер откликается, шлёт свою картинку (и какую-то логику) в ответ (предварительно разложив это всё в пакеты). Ты, видя
        //     кнопки/ссылки/что-тоЕщё, конечно, можешь нажать на них, и запустить какую-то связанную логику. Логика может попросить бразуер
        //     снова связаться с сервером, чтоб получить новый пакет с нужной сейчас инфой. Примерно так
        //
        //   На самом деле браузер - это не единственный шлюз в интернет. Он просто был сделан одним из первых, т.к. все изначально решили, что
        //     сайтики - прекрасная вещь
        //   


        // HTTP, www  //after How web works
        //
        //   HTTP - Hyper Text Transfer Protocol. Это как раз тот протокол (т.е. набор соглашений), по которому перемещаются пакеты между
        //     клиентами и серверами. Именно протокол HTTP определяет, какой вид должны иметь пакеты с данными, как они должны отправляться,
        //     как они должны идти и как они должны приниматься
        //   ASP.NET, конечно, работает с HTTP искаропки. Это очень хорошо, ведь получается, что данные проходят весь путь от конца к концу
        //     в виде неприступных HTTP пакетов
        //     /////////after reading: HTTPS////////////////////////////////////////////////////////////////
        //     // (на самом деле обычные http пакеты очень даже приступны. если хочешь обезопаситься, юзай
        //     // https пакеты)
        //     /////////////////////////////////////////////////////////////////////////////////////////////
        //
        //   www - World Wide Web. Эта штука связывает клиенты (компьютеры пользователей) с серверами
        //   
        //   ****HTTP основан на компонентах Katana и спецификации OWIN. А ещё этот протокол модульный, и его легко расиширить своими
        //       компонентами (- говорит метанит, но в вики на странице про HTTP ничего нет про Katana и OWIN)


        // HTTPS!
        //   
        //   HTTPS - то же, что HTTP, но Secure. Имея солидный опыт сёрфинга инета, ты давно понял, что следует заходить только на
        //     https://-сайты
        //   Если говорить поподробнее, то HTTPS защитит твои пакеты от атак перехватичков между сервером и клиентом. Точнее, перехватить они
        //     такие пакеты всё ещё смогут, но вот получить инфу - нет
        //   
        //   /////////after reading: Create your own web//////////////////////////////////////////////////
        //   // Помнишь флаг --no-https, у утилиты dotnet при создании по шаблону webapi (полная команда
        //   //     выглядит так:    dotnet new webapi --no-https    )? Как ты понял ещё тогда, по
        //   //     умолчанию dotnet создаёт проекты с HTTPS сертификатом
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //


        // Web Pages (obsolete techlonogy)
        //     
        //     Фреймворк Web Pages появился в 2010-ом.
        //     
        //     Этот фреймворк упоминался выше (в истории ASP.NET Core). Как ты понял, на нём .NET'оцы 2010-ых годов могли писать сайтики,
        //         используя C#
        //     
        //     
        //     Хотя ASP.NET Web Pages и появился примерно в одно время с ASP.NET MVC, люди не особо использовали этот фреймворк. Он имел
        //         несколько недостатков, что ярко усиливались в сравнении с MVC
        //         /////////after reading: MVC//////////////////////////////////////////////////////////////////
        //         // . Пока MVC Framework проекты чётко разделялись на отдельные части, Web Pages проекты
        //         // стардали из-за структурных проблем
        //         /////////////////////////////////////////////////////////////////////////////////////////////
        //         . Но зато простенькие проектики на Web Pages строятся всего за пару часов
        //     
        //     


        // MVC
        //
        //     Допустим, мы пишем сайт, где клиенты могут покупать какие-то вещи. Эти самые товары - это Models (модели). На сайт заходит
        //         клиент, он смотрит товары, получает инфо о них, складывает в корзину. Эти действия - Controllers, т.е. эти действия для
        //         управления моделями (попросить модель выдать инфу, заставить модель перейти в корзину, попросить модель о скидке).
        //         Пользователь, конечно, видит все изменения у себя на экране (инфу о модели, скидку, ...) - эта часть зовётся View
        //         
        //     Ну т.е. понимаешь, да?
        //         
        //             > Model - представляет данные, реагируют на команды контроллера, изменяя своё состояние
        //             > View - отвечает за отображение модели пользователю, реагируя на изменение модели
        //             > Controller - интерпретирует действия пользователя, оповещяя модель о необходимости измений
        //         
        //     MVC, как видишь, - шаблон (pattern). Он описывает только общее положение дел. А это значит, что нет никакой разницы в том, на
        //         каком языке этот шаблон реализован
        //         
        //     Вся фишка MVC в том, что он разделяет всё приложение на 3-и большие части, полностью независимые друг от друга. Это даёт
        //         сильнейший плюс к тестируемости
        //         
        //         
        // MVC Framework (ASP.NET MVC)
        //         
        //     ASP.NET Core включает имеет в своём составе MVC Framework, что объеденяет в себе паттерн MVC, Web API (****что это?) и Web Pages
        //         
        //     History
        //         
        //         *****В до ASP.NET MVC технологии Web API и Web Pages существовали отдельно, часто дублируя друг друга. Теперь они объеденены
        //             в MVC Framework (- говорит метанит. но ведь Web Pages Framework вышел позже ASP.NET MVC)
        //         
        //         Ранние версии MVC Framework'а строились на старом ASP.NET'е, что изначально был спроектирован для Web Pages. Из-за этого
        //             MVC Framework в некоторых своих частях был костыльным (но всё-таки люди переходили на него, покидая Web Pages)
        //             
        //         При cross-platform революции (2016-ый) MVC Framework был перестроен под новый, открытый, расширяемый и cross-platform'енный
        //             ASP.NET Core, избавившись от старых костылей
        //             
        //         /////////after reading: SPA//////////////////////////////////////////////////////////////////
        //         // Чуть позже всё сместилось в сторону SPAs. Оказалось, что single-page applications удобнее
        //         //     , чем MVC паттерн. Теперь MVC Framework используется лишь для поддержки SPAs
        //         /////////////////////////////////////////////////////////////////////////////////////////////
        //       
        //     Один из заметных недостатков MVC Framework'а в том, что с ним тебе придётся проделать кучу подготовительной работы перед тем,
        //         как приложение начнёт генерировать контент (Web Pages же здесь явно выигрывает)
        //         
        //     MVC фреймворк привнёс такие штуки, как tag helper'ы, что более органично соединяют C# код с кодом HTML
        //         


        // SPA
        //         
        //     Single-page applications (SPAs) - по этой технологии браузер делает один HTTP запрос и получает один HTML файл, включающий в
        //         себя целый (обычно) JavaSript клиент (например, Angular или React)
        //       


        // Alternatives
        //
        //   Silverlight
        //  
        //       На самом деле, кроме ASP.NET'а существовало ещё несколько задумок для web-базы. Например, Silverlight, который шёл как плагин
        //           к браузерам. Идея состояла в том, что, раз уж браузеры так сильно ограничивают код в себе (привет, интернет-игрушки!),
        //           почему бы не построить мост за пределы браузера?
        //       Пользоваться этим, правда, никто не стал. На сегодняшний день Silverlight считается заброшенным
        //  
        //   Windows 8's app model
        //  
        //       По этой модели разработчикам следовало писать GUI приложения, использующие HTML для разметки графики. Да, это вообще не
        //           касается настоящего web'а ****но Прайс почему-то решил написать об этом. Эта модель также оказалась почти никем не
        //           тронута, ведь запуск Windows 8 был полным провалом (и люди туда не шли)


        // Where you can put ASP.NET application
        //
        //   > Kestrel
        //   > IIS (ещё жив!)
        //   > HTTP.sys
        //   > Nginx
        //   > Apache
        //   > Docker
        //


        // Server and Cliend rendered UI  //after MVC
        //   
        //   Есть три подхода построения web UI с использованием ASP.NET Core:
        //   
        //           > Рендерить UI на сервере
        //           > Рендерить UI на юзерском браузере
        //           > Рендерить часть UI на сервере, часть на юзерском браузере (например, юзерский браузер будет рендерить размер страницы
        //             под себя)
        //       
        //       В первом случае юзеру остаётся лишь получить готовые HTML и CSS файлы (в виде пакетов) и сразу вывести их на экран. Это,
        //       конечно, сильно хорошо для юзеров на слабых устройствах. А ещё такие сайты будут работать на гораздо большем диапазоне
        //       браузеров. Правда, сильно возрастает нагрузка на сервер, ведь весь рендер происходит на нём, и на каждый тык пользователя
        //       придётся создавать новую страницу
        //       
        //       Во втором случае юзеру придётся получать громоздкий набор "собери сам" (включающий JabbaScript код и начинку страницы)(не
        //       каждый браузер сможет это произвести).
        //       Это всё будет грузится на комп юзера дольше, и затем ещё какое-то время займёт, собственно, рендеринг картинки. Но зато
        //       в интерактивности здесь уже нет предела. Каждый тык пользователя юзерский бразуер будет обрабатывать на месте, что хорошо
        //       как для сервера, так и для самого пользователя (резульутат у него будет мгновенный)(но понми, юзер ищет на твоём сайте текст и
        //       картинки, но не анимацию со свистелками)
        //       
        //   /////////after reading: Razor Pages, Blazor//////////////////////////////////////////////////
        //   // В команде Server rendered UI находятся фреймворки ASP.NET Core MVC и Razor Pages
        //   // В команде Client rendered UI находятся Blazor и ASP.NET Core Single Page Application
        //   //     (SPA)(в связке с JavaScript фреймворками)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //
        //
        //
        //


        // REST  //after HTTP
        //
        //   REST - Representational State Transfer (надмозг. переноситель репрезентативного состояния). Если вкратце, то это такой стиль
        //     построения web-сервиса (иначе говоря, web-инструмента, функционалости). REST запросы (т.е. команды) строятся на HTTP, т.е. они
        //     описываются на том же синтаксисе, на котором браузеры принимают и отправляют пакеты из интернета
        //     
        //   Вот некоторые слова из синтаксиса HTTP:
        //       > GET     - инструкция для получения данных из web-сервиса 
        //       > POST    - создать новый пакет в web-сервисе
        //       > PUT     - обновить пакет в web-сервисе
        //       > PATCH   - обновить пакет в web-сервисе, отправив набор инструкция для него
        //       > DELETE  - удалить пакет в web-сервисе
        //     
        //   Web-сервисы, что построены в соостветствии с REST, зовутся RESTful APIs
        //  
        //   Всякая RESTful web-сервисная API строится из:
        //  
        //       > Базового URL
        //       > HTTP инструкций
        //       > Каких-нибудь файлов с данными (вроде JSON'ов или XML)
        //
        //****ничего не понятно, ты должен знать больше!
        

        // .NET HTTP REPL
        //    
        //   Традиционно вебсайты тестируются их создателями прямо в браузере. Но индусы из Microsoft решили сделать более удобную штуку -
        //     .NET HTTP REPL (Read-Eval-Print-Loop). Это такая cmd утилитка для тестирования каждой фишки твоего будущего сайта
        //     (****но это не точно)


        // Create your own web, Secret Manager
        //       
        //   Самый простенький сайт быстрее всего создать через dotnet cli, через шаблон web. Это один из тех шаблонов, что имеют свои
        //       собственные [<options>]. Вот они:
        //       
        //           dotnet new web [<options>]    - Выбор из [<options>] здесь такой:
        //                                                 --no-https   - создать webapp проект, что будет запускаться без HTTPS сертификата.
        //                                                                Эта штука тебе не нужна, если ты делаешь простенький проект
        //                                                 --help, -h   - вывести help раздела dtonet new + help этого шаблона
        //       
        //       web - сокращение для шаблона ASP.NET Core Empty (в VS используется полное название)
        //       
        //   Я создал директорию ./SimpleWeb_ASP.NET/, и произвёл команду
        //           dotnet new web --no-https
        //       там
        //       
        //   По шаблону webapp dotnet new создаст эти файлы и деректории:
        //       
        //           ./SimpleWeb_ASP.NET.csproj        - файл с настройками твоего проекта (как настраивать ты уже знаешь)
        //           ./Program.cs                      - файл с методом Main(), что настраивает и запускает веб-хост
        //           ./Startup.cs                      - содержит класс Startup, что конфигурирует сервисы (штуки, что предосатвляют
        //                                               функционалости сайта) и конвеер запросов приложения (логику обработки входящих
        //                                               запросов)
        //                                               (комментарии в нашем ./SimpleWebApp_ASP.NET/Startup.cs присутствуют)
        //           ./Properties/                     - директория содержит некоторые второстепенные настройки проекта (вроде тех, что
        //                                               описывают как запускать)
        //           ./Properties/launchSettings.json  - хранит настройки того, как запустить проект (мои комментарии в этом файле
        //                                               присутствуют)
        //           ./appsettings.json                - config файл проекта в формате .json
        //           ./appsettings.Development.json    - ****
        //       
        //       После компиляции (например, разделом dotnet run) появятся ещё две стандартные папки (которые ты уже знаешь):
        //       
        //           ./bin/
        //           ./obj/
        //       
        //   Запустив наш новоиспечённый проект с сайтом (например, инструкцией     dotnet run    ) и открыв его (по тому URL, что прописан в
        //       ./Properties/launchSettings.json) ты увидишь те самые слова "Hello World!"
        //       
        //   Если ты раньше не создавал никаких ASP.NET проектов, то dotnet cli установит в себя новый .NET runtime -
        //       Microsoft.AspNetCore.App (все runtime'ы ты можешь посмотреть, введя dotnet --info)(****ASP.NET Core использует .NET Core
        //       runtime, так что это точно не runtime). Также dotnet cli обзаведётся новыми подкатегориями параметров. Вот они (****возможно,
        //       они не относятся к ASP.NET'у):
        //           > dev-certs                             - ****
        //           > fsi                                   - ****
        //           > sql-cache                             - ****
        //           > user-secrets                          - ****
        //           > watch <program>                       - запускать file watcher, что запустит твою программу, как только файлы изменятся.
        //                                                     Можно использовать в паре с run (вводя    dotnet watch run ...    ), и
        //                                                     dotnet cli будет запускать проект по новой при изменениях в нём
        //                                                    (****я так понял)
        //                                                   
        //
        //   ****нужно как-то сделать https сертификат для dotnet cli
        //       
        // Что именно изменяет флаг --no-https? Чтож, вот сравнение их ./Properties/launchSettings.json'ов:
        //
        //       Проект по    dotnet new web                                                Проект по    dotnet new web --no-https             
        //       {                                                                          {                                                  
        //         "iisSettings": {                                                           "iisSettings": {                                 
        //           "windowsAuthentication": false,                                            "windowsAuthentication": false,                
        //           "anonymousAuthentication": true,                                           "anonymousAuthentication": true,               
        //           "iisExpress": {                                                            "iisExpress": {                                
        //             "applicationUrl": "http://localhost:7049",                                 "applicationUrl": "http://localhost:18277",  
        //             "sslPort": 44391                                                           "sslPort": 0                                 
        //           }                                                                          }                                              
        //         },                                                                         },                                               
        //         "profiles": {                                                              "profiles": {                                    
        //           "IIS Express": {                                                           "IIS Express": {                               
        //             "commandName": "IISExpress",                                               "commandName": "IISExpress",                 
        //             "launchBrowser": true,                                                     "launchBrowser": true,                       
        //             "environmentVariables": {                                                  "environmentVariables": {                    
        //               "ASPNETCORE_ENVIRONMENT": "Development"                                    "ASPNETCORE_ENVIRONMENT": "Development"    
        //             }                                                                          }                                            
        //           },                                                                         },                                             
        //           "dotnetTest2": {                                                           "dotnetTest": {                                
        //             "commandName": "Project",                                                  "commandName": "Project",                    
        //             "dotnetRunMessages": "true",                                               "dotnetRunMessages": "true",                 
        //             "launchBrowser": true,                                                     "launchBrowser": true,                       
        //             "applicationUrl": "https://localhost:5001;http://localhost:5000",          "applicationUrl": "http://localhost:5000",   
        //             "environmentVariables": {                                                  "environmentVariables": {                    
        //               "ASPNETCORE_ENVIRONMENT": "Development"                                    "ASPNETCORE_ENVIRONMENT": "Development"    
        //             }                                                                          }                                            
        //           }                                                                          }                                              
        //         }                                                                          }                                                
        //       }                                                                          }                                                  
        //


        // Create your own webapp  //after https!
        //       
        //   Простетский проект сайта
        //       /////////after reading: Razor Pages//////////////////////////////////////////////////////////
        //       // с обработкой запросов через Razor Pages
        //       /////////////////////////////////////////////////////////////////////////////////////////////
        //       быстрее создать через dotnet cli, из шаблона web app. Этот шаблон имеет свои собственные [<options>]. Вот они
        //       
        //           dotnet new webapp [<options>]    - Выбор из [<options>] здесь таков:
        //                                                 --no-https   - действует также, как при шаблоне web
        //                                                 --help, -h   - вывести help раздела dtonet new + help этого шаблона
        //       
        //       webapp - сокращение для шаблона ASP.NET Core Web App (в VS выводятся полные имена)
        //       
        //   Я создал директорию ./SimpleWebApp_ASP.NET/, произвёл инструкцию
        //           dotnet new webapp
        //       там
        //       
        //     
        //   Запустить этот проект будет лучше, если ты задействуешь подраздел watch:
        //
        //           dotnet watch run
        //     
        //       Сделав это, ты увидешь, что (..) ничего не происходит (кроме выплёскивание логов в терминал). Но на самом деле твой сайт
        //       запустился на Kestrel web сервере (****но это не точно****а что это?), ты просто не открыл его. https://localhost:5001 - вот
        //       где хостится твой первый вебсайт
        //       
        //   По шаблону webapp dotnet new создаст эти файлы и деректории:
        //       
        //           ./Pages/                        - да, у нас есть директория ./SimpleWebApp_ASP.NET/Pages/. Файлы в ней описывают то, как
        //                                             страницы нашего сайта должны выглядеть. По умолчанию рисуется вполне симпатичная
        //                                             страница, хоть она и содержит в себе всего несколько элементов. Ты можешь открыть
        //                                             https://localhost:5001 и посмотреть на неё сам
        //           ./Properties/                   - ****
        //           ./wwwroot/                      - ****
        //           ./appsettings.Development.json  - ****
        //           ./appsettings.json              - ****
        //           ./SimpleWebApp_ASP.NET.csproj   - файл с настройками твоего проекта
        //           ./Program.cs                    - ****
        //           ./Startup.cs                    - суть та же, что у шаблона web. Код немного другой
        //       
        //       Razor pages
        //       
        //                  Файл ./.../Pages/Index.cshtml задаёт вид главной страницы. В этом файле имеются мои комментарии
        //          
        //          Вообще, Razor Pages - это page-based модель (и фреймворк). По ней UI и бизнес-логика держутся раздельно, но в пределах
        //              одной страницы.
        //          
        //          Данный фреймворк легче понять, чем ASP.NET Core MVC. Ещё Razor Pages хорош тем, что:
        //                  > UI на нём строится и редаткируется несколько быстрее
        //                  > Он легко тестируем
        //                  > Логика и UI одной страницы хранятся в одной директории (но в разных namespace'ах)(****я так понял)
        //                  > Группа связанных страницы может хранится в одной директории и namespace'е (****я так понял)
        //          


        // Create your own webapi  //after https!
        //       
        //   Простетский проект web-сервиса быстрее создать через dotnet cli, из шаблона web api. Этот шаблон имеет свои собственные
        //       [<options>]:
        //       
        //           dotnet new webapi [<options>]   - [<options>] могут быть такие:
        //                                                 --no-https   - делаешь то же, что и у шаблона web
        //                                                 --help, -h   - вывести help раздела dtonet new + help этого шаблона
        //       
        //       webapi - это сокращение шаблона ASP.NET Core Web API (в VS в выборе выводятся только полные имена)
        //       
        //   Я создал директорию ./ContosoPizza_ASP.NET/, и выполнил в ней такую команду:
        //       
        //           dotnet new webapi --no-https
        //       
        //       Выполнив её, мы получили каркас проекта. В нём имеются некоторые ещё незнакомые тебе файлы и директории. Если конкретно, эти:
        //       
        //           > ./Controllers/                  - здесь храниться класс WeatherForecastController, определяющий в себе HTTP инструкцию
        //                                               GET (в виде C#-повского метода Get() с атрибутом [HttpGet])
        //           > ./Program.cs                    - собственно, стартовая точка программы. Метод Main() создаёт хост
        //           > ./Startup.cs                    - а этот метод конфигурирует твой хост при старте****но это не точно
        //           > ./appsettings.Development.json  - ****
        //           > ./appsettings.json              - ****
        //           > ./WeatherForecast.cs            - здесь хранится сам класс ContosoPizza_ASP.NET.WeatherForecast, его объекты будут
        //                                               хранить данные о прогнозах погоды
        //       
        //       Компилирование и запуска проекта производится этим:
        //           
        //           dotnet run
        //     
        //       ****ты перенёс отсюда большой кусок текста в блок о webapp
        //       (но это не ссылка на страницу сайта. если ты откроешь её, твой браузер не найдёт ничего)(если бы мы не прописали
        //       флаг --no-https, сайт бы хостился на https://localhost:5001). Перейди по ссылке http://localhost:5000/weatherforecast, чтобы
        //       действительно посмотреть на результат. Ты увидишь начинку json-файла (хоть и в неудобном оформлении)! Именно в
        //       этот json файл и были упакованы объекты типа ContosoPizza_ASP.NET.WeatherForecast
        //       
        //****что такое webapi?


        // Create your own mvc  //after Create your own webapp
        //       
        //       mvc - это сокращение шаблона ASP.NET Core Web App (Model-View-Controller)
        //       
        //       



        // Create your own angular  //after Create your own web
        //       
        //       angular - это сокращение шаблона ASP.NET Core With Angular
        //       
        //       


        // Create your own react  //after Create your own web
        //       
        //       react - это сокращение шаблона ASP.NET Core With React.js
        //       
        //       



        // Create your own reactredux  //after Create your own web
        //       
        //       reactredux - это сокращение шаблона ASP.NET Core With React.js and Redux
        //       
        //       


        // Blazor
        //   
        //   Blazor приложения состоят из частей Razor (а именно частей для реюзабельности и web UI, уже написанном на C#, HTML и CSS
        //       ****всё ещё непонятно). И клиентский, и серверный здесь пишется на C#'е (и это сильно упрощает разработку)(а ещё страница
        //       юзера можешь пользоваться общими сборками из GAC****но это не точно)
        //   
        //   Сами Razor части ты можешь разместить или на Blazor Server, или на Blazor WebAssembly
        //   


        // ASP.NET Map
        //     Если собрать всё в кучу, то ASP.NET Core выглядит так:
        //           
        //               ASP.NET
        //               ┌──────────────────────────────────────┬────────────────────────────────────┐
        //               │ Фреймворки приложения                │  Фреймворки полезных утилит        │
        //               │                                      │                                    │
        //               │    MVC       Razor   Blazor          │    Identity    Entity              │
        //               │  Framework   Pages                   │               Framework            │
        //               │                                      │                                    │
        //               ├──────────────────────────────────────┴────────────────────────────────────┤
        //               │ Платформа                                                                 │
        //               │                                                                           │
        //               │    HTTP     Middleware   URL Routing   Dependency   Configuration         │
        //               │   Server                               Injection     & Logging            │
        //               │                                                                           │
        //               │   Caching    Model          Razor      gRPC        SignalR                │
        //               │             Binding                                                       │
        //               │                                                                           │
        //               └───────────────────────────────────────────────────────────────────────────┘
        //           
        //           Почему фреймворком приложения несколько? Просто они решают разные проблемы (на самом деле иногда решают одну проблему. в
        //           таком случае ты сам решаешь каким пользоваться)


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   ASPNETPreview_Silent()");
    }
}