/*
 * creation date  19 jun 2021
 * last change    31 jul 2021
 * author         artur
 */
using System;

using Excel = Microsoft.Office.Interop.Excel;

class _DLR_DynamicProfit_MicrosoftOfficeInteropExcelNamespace_COMExtraANDPIA
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        DLR_Silent();
        DynamicProfit();
        MicrosoftOfficeInteropExcelNamespace_Silent();
        COMExtraANDPIA_Silent();
        
        Console.ReadLine();
    }
    static void DLR_Silent()  //after DynamicType
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   DLR_Silent()\n");


        // WhatIsIt
        //
        //   DLR (Dynamic Language Runtime) - это как раз та часть добавленной инфраструктуры, что, собственно, и работает с динамическими
        //     типами (остальная инфраструктура - это ключевое слово dynamic, namespace Microsoft.CSharp.RuntimeBinder с иключениями и
        //     расширение компилятора для его обработки нужным для DLR способом).
        //     Ввели её в C# 4.0 в качестве расширение к CLR. Конечно, концепция "динамической исполняющей среды" (DLR) не нова, и она уже
        //     много лет
        //     применяется в таких языках, как LISP, JavaScript, Ruby и Python. Если кратко, то DLR просто даёт возможность обнаруживать
        //     типы прямо в runtime (без участия компилятора)
        //   Конечно, привышкий к строгой типизации человек посчитает эту возможность неподходящей для работы (т.к. хотелось бы узнавать об
        //     ошибках ещё при компиляции). Тем не менее, динамические языки (или те, что имеют хотя бы свой DLR) предлагают интересные
        //     возможности, вроде этих:
        //  
        //     >  Черезвычайно гибкая кодовая база. Ты можешь производить рефакторинг не внося многочисленные изменения в типы данных (ну
        //        типа когда ты меняешь тип параметра в каком-нибудь методе)
        //     >  Простой способ взаимодействия с разнообразными типами, что построенны на разных платформах (COM, .NET) и языках (что
        //        используют динамическую типизацию. Самые популярные в .NET - это IronRuby и IronPython)
        //     >  Способ добавления и удаления типов прямо в runtime
        //  


        //                                             //
        dynamic d = "someobject";                      //
        d.ToString().Equals("otherobject");            //
        //                                             //
        // ExpressionTree                              //
        //
        //   Для описания динамического члена (метода, например) во время использования среда DLR задействует так называемые "деревья выражений"
        //     . Например, когда CLR встречает код
        //
        //         dynamic d = GetSomeData();
        //         d.GetSomeData(12);
        //
        //     (на CIL языке, кончено)(как ты помнишь, компилятор оставляет всё в нетронутом виде****но это неточно), она, во первых, передаёт
        //     его среде DLR, а та уже и создаёт дерево выражения, которое по существу гласит: "Вызвать метод
        //     SuperMethod() объекта d с передачей в него числа 12". Затем эта инфо (формально называемая "полезной нагрузкой") передаётся
        //     соответствующему связывателю (binder'у) времени выполнения (связыватель связывает эту инфу в подходящий код. это может
        //     быть динамический связыватель C#, динамический
        //     связыватель IronPython или даже унаследованный объект COM. О последнем чуть позже.
        //     Связыватель просто выясняет текущий тип динамической
        //     переменной (у нас это d) и затем, используя дерево выражения (точнее его полезную нагрузку) вызывает нужный член переменной (как
        //     это делается у обычных переменных)
        //   Ну ты понял, такой вызов - это "дерево выражений", т.к. в нём одно вырожение выходит после другого, а некоторые выражения даже
        //     могут быть
        //     внутри других (например,    d.GetSomeData(d.GetName(), 12).ToString()    . Из этой строки построится дерево
        //     ****на самом деле ты предположить неправильно, т.к. в CIL коде, наверное такой строка разделится на много мелких
        //         строк-инструкций)
        //   Деревья выражений удобны тем, что (помимо ненужности строить их самим) ты не беспокоишься о том, какой
        //     связыватель будет задействован (для C#, IronRuby, IronPython или объекта COM). Он будет подобран верно исходя из твоего кода.
        //     Вот схема процесса:
        //
        //                                                      ┌────────────────┐
        //                                      ┌─────────────┐ │  Связыватель   │ ┌─────────────┐
        //     ┌──────────────────────────────┐ │ Связыватель │ │    IronRuby    │ │ Связыватель │
        //     │  dynamic d = GetSomeData();  │ │     COM     │ │ или IronPython │ │    .NET     │
        //     │  d.SuperMethod(12);          │ └──────┬──────┘ └───────┬────────┘ └──────┬──────┘
        //     └──────────────┬───────────────┘        └────────────────┼─────────────────┘
        //                    │                          ┌──────────────┴──────────────┐
        //          ┌─────────┴─────────┐                │  Исполняющая среда          │
        //          │ Дерево выражений  ├───────>>───────┤  динамического языка (DLR)  │
        //          └───────────────────┘                │  платформы .NET             │
        //                                  ┌────────────┴─────────────────────────────┴────────────┐
        //                                  │  Общеязыковая исполняющая среда (CLR) платформы .NET  │
        //                                  └───────────────────────────────────────────────────────┘
        //
        //     Ещё автор говорит, что деревья выражений описаны в нейтральных терминах (т.е. они независимы от языка)(конечно, ведь здесь уже
        //     уровень CIL кода. А вот объекты, что скрываются в dynamic переменной - да, различаются. под каждый объект свой связыватель)


        // SystemDynamic
        //
        //   Сборка System.Core.dll хранит пространство имён System.Dynamic. На самом деле врядли тебе когда-нибудь придётся использовать
        //     типы из него, ведь они созданы для тех, кто хочет создать свой собственный динамически типизированный .NET язык, способный
        //     работать с DLR.
        //     Типы из System.Dynamic не будут рассматриваться в энкциклопедии, но, если ты заинтересован, можешь узнать всё необходимое из
        //     .NET Framework 4.7 SDK. Если же создавать собственный язык ты не планируешь, то тебе просто достаточно знать, что
        //     System.Dynamic предоставляет необходимую инфраструктуру, которая делает динамический язык "осведомлённым о платформе .NET"


        // DynamicSearchInExpressionTreeInRuntime
        //
        //   Как уже писалось, DLR отправляет деревья выражений к подходящему связывателю, что должен будет, собственно, связать переменную и
        //     её член. Давай посмотрим чуть детальнее
        //   Если динамическая переменная указывает на объект
        //     COM, то дерево выражения отправляется некому объекту, что реализует низкоуровневый интерфейс IDispatch (с англ. - отправка,
        //     отсылка)(этот интерфейс вне .NET'а). Этот объект - уже чисто COM'ская вещь. В этом объекте внедрён COM'овский набор
        //     динамических служб (они - это и есть связыватель COM). Хотя объекты COM можно использовать и без DLR и ключевого слова dynamic
        //     языка C#, такой подход сопряжён с написанием более сложного кода C#
        //     /////////after reading:DynamicProfit/////////////////////////////////////////////////////////
        //     // (это ты увидишь чуть позже в методе про DynamicProfit)
        //     /////////////////////////////////////////////////////////////////////////////////////////////
        //     . А дальше твоим
        //     объектом (что сейчас уже в оболчке объекта IDispatch) займётся RCW (Runtime Callable Wrapper. всё ещё помнишь, что это?)
        //   Если переменная динамического типа ссылается не на COM-объект, а на объект типа, что реализует интерфейс IDynamicObject
        //     (тоже что-то низкоуровневое), то
        //     его методы (методы интерфейса) будут использованы "за кулисами". Это позволит таким языкам, как IronRuby принимать это дерево
        //     выражения DLR и отображать его на специфические средства языка Ruby (объекты IronRuby, IronPython и подобных языков реализуют
        //     IDynamicObject по умолчанию)(так работает связыватель IronRuby и IronPython)
        //   Наконец, если динамическая переменная не является объектом COM и не реализует IDynamicObject, то это нормальный повседневный
        //     объект .NET, и дерево выражения (что создаёт DLR) передаётся связывателю .NET. Процесс отображения этого дерева выражения
        //     основан на службах рефлексии (да, здесь всё просто)


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   DLR_Silent()");
    }
    static void DynamicProfit()  //after LateBinding
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   DynamicProfit()\n");


        // Как уже писалось, dynamic может сильно помочь тебе при работе с поздним связыванием (напомню, что "позднее связывание" - это когда
        //   ты используешь начинку сторонней сборки, о который компилятор ничего не знал)


        void ClassicLateBinding(System.Reflection.Assembly asm)  // Classic.. - для начала напомню, как это делали мы в методе про LateBinding,
        {                                                        //   когда мы не знали о dynamic (так делали все до C# 4.0)
            try
            {
                Type miniVanType = asm.GetType("CarLibrary.MiniVan");
                object myMiniVan = System.Activator.CreateInstance(miniVanType);                     // asm.GetType()/System.Activator.. - как
                System.Reflection.MethodInfo turboBoostMInfo = miniVanType.GetMethod("TurboBoost");  //   ты помнишь, можно было сделать и
                turboBoostMInfo.Invoke(myMiniVan, null);                                             //   так:
            }                                                                                        //       asm.CreateInstance("..");
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
        void DynamicUsingLateBinding(System.Reflection.Assembly asm)  // DynamicUsing.. - а вот как это делается почти всеми в наше время
        {
            try
            {
                Type miniVanType = asm.GetType("CarLibrary.MiniVan");
                dynamic myMiniVan = Activator.CreateInstance(miniVanType);
                myMiniVan.TurboBoost();         // myMiniVan.TurbotBoost() - как ты понял, теперь нам не нужно вручную получать метаданные
            }                                   //   о методе и работать с ним, а не с нашим объектом. Вся эта рутинная работа
            catch (Exception ex)                //   перекладывается на DLR (на самом деле DLR будет делать те же действия, что и с
            {                                   //   обычными переменными). Также при отправке аргументов в метод ты можешь прям
                Console.WriteLine(ex.Message);  //   таки их отправлять, без предварительного упаковывания их в массив object[]
            }                                   // ..Turbo..() - не забываем, что для вызова членов dynamic переменной нужна
        }                                       //   Microsoft.CSharp.dll
        ClassicLateBinding(System.Reflection.Assembly.LoadFrom(@"..\..\..\..\chapter14\14.2_Assembly\bin\Debug\14.2.dll"));
        DynamicUsingLateBinding(System.Reflection.Assembly.LoadFrom(@"..\..\..\..\chapter14\14.2_Assembly\bin\Debug\14.2.dll"));


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   DynamicProfit()");
    }
    static void COMExtraANDPIA_Silent()  //after Assembly,Manifest,DynamicType,LinkingAssemblies,MicrosoftOfficeInteropExcelNamespace
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   COMExtraANDPIA_Silent()");


        // COMExplanationOfUsing
        //  
        //   Если у тебя не было опыта работы с COM, то знай, что скомпилированная библиотека COM содержит метаданные (да, как в
        //     сборках .NET), правда, их структура совершенно другая. Это приводит к тому, что если тебе нужно работать с типами COM, сначала
        //     потребуется сгенерировать так называемую "сборку взаимодействия", и пользоваться уже ей (которую на самом деле ты будешь
        //     использовать не как обычную сборку с кодом, а как хранилище понятных для C#/VB/IronRuby/.. метаданных)
        //   Имей ввиду, что некоторые распространённые ресурсы (включая продукты Office) до сих пор доступны только через COM. Поэтому
        //     знание принципов взаимодейтсвия с Component Object Model может пригодится
        //     (это может стать твоей киллер-фичей на собесе)
        //  
        //   Здесь я создал проект 16.3.1_ExportMetadataOfOffice прямо в текущем решении, при компиляции которого выплюнется наша собственная
        //     сборка взаимодействия вместе с нашим .exe. Нам всего лишь нужно (если VS) добавить ссылку в его Reference Manager к нужной
        //     COM-сборке
        //     (или сразу нескольким. иногда при добавлении одной COM-сборки в References можно увидеть сразу новых несколько ссылок****разве
        //     так и не должно быть?). Я
        //     подключил некую DexterLib (что в реальности C:\Windows\System32\gedit.dll)(после подключения я выключил в окне Properties
        //     этой ссылки пункт Embed Interop, и оставил свойство Copy Local в значении true. О первом будет рассказано чуть ниже, а о второй,
        //     как ты помнишь, нужен, чтоб сборка взаимодействия появилась прямо в .\bin\Debug\ энциклопедии). Сам код этого проекта просто
        //     демонстрирует возвожность
        //     полноценного использования COM-кода, и это стало возможным, т.к. компилятор разместил рядом с приложением настоящую сборку
        //     взаимодействия, к которой у него есть ссылка. Эта сборка (Interop.DexterLib.dll) содержит описание метаданных со сборки COM
        //     в .NET-формате (правда, перевести метаданные удалось не все, и VS выдаёт 10 предупреждений об этом). В ней нет никакого кода
        //     (разве что могут быть его небольшие порции, что помогают транслировать события COM в события .NET). Разработчкики .NET пошли
        //     путём сборки взаимодействия, чтоб защитить кодовую базу .NET от сложностей внутреннего механизма COM (вообще, да, .NET - это
        //     просто современный наследник COM)
        //   Если для DexterLib ты выставишь свойство Copy Local в False, то приложение не заработает, т.к. Interop.DexterLib.dll не будет
        //     в его зоне видимости (эта сборка взаимодействия останется только в .\obj\Debug\)(****а если подправить .config-файл, чтоб CLR
        //     нашла Interop.DexterLib.dll?)
        //   ****ты не выполнить проверка этого проекта 16.3.1_.., т.к. сидеть в VS Code с .NET 5.0.
        //       тебе стоит сделать проверка, чтоб всё компилироваться. ты ещё не знать как подключать COM сборка к .NET 5.0. может тебе ещё
        //       стоит перенесить код с проекта сюда
        //  
        //   За кулисами при использовании её начинки среда CLR (или, если ты будешь использовать dynamic - DLR) будет автоматически
        //     отображать типы .NET на типы COM и наоборот. Данные будут гулять между приложениями .NET и COM, проходя через оболочку времени
        //     выполнения (Runtime Callable Wrapper - RCW), которая по существу - динамически сгенерированный прокси (представитель). Другими
        //     словами, RCW просто переводит объекты .NET и COM в обе стороны (если в COM отсылает char[], то .NET получит string). Вот как
        //     это будет выглядить для .NET объекта, что ссылается на COM-тип:
        //  
        //         ┌───────────────────────────────────────────────────────────────────┐
        //         │ CLR                                                               │
        //         │                                 ┌──RCW──Неуправляемый объект COM  │
        //         │   Управляемый объект .NET──<──>─┼──RCW──Неуправляемый объект COM  │
        //         │                                 └──RCW──Неуправляемый объект COM  │
        //         │                                                                   │
        //         └───────────────────────────────────────────────────────────────────┘
        //  
        //     Да, сборка взаимодействия тем и отличается от обычных сборок, что свой код она не даёт (т.к. его нет, а если и есть, то он
        //     служебный), а запросы на него со стороны приложения перенаправляются (незаметно для него) службами RCW на COM-библиотеки
        //  
        //  /////////after reading:PIA///////////////////////////////////////////////////////////////////
        //  // Многие COM библиотеки имеют свою собственную официальную сборку взаимодествия. Их
        //  //   прозвали Primary Interop Assembly (PIA)(у DexterLib такой нет). Такие сборки уже
        //  //   оптимизированны, и они также лежат где-то в GAC
        //  /////////////////////////////////////////////////////////////////////////////////////////////
        //  


        // PrimaryInteropAssembly(PIA)
        //
        //   Многие библиотеки COM имеют свою собственную официальую сборку взаимодействия, их прозвали Primary Interop Assembly (основаная
        //     сборка взаимодействия, PIA). Сборки PIA создавались как оптимизированные версии сборок взаимодействия,
        //     код в которых приведён в порядок (а иногда и расширен). Основные сборки взаимодействия обычно перечисленны в
        //     Reference Manager -> Assemlbies -> Extensions. Находятся они где-то в GAC
        //  
        //   Здесь в качестве примера я буду использовать PIA для Excel'а Microsoft.Office.Interop.Excel версии 15.0.0.0
        //   Эта сборка поставляется в составе индивидуального компонента (individual component) VS под названием VSTO (Visual Studio Tools for
        //     Office) или в составе рабочей нагрузки (workload) Office/SharePoint development. Если этого у тебя ещё нет, то для проработки
        //     текущего метода тебе следует её установить. Быстро это можно сделать, используя в VS поле Search
        //     и написать VSTO, а затем из предложенных вариантов выбрать Install Visual Stu..
        //   ****2021 jul 13: ты использовать VS Code и dotnet. ты просто подключить эта сборка как nuget пакет. может ты можешь подключить так
        //       всякая сборка? тебе стоит написать об этом в правильный место
        //  
        //   До выхода .NET 4.0, когда приложение C# хотело задействовать библиотеку COM (через PIA или нет), ему следовало проследить за тем,
        //     чтоб подходящая сборка взаимодействия имелась на клиентской машине. Т.е. установочный пакет должен был тоскать эту сборку с собой
        //     и, если на машине такой сборки ещё нету, размещать сборку в подходящее место (PIA сборки ставились, конечно, в GAC)
        //     
        //   Однако в .NET 4.0 (и следующих версиях) данные взаимодействия можно было встраивать прямо в скомпилированное приложение. Т.е.
        //     теперь не нужно было таскать их в виде отдельной .dll. По умолчанию при выборе COM-библиотеки в Reference Manager (не PIA,
        //     а именно COM) VS автоматически выставит для неё свойство Embed Interop Types в True (это свойство можно увидеть в окне
        //     Properties, что, напомню, открывается через Solution Explorer -> Solution .. -> .. -> References -> .. (ПКМ))
        //   Также, как и с обычными сборками, компилятор будет включать только те части из библиотеки взаимодействия, что действительно
        //     используются (сборка взаимодействия, видимо, в какой-то степени будет создана компилятором в ходе этого способа)
        //


        // COMUsingDifficulties
        //
        //   Перед действительным примером нам следует рассмотреть ещё одну тему. До выпуска DLR (т.е. до .NET 4.0) при работе с COM (тогда
        //     ещё всегда через отдельные .dll'шные сборки взаимодействия) неизбежно возникало несколько сложностей. Многие методы из
        //     COM-библиотек имели
        //     прототип, принимающий необязательные аргументы (т.е. у параметров были значения по умолчанию), которые вплоть до .NET 3.5 в C#
        //     не поддерживались, и требовалось указывать значение System.Type.Missing (static readonly поле) каждому необязательному аргументу,
        //     который ты не хочешь использовать (начиная с .NET 3.5 стало можно это опускать, компилятор научился сам расставлять
        //     Type.Missing необязательным параметрам)
        //   Также многие методы COM поддерживают именованные агрументы (ну т.е. те методы, язык программирования которых такую штуку позволяет)
        //     . Разработчики C# смогли воспользоваться этим только в C# 4 (что вышел 11 апреля 2010, за день до выхода .NET 4.0)
        //   Больше всего доставлял тип данных с именем Variant, что иногда встречался в прототипах. Фактически, это батя dynamic, т.к. он
        //     ещё тогда мог на лету стать кем угодно. До появления dynamic в C# для передачи и приёма объектов с типом Variant приходилось
        //     по настоящему ухищряться (обычно через многочисленные операции приведения, т.к. в сборки взаимодействия этот тип попадал как
        //     System.Object)
        //  
        //   Как ты понял, начиная с .NET (и C#) версии 4.0 работа с COM упростилась в разы. Если у нужной тебе COM-сборки свойство Embed
        //     Interop Types стоит в True, то все её типы Variant автоматически переведутся в dynamic (если ты будешь использовать обычную
        //     сборку взаимодействия, то придётся использовать старый стиль). Этот способ не только сокращает потребность в паразитных
        //     операциях приведения, но и также ещё больше скрывает некоторые сложности структуры COM, вроде работы с индексаторами COM
        //


        /////////after reading: MicrosoftOfficeInteropExcelNamespace////////////////////////////////////////////////////////////////////////////
        //
        // COMAndDynamicUsing
        //
        //   Здесь будет продемонстрировано то, как именно необязательные аргументы, именованные аргументы и ключевое слово dynamic работают
        //     бок о бок при использовании COM (значительно упрощая процесс). Напоминаю, что работаем мы с PIA Microsoft.Office.Interop.Excel.
        //     Свойство Embed Interop Types выставлено в True, поэтому сложностей с Variant у нас не возникнет (на самом деле его здесь и нет)
        //
        //   Нужную часть этого пространства ты уже знаешь, так что при чтении этого кода у тебя не должно возникнуть проблем
        //
        System.Collections.Generic.List<Car> cars= new System.Collections.Generic.List<Car>
        {
            new Car { Make="VM", Color="Green", PetName="Mary" },
            new Car { Make="Saab", Color="Red", PetName="Mel" },
            new Car { Make="Ford", Color="Black", PetName="Hank" },
            new Car { Make="BMW", Color="Yellow", PetName="Davie" },
        };
        //
        void ExportToExcel(System.Collections.Generic.List<Car> carsInStock)
        {                                                          // carsInStock - напомню, что в списке хранится лишь набор ссылок. Сами
            Excel.Application excelApp = new Excel.Application();  //   Cars хранятся в управляемой куче
            excelApp.Workbooks.Add();                              // Excel - это псевдоним для namespace'а Microsoft.Office.Interop.Excel. Ты
                                                                   //   , в общем-то, редко где его увидишь (если тебя не затянет в разработку
                                                                   //   Office от мелкомягких, конечно. или просто не запрягут делать вечные
                                                                   //   отчёты)

            Excel._Worksheet workSheet = (Excel._Worksheet)excelApp.ActiveSheet;
            workSheet.Cells[1, "A"] = "Make";
            workSheet.Cells[1, "B"] = "Color";
            workSheet.Cells[1, "C"] = "PetName";
            int row = 2;
            foreach (Car curr in carsInStock)
            {
                workSheet.Cells[row, "A"] = curr.Make;
                workSheet.Cells[row, "B"] = curr.Color;
                workSheet.Cells[row, "C"] = curr.PetName;
                row++;
            }

            workSheet.Range["A1"].AutoFormat(Excel.XlRangeAutoFormat.xlRangeAutoFormatClassic2);

            workSheet.SaveAs($@"{Environment.CurrentDirectory}\Inventory.xlsx");
            excelApp.Quit();

            Console.WriteLine("The Inventory.xlsx has been saved to your app folder");
        }
        //
        ExportToExcel(cars);  // ExportToExcel() - при запуске этого метода в папке .\Debug\bin\ этого проекта появится файл Inventory.xlsx с
        Console.WriteLine();  //   данными, что мы туда записали. Они будут выглядеть в довольно красивом оформлении
        //                    // Т.к. мы используем современные возможности (возможности опускания необязательных аргументов, ключевого слова
        //                    //   dynamic, ..) для работы с COM, мы получили гораздо более компактный и лёгкий код по сравнению с тем, что нам
        //                    //   пришлось бы написать без них
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        //   Вот, собственно, что из себя представляет dynamic и DLR (как они ведут себя в связке с COM ты также увидел). Dynamic предоставляет
        //     неимоверную гибкость в коде, но за это ты платишь безопаностью кода.
        //     Здесь мы видели ситуации, когда полезно использовать именно динамическую типизиацию, ведь статическая типизация в таких
        //     условиях начинает задыхаться (попробуй сделать функцию ExcelToExport() без использования dynamic для глубокого понимания. я это
        //     сделал, и говорю, что это больно)
        //     Помимо постоянных приведений объектов object к нужным типам, иногда придётся использовать низкоуровненвые свойства Value2)
        //   Если тебя интерисует более специфичные средства DLR, вроде индеграции с языками для сценариев, то твой путь проложен в
        //     .NET Framework 4.7 SDK (лучше начинай с темы "Dynamic Language Runtime Overview". это очевидное начало)

        
        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   COMExtraANDPIA_Silent()");
    }
    class Car  //****ты просто копировать ту реализация класса Car, что быть в CodeFile..cs. при этом ты знать, что ты уже иметь класс Car
    {
        public string Make { get; set; }
        public string Color { get; set; }
        public string PetName { get; set; }
    }
    static void MicrosoftOfficeInteropExcelNamespace_Silent()  //after COMExtra
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   MicrosoftOfficeInteropExcelNamespace_Silent()\n");


        // Пространство Microsoft.Office.Interop.Excel - ****


        //                                              //
        // Т.к. эта COM-библиотека не входит в          //
        //   стандартную библиотеку .NET, IntelliSense  //
        //   не будет предлагать тебе изранные члены    //
        //   местных типов (откудаж ему знать их)       //
        //                                              //


        // Чтобы код был хоть чуточку проще, наши инженеры решили сделать alias для немаленького имени Microsoft.Office.Interop.Excel. Мы
        //   надеемся, что это облегчит жизнь и тебе
        //
        Microsoft.Office.Interop.Excel.Application excelApp = new Excel.Application();
        //                                                  // ..Excel.Application - это интерфейс, и объект его реализующий (объект excelApp)
        //                                                  //   мы можем использовать как хранилище целого приложения Excel (верно, в нём будут
        //                                                  //   листы таблиц, настройки, и .. и всё том же духе). И да, мы вызываем конструктор
        //                                                  //   интерфейса. Вообще, здесь мы будет работать только интерфейсами
        //excelApp.Visible                                  // excelApp.Visible - по умолчанию окно приложения не отобразиться, но это можно
        //                                                  //   сделать, задав это свойство в true
        //
        //
        excelApp.Workbooks.Add();                        // excelApp.Workbooks - это свойство для доступа к объекту, реализующему интерфейс
        //                                               //   Microsoft.Office.Interop.Excel.Workbooks
        //                                               //   (это коллекция объектов ..Workbook, что представляют открытые рабочие книги
        //                                               //   в текущем приложении). Его метод Add() просто добавляет новый чистый
        //                                               //   экземпляр типа Microsoft.Office.Interop.Excel.Workbook в коллекцию
        Excel._Worksheet workSheet = (Excel._Worksheet)excelApp.ActiveSheet;
        //                                               // Microsoft.Office.Interop.Excel._Worksheet - этот интерфейс представляет лист
        //                                               //   таблицы
        //                                               // excelApp.ActiveSheet - это { get; }-свойство выдаст тебе текущий лист
        //                                               //   текущей книги в твоём приложении ****на момент 13 oct 2020 (когда я делать
        //                                               //                                        конспект с C# 6 и .NET 4.7) эта штука сразу
        //                                               //                                        выдавать правильный тип. Сейчас,
        //                                               //                                        13 jul 2021 (когда ты делать энциклопедия
        //                                               //                                        с C# 9.0 и .NET 5.0), эта штука выдавать
        //                                               //                                        object
        //                                               //
        workSheet.Cells[1, "A"] = "Make";     // workSheet.Cells - это свойство (также read-only) даст тебе объект интерфейса
        workSheet.Cells[1, "B"] = "Color";    //   Micrisoft.Office.Interop.Range (прямоугольный кусок таблицы, может быть даже 3-D), хранящий
        workSheet.Cells[1, "C"] = "PetName";  //   вообще всю таблицу. Через его индексатор (принимающий два объекта object) ты
        //                                    //   можешь получить dynamic объект с нужной тебе ячейкой (столбец может быть
        //                                    //   задан как большой, так и маленькой буквой, главное, чтобы это был string)
        //                                    //
        workSheet.Range["A1"].AutoFormat(Excel.XlRangeAutoFormat.xlRangeAutoFormatClassic2);
        //                                                 // workSheet.Range - странное read-only свойство, дающее тебе доступ к ..Excel.Range
        //                                                 //   экземпляру. Если ты заглянешь в его определение, то увидишь, что это вообще
        //                                                 //   не свойство, а метод в прототипом
        //                                                 //       Range get_Range(object Cell1, object Cell2);
        //                                                 //   Тем не менее, IntelliSense даёт ему знак свойства, а его второй параметр
        //                                                 //   - необязателен. Мы здесь выбрали ячейку A1, и, т.к. вторую ячейку мы не
        //                                                 //   задали, индексатор просто выдаст прямоугольную область, в которую входят
        //                                                 //   все ячейки, до которых можно дотянутся, начиная от окружающих ячеек, не
        //                                                 //   наступая при этом на пустые. Если так будет выбрано меньше двух ячеек,
        //                                                 //   индексатор (который метод) выдаст исключение, говорящее о том, что
        //                                                 //   Microsoft Excel не смог автоматически определить нужную область
        //                                                 // workSheetRange[..].AutoFormat(..) - этот метод форматирует свой объект
        //                                                 //   ..Excel.Range , принимая достаточно много праметров (хорошо, что все они
        //                                                 //   необязательны).
        //                                                 //   Нам понадобится только один из них. С этим методом связана одна аномалия
        //                                                 //   IntelliSense (записано в видео, что сейчас хранится в google Drive****где
        //                                                 //   именно? кажется, видео затерятся)
        //                                                 // ..xlRangeAutoFormat - это перечисление хранит в себе 43 различных форматов
        //                                                 //   для оформления ячеек. Да, они предопределены
        //
        workSheet.SaveAs($@"{Environment.CurrentDirectory}\Inventory.xlsx");
        excelApp.Quit();                                   // workSheet.SaveAs(..) - сохраняет слепок текущей структуры твоего приложения в
                                                           //   отдельном файле. Принимает достаточно много параметров, но обязателен
                                                           //   только один (тот, что принимает объект string с именем файла). Если
                                                           //   в целевой папке уже будет файл с таким именем, то выйдёт дополнительное
                                                           //   окно с предложением перезаписать. Лучше нажать "Yes", т.к. при других
                                                           //   случаях (это кнопки "No" и "Cancel") выйдет исключение (одно и то же
                                                           //   на два случая, что странно)
                                                           // excelApp.Quit() - этот метод закрывает приложение в объекте
                                                           // $@".." - напомню, что дословные строки (коих всего 2-е) можно комбинировать


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   MicrosoftOfficeInteropExcelNamespace_Silent()");
    }
}