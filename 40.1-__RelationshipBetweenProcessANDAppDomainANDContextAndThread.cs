/*
 * creation date  23 oct 2021
 * last change    23 oct 2021
 * author         artur
 */
using System;

class __RelationshipBetweenProcessANDAppDomainANDContextAndThread
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        RelationshipBetweenProcessANDAppDomainANDContextAndThread_Silent();

        Console.ReadLine();
    }
    static void RelationshipBetweenProcessANDAppDomainANDContextAndThread_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   RelationshipBetweenProcessANDAppDomainANDContextAndThread_Silent()\n");


        // Как уже упоминалось (в методе о строении процесса .NET), поток - попросту говоря идущий по тропинке рабочий компьютера,
        //   постоянно нажимающий на кнопки под ногами. Хотя многие приложения способны прекрасно работать и с одним таким работником (это
        //   первичный поток), часто полезно иметь сразу нескольких. Если ты подставишь нужные кнопки под идущий поток, он может натыкать
        //   себе дочерний, который даже может принести пользу (если кнопки на его тропинке будут расставлены правильно)
        // Простраснтво System.Threading (в котором и хранятся кнопки для работы с потоками), поставляется ещё с .NET 1.0, и оно предлагает
        //   один из подходов к созданию многопоточного приложения. Его центральным типом можно назвать класс System.Threading.Thread
        //   (т.к. он представляет, собственно, сам поток). Мы уже несколько раз использовали его (как минимум статическое свойство
        //   CurrentThread)
        // Как мы уже давно знаем, один домен может иметь многочисленные потоки. Как оказалось, иногда эти потоки могут пересекать границы
        //   доменов приложения, когда планировщик потоков Windows и среда CLR сочтут это подходящим. Чтобы программно получить инфо о
        //   домене, что в данные момент обслуживает твой текущий поток, понадобится вызвать статический метод ...Thread.GetDomain()
        // Также одиночный поток в любой момент времени также можно быть перенесён в определённой контекст и перемещаться внутри нового
        //   контекста по прихоти среды CLR. Для получения текущего контекста, существует статическое свойство ...Thread.CurrentContext
        // Как разработчик .NET, ты всегда остаёшься в блаженном неведении о том, что именно происходит с твоим текущим потоком. Ты не
        //   знаешь, когда он в точности перемещается внутрь новых границы и когда завершится. Он может быть приостановлен, а ты даже не
        //   заметишь этого. Тем не менее, ты должен быть осведомлён о разнообразных способах получения лежащих в основе примитивов


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   RelationshipBetweenProcessANDAppDomainANDContextAndThread_Silent()");
    }
}