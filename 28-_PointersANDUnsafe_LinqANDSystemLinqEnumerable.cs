/*
 * creation date  25 apr 2021
 * last change    26 jun 2021
 * author         artur
 */
using System;
using System.Linq;
using System.Collections.Generic;

class _PointersANDUnsafe_LinqANDSystemLinqEnumerable
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        PointersANDUnsafe();
        LinqANDSystemLinqEnumerable();

        Console.ReadLine();
    }
    static unsafe void PointersANDUnsafe()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   PointersANDUnsafe()\n");


        // Как мы знаем, в C# есть две крупные группы данных. Это типы значения и ссылочные типы (но истоки у них одни). На самом деле есть ещё
        //   и третья категория - типы указателей, позволяющее обойти схему управления CLR (и, конечно, операторы здесь сделаны в стиле Си)
        //
        // Операции и ключевые слова для них:
        //       *                     - звёздочка применяется для создания указателя и для его дальнейшего разымёнывания
        //       &                     - этим можно получить из переменной адрес её памяти (здесь адрес уже не просто число, а отдельный тип)
        //       ->                    - этим получают доступ к члену через указатель, не разымёнывая его явно
        //       []                    - как мы помним, этим можно индексировать память, начиная от байта, на который указывает адрес
        //       ++, --                - инкремент и декремент тоже имеются
        //       +, -                  - сложение и вычитание также могут применятся к местным указателям
        //       ==, !=, <, >, <=, >=  - сравнивать указатели тоже можно
        //       stackalloc            - этим ключевым словом можно выделить память для массива прямо в стёке (такого нет в Си)
        //       fixed                 - этим можно временно закрепить данные ссылочного объекта в памяти, чтобы гарантировать их
        //                               несдвигаемость
        // Разумеется, вся работа с указателями считается здесь очень небезопасной. Но ещё стоит сказать, что ты очень редко, если вообще
        //   когда-нибудь будешь использовать указатели в своих реальных проектах. Среда .NET не имеет вообще никакаого понятия о твоих
        //   намерениях при их применении, и всю полноту последствий ты снова берёшь на себя (но разве это не прекрасно, когда всё под твоим
        //   контролем?)
        //
        // На самом деле существует всего две распространённые ситуации, когда может возникнуть необходимость в них:
        //   > Нужно оптимизировать часть приложения, напрямую манипулируя памятью
        //   > Необходимо вызывать функции из DLL-библиотеки, написанной на Си, или сервера COM, требующих передачи в них указателя
        //     /////////after reading///////////////////////////////////////////////////////////////////////
        //     // (но даже здесь можно обойтись без них, используя System.IntPtr и члены типа System.Runtime.InteropServisec.Marshal)
        //     /////////////////////////////////////////////////////////////////////////////////////////////
        //   Во всех остальных случаях простых ссылок достаточно (даже для типов значений, ведь у нас есть ref и out с их boxing-unboxing'ом)


        unsafe                                                             // unsafe - небезопасный (т.е. использующий указатели) код всегда
        {                                                                  //   должен находится внутри блока кода, помеченного этим. По
                                                                           //   умолчанию компилер ругнётся на применение unsafe, чтоб он это
            int otherInt = 5;                                              //   принял, нужно добавить флаг /unsafe для него (в VS это можно
            Console.WriteLine("myInt is {0}", otherInt);                   //   сделать, поставив галочку у Build -> General ->
            SquareIntPointer(&otherInt);                                   //   Allow unsafe code в свойствах проекта. Если ты без VS, то правь
            Console.WriteLine("myInt after handling is {0}\n", otherInt);  //   .csproj файл вручную, сделав так:
        }                                                                  //       ..
                                                                           //       <PropertyGroup>
                                                                           //         ..
                                                                           //         <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
                                                                           //       </PropertyGroup>
                                                                           //       ..
                                                                           //   . Т.е. добавь <AllowUnsafeBlocks>.. в любой <PropertyGroup>
                                                                           //
        unsafe void SquareIntPointer(int* pNum)  // SquareIntPointer() - если метод грешит небезопасностью прямо в прототипе, ты должен
        {                                        //   использовать unsafe прямо в его объявлении, ну, или, если это локальная функция,
            *pNum *= *pNum;                      //   определить во внешнем unsafe-блоке. В дальнейшем этот метод можно будет вызывать
        }                                        //   в любом месте в пределах своего блока. Ну и да, начинка функции также автоматически
                                                 //   начинает считаться unsafe


        int myInt;
        int* ptrMyInt = &myInt;  // int* - отличительный момент указателей C# в том, что звёздочка их при объявлении относится к типу, а
                                 //   не к имени переменной. Например, так делается в Си (и C++):    int *p_one, *p_two;    , а так в C#:
        *ptrMyInt = 253;         //       int* pOne, pTwo;
        Console.WriteLine("myInt is {0}", myInt);
        Console.WriteLine("The Address of myInt is {0:X}\n", (int)&ptrMyInt);  // {0:X} - ты же ещё на забыл про эти модификаторы для
                                                                               //   WriteLine(), верно?
                                                                               // (int)&.. - да, здесь легко можно было использовать myInt
                                                                               //   . Заметь, Console.WriteLine() требует объекты object
                                                                               //   ведь указатели здесь, всё-таки, отдельная группа данных),
                                                                               //   поэтому следует перевести указатель в int


        char* p = stackalloc char[256];  // stackalloc - если тебе понадобится, этим ты можешь выделить себе память прямо в стёке. В Си
        for (int i = 0; i < 256; i++)    //   эту работу делала функция alloca() (не из стандарта, но работает и на винде, и на лине).
            p[i] = (char)i;              //   (на винде была более безопасная _alloca(), что предохраняла от UB, undefined behavior при
                                         //   переполнении стёка). Выделенная память освобождается, как только метод завершит свою работу
        for (int i = 0; i < 256; i++)
            Console.Write(p[i]);
        //
        Console.WriteLine('\n');
        //
        int* GetIt()
        {
            int num = 955;
            Console.WriteLine("we will send {0} with address of {1:x}", num, (int)&num);
            return &num;                 // return - здесь мы возвращаем адрес локальной переменной, что исчезнет через мгновения. Интересно
                                         //   что выйдет
        }                                // На самом деле такое прямое возвращение адреса локальной переменной в Си вызовет warning (у gcc), а
                                         //   вовзратится при этом NULL (правда, это легко обойти, сохранив этот адрес сначала в другую
        int* it = GetIt();               //   переменную)
        Console.WriteLine("we got {0:x}", (int)it);
        Console.WriteLine("it is {0}\n", *it);
        //                               // *it - выдаст 0


        // Интересно, что операция & (получения адреса памяти) здесь не может применятся к ссылочным типам (хотя указатель на указатель здесь
        //   таки работает, хоть и со странностями)
        //
        PointClass point = new PointClass { x = 100, y = 200 };
        Console.WriteLine("point is {0}", point);
        //                          //
        fixed (int* px = &point.x)  // fixed - при этом мы можем хранить адреса их внутренних полей, но только зафиксировав этот объект
        {                           //   в куче от нежелательных действий CLR при реорганизации кучи, вроде удаления или перемещения
            *px = 105;              //   данных в любой момент. Эта заморозка действует до конца оператора (пока блок не завершится).
        }                           //   Компилятор до последнего пытается обезопасить твой код
                                    //
        Console.WriteLine("now point is {0}\n", point);


        Console.WriteLine("The size of short is {0}", sizeof(short));  // sizeof() - это последнее ключевое слово, связанное с
        Console.WriteLine("The size of int is {0}", sizeof(int));      //   небезопасным кодом. Как и в Си, оно служит для получения
        Console.WriteLine("The size of long is {0}\n", sizeof(long));  //   размера в байтах, но только встроенных типов, но не кастомных
        // short, int long - как и в Си, они имеют 2, 4 и 8 байт       //   (разве что только в небезопасной манере)
        //   (и так же на 98% машин)                                   // Как и в Си, sizeof() здесь - это оператор. Это значит, что
                                                                       //   обрабатывается он ещё компилятором и размер типа известен с
                                                                       //   самого начала (во всяком случае, так это работало в Си)
                                                                       //
        unsafe                                                         //
        {                                                              //
            Console.WriteLine("And the size of Point is {0}", sizeof(Point));              // sizeof(Point) - теперь мы можем узнать
            //Console.WriteLine("And the size of PointClass is {0}", sizeof(PointClass));  //   размер нашей структуры (это 8 байт). VS
        }   // sizeof(PointClass) - а вот получить вес ссылочного типа уже никак не        //   подсказывает, что для безопасностив в
            //   получится                                                                 //   sizeof() как-то должен быть предопределён
            // Это были все чуть более сложные средства языка, некоторыми из них ты врядли //   размер твоей структуры
            //   вообще воспользуешься в реальных проектах (особенно указателями). Тем не  //
            //   менее, дальше ты увидишь, что некоторые из них действительно полезны (и   //
            //   даже обязательны) при работе с API-интерфейсами LINQ (в частности,        //
            //   расширяющие методы и анонимные типы                                       //


        // У структур Node и Node2 есть комментарии, где ты узнаешь о unsafe кое-что ещё


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   PointersANDUnsafe()");
    }
    class PointClass
    {
        public int x;
        public int y;
        public override string ToString() => $"({x}, {y})";
    }
    struct Point
    {
        public int x;
        public int y;
        public override string ToString() => $"({x}, {y})";
    }
    unsafe struct Node             // unsafe - эта пометка также должна быть у типов, что хранят небезопасные элементы
    {
        public int Value;
        public Node* Next;
    }
    struct Node2
    {
        public int Value;
        public unsafe Node* Next;  // unsafe Node* - ну, или отдельно у каждого из его небезопасных членов
    }
    static void LinqANDSystemLinqEnumerable()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   LinqANDSystemLinqEnumerable()\n");


        // Исторически сложилось так, что какждый источник данных (будь-то реляционная база, файл с текстом, коллекция в памяти или
        //   элементарный массив) имел свой непохожий на другие API-интерфейс. LINQ (language integrated query), появившийся в .NET 3.5,
        //   попытался дать своё решение - краткий, симметричный и строго типизированный интерфейс доступа ко всему. Он уже встроен в
        //   грамматику C#. Сначала может показаться, что LINQ выглядит и ведёт себя подобно SQL (который работает только с базами данных), но
        //   это не так. Лучше воспринимать запросы LINQ как уникальные операторы, местами очень похожие на запросы SQL (при этом выражение
        //   запроса LINQ строго типизировано, в отличии от операторов SQL). Когда LINQ был представлен, C# и VB уже были расширенны огромным
        //   количеством программных конструкций для набора технологий LINQ. В частности, C# использует эти связанные с LINQ средства:
        //   > неявнотипизированные локальные переменные     - var my = "hello"
        //   > синтаксис инициализации объектов и коллекций  - new List<object> { 234, new Point { X = 10, Y = 10 }, "hello" }
        //   > лямбда-выражения                              - (int i) => (i % 2) == 0
        //   > расширяющие методы                            - static char GetSecondChar(this string str) {..}
        //   > анонимные типы                                - new { Mask = false, Sort = "Saab", Color = "Red" }
        //   (фактически, ими подготавливали почву для LINQ)
        //
        // А вот и прямые API-интерфейсы для разных типов данных:
        //  > реляционные данные     - System.Data.dll, System.Data.SqlClient.dll и т.д.
        //  > данные документов XML  - System.Xml.dll
        //  > таблицы метаданных     - пространство имён System.Reflection
        //  > коллекции объектов     - класс System.Array и пространства имён System.Collections, System.Specialized, System.ObjectModel,
        //                             System.Collections.Generic
        //  Разумеется, с таким подходом к манипулированию данными не связано ничего плохого. Ты легко можешь (и будешь) работать напрямую с
        //  ADO.NET, пространствами имён XML, службами рефлексии и разнообразными типами коллекций, но основная проблема здесь в том, что
        //  каждый из их API-интерфейсов является своего рода "самостоятельным островком", трудно интегрируемым с другими. Конечно, можно
        //  (например) сохранить объект DataSet из ADO.NET в документ XML и затем работать с ним с помощью средств System.Xml, но теперь у тебя
        //  есть LINQ
        //
        // Применяя LINQ, можно создавать прям внутри языка конструкции, называемые выражениями запросов (они намеренно сделаны похожими внешне
        //   и по поведению на выражения SQL). Трюк здесь в том, что одни и те же выражения запросов можно применять к совершенно разным видам
        //   данных. В зависимости от того, где применяются запросы LINQ, ты можешь встретить разные обозначения вроде этих:
        //   > LINQ to Objects              - это действие по применению запросов к обычным массивам и коллекциям (т.е. инфа будет храниться в
        //                                    них)
        //   > LINQ to XML                  - это действие при использовании запросов для манипулирования с документами XML
        //   > LINQ to DataSet              - /////////after reading///////////////////////////////////////////////////////////////////////
        //                                    // когда ты применяешь запросы к объектам System.Data.DataSet из ADO.NET
        //                                    /////////////////////////////////////////////////////////////////////////////////////////////
        //   > LINQ to Entities             - этот аспект также отностися к ADO.NET, но теперь к Entity Framework (EF)
        //   > Parallel LINQ (он же PLINQ)  - этот аспект повзоляет вести параллельную обработку данных, возвращаемых из запроса LINQ
        // В Настоящий момент LINQ является неотъемлемой частью библиотек базовых классов .NET, управляемых языков и самой Visual Studio
        //
        // Если какой-нибудь непустой проект VS создан с использованием .NET выше версии 3.5, то все основные сборки LINQ уже привязаны к ниму.
        //   Вот они, кстати:
        //   > System.Core.dll                    - здесь определены типы, представляющие основной интерфейс LINQ (если ты собираешься работать
        //                                          с LINQ, эта сборка точно должна быть подключена)
        //   > System.Data.DataSetExtensions.dll  - здесь определён набор типов для интеграции ADO.NET с парадигмой LINQ (LINQ to DataSet)
        //   > System.Xml.Link.dll                - предоставляет функциональность для применения LINQ с документами XML (LINQ to XML)
        //  Для работы с LINQ to Objects ты должен обеспечить, чтобы было импортировано пространство имён System.Linq (по большей части лежащее
        //  в System.Core.dll). Если что-то связанное с LINQ идёт не так, то, скорее всего, ты просто забыл импортировать System.Linq


        // Расширяющие методы играют ключевую роль в API-интерфейсах LINQ. Там ровно всё построено именно на расширенях из static класса
        //   System.Linq.Enumerable


        // Если ты хочешь, чтобы LINQ to Objects мог применятся и с твоим контейнером, то позаботься о том, чтобы тот реализоваывал
        //   System.Collections.Generic.IEnumerable<T>. Реализации простого System.Collections.IEnumerable хватать не будет
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // (хотя на объекты этого интерфейса таки предусмотрены расширяющие методы Cast<T>() и
        //   // OfType<T> для получения из них System.Collections.Generic.IEnumerable<T>)
        //   /////////////////////////////////////////////////////////////////////////////////////////////


        string[] currentGames = new string[] { "Until Dawn", "Uncharted 2", "Fallout 3", "Dexter", "Oxygen Not Included" };
                                                                                                        // string[] - для начала попробуем
        IEnumerable<string> subset1 = from g in currentGames where g.Contains(' ') orderby g select g;  //   использовать LINQ с обычными
                                                                                                        //   массивами (это LINQ to
                                                                                                        //   Objects)
        foreach (string game in subset1)                                                                // from.. - этим выражением запроса
            Console.WriteLine("item is {0}", game);  // from, in, .. - формальнсоти синтаксиса будут    //   мы можем получить набор игр,
        Console.WriteLine();                         //   подробно разбираться чуть позже, но сейчас мы //   отсортированный по алфавиту,
        // На самом деле операторы LINQ работают     //   в состоянии прочесть это выражение так:       //   где каждая строка имеет пробел
        //   только с LINQ. Остальная часть языка их //   "предоставить мне элемента из currentGames,   // Сразу стоит сказать, что этими
        //   не поймёт (и VS просто не будет их      //   содержащие пробел, в алфавитном порядке". Как //   запросами на начинку исходного
        //   выделять синим цветом)                  //   говорит автор, каждый элемент нашего массива  //   контейнера (здесь это
        // Как говорит автор, вместо построения      //   получит имя g (это game, кстати)              //   currentGames) ты не повлияешь
        //   сложной логики с for и if/else,         // subset1 - возвращается нам некий тип,           //   (ведь это всё-таки запросы)
        //   временных типов и т.п., лучше создать   //   реализующий IEnumerable<string> (т.к. мы      // Конечно, этой цели можно было
        //   подходящий запрос LINQ, и оставить всю  //   посылаем массив объектов string)              //   добится и обычными средствами
        //   чёрную работу компилятору (а затем и    //                                                 //   (мы уже знаем static метод
        //   писишнику, ведь LINQ внутри состоит из  //                                                 //   System.Array.FindAll(), например)
        //   тех же for/while и if/else, но          //
        //   перефаршированных всякого рода          //
        //   проверками, что бурет на себя добротную //
        //   часть процессорного времени)            //


        // А вот и некоторые часто применяемые операции запросов:                                                                         
        //   >  from, in                - используется для определения основы выражения LINQ. Его ты уже видел
        //   >  where                   - применяется для задания условия для проверки на пригодность каждого элемента
        //   >  select                  - используется для выборки того, что войдёт в выходной результат (обязателено хоть один такой при
        //                                использовании операторов LINQ, но при использовании методов его можно опустить (так, там будут
        //                                браться сами объекты)
        //   >  join, on, equals, into  - выполняют соединения по указанному ключу. Помни, что на сами контейнеры они не влияют
        //   >  orderby, ascending,     - эта команды для сортировки
        //      descending
        //   >  group, by               - они могут выдать данные, сгруппированные по указанному значению (выдавая подобие only-set словаря)
        //   where и другие подобные дополнения должны быть между from/in и select
        //
        //   На самом деле эти понятные операторы - это всего-лишь прикрытие для расширяющих методов (использование которых напрямую ты
        //   увидишь ниже). Ты даже можешь поставить несколько одинаковых операций в свой запрос:
        //       .. where g.Contains(' ') orderby g orderby g where g.Contains('y') select g
        //
        // Этого можно было ожидать, но некоторые расширяющие методы статического класса System.Linq.Enumerable (о нём всё ещё ниже) не имеют
        //   аналогов в операциях запросов
        /////////after reading///////////////////////////////////////////////////////////////////////
        //   (это методы вроде Reverse<>(), ToArray<>(), ToList<>() и т.д.)
        /////////////////////////////////////////////////////////////////////////////////////////////
        //   . Какие-то из них применяются к определённому элементу набора, какие-то применяются к нескольким наборам
        /////////after reading///////////////////////////////////////////////////////////////////////
        //   (Distinct<>(), Union<>(), Intersect<>() и т.д.),
        /////////////////////////////////////////////////////////////////////////////////////////////
        //   а ещё одни просто агрегируют результаты
        /////////after reading///////////////////////////////////////////////////////////////////////
        //   (Count<>(), Sum<>(), Min<>(), и т.д.)
        /////////////////////////////////////////////////////////////////////////////////////////////


        IEnumerable<string> subset11 = currentGames.Where(g => g.Contains(' ')).OrderBy(g => g).Select(g => g);
                                                     // Where(), OrderBy(), Select() - существует ещё один синтаксис, использующий
        foreach (string game in subset11)            //   расширяющие методы. Им можно записать абсолютно все выражения запросов, что и с
            Console.WriteLine("item is {0}", game);  //   операторами LINQ (и дальше больше!)
        Console.WriteLine();                         // Заметь, в каждом расширяющем методе здесь используется по лямбда-выражению
                                                     // Каждый из этих расширяющих методов возвращает тот же
                                                     //   System.Collections.Generic.IEnumerable<string> (это, кстати, интерфейс), но уже с
                                                     //   изменённой начинкой. Т.е. мы просто построили мини конвейер (и это основная задумка
                                                     //   LINQ)
                                                     // Where() - этот метод фильтрует элементы по условию. Как говорит автор, на самом деле
                                                     //   этот метод возращает объект типа System.Linq.IOrderedEnumerable<T> (хоть мы этого и
                                                     //   не видим, получая просто System.Collections.Generic.IEnumerable<T>-совместимый тип)
                                                     // OrderBy() - этот сортирует полученный объект. Метод запрашивает функцию для вывода
                                                     //   ключевых внутренностей каждого объекта, по которым уже можно сортировать. Есть и 2-ая
                                                     //   версия метода, что принимает System.Collections.Generic.IComparer<T>, чтобы ты мог
                                                     //   задать более сложный вид сравнения
                                                     // Select() - этим методом мы можем указать, что именно мы хотим получить в
                                                     //   хранилище результата от текущего проверяемого объекта (здесь от каждого элементы мы
                                                     //   хотим получить .. сам элемент. Да, этот метод здесь фактически бесполезен)


        void DisplayQueryResultReflection(object result)
        {
            Console.WriteLine("result type is {0}", result.GetType());
            Console.WriteLine("result type location is {0}", result.GetType().Assembly.GetName().Name);
        }
        string[] currentGames1 = new string[] { "Until Dawn", "Uncharted 2", "Fallout 3", "Dexter", "Oxygen Not Included" };
        //
        IEnumerable<string> subset21 = from g in currentGames where g.Contains(' ') orderby g select g;
        IEnumerable<string> subset22 = currentGames.Where(g => g.Contains(' ')).OrderBy(g => g).Select(g => g);
        //                                       //
        DisplayQueryResultReflection(subset21);  // Display..(subset1) - при запуске видно, что subset1 в действительности
        Console.WriteLine();                     //   представляет тип System.Linq.OrderedEnumerable<TElement, TKey> (в коде CIL и в выводе
        DisplayQueryResultReflection(subset22);  //   это OrderedEnumerable`2). Это внутренний абстрактный тип в сборке System.Core.dll
        Console.WriteLine();                     // Display..(subset2) - а здесь выяснится, что subset2 - это экземпляр типа
        // VS - многие типы, представляющие      //   System.Linq.WhereSelectEnumerableIterator. Но если удалить из запроса конструкцию
        //   результат LINQ, скрыты в браузере   //   Select(), выйдет тот же тип, что и у subset1. Что всё это значит? Для подовляющего
        //   объектов. Эти низкоуровневые типы   //   большинства - ничего (кроме справки). Оба этих типа производны от
        //   не предназначены для прямого        //   System.Collections.Generic.IEnumerable<T>, проход по ним осуществляется одинаково и они
        //   использования                       //   оба могут перейти в список или массив


        int[] numbers = new int[] { 10, 20, 30, 40, 1, 2, 3, 8 };
        IEnumerable<int> subset30 = from n in numbers where n < 10 select n;  // subset - т.к. средства LINQ могут применятся к широкому
        foreach (int num in subset30)                                         //   спектору разнообразных типов, часто определить
            Console.WriteLine("item is {0}", num);                            //   подходящий тип для хранения результирующего набора не
        Console.WriteLine();                                                  //   так просто (а если этот тип генерируется компилятором,
                                                                              //   то и невозможно). subset30 здесь имеет совершенно другой
        DisplayQueryResultReflection(subset30);                               //   тип - System.Linq.WhereArrayIterator<T>
        Console.WriteLine();  // Запросы LINQ to Objects применимы к          // Автор, основываясь на своём эмперическом опыте, предлагает
        // Эти расширяющие    //   контейнерам, что реализуют IEnumerable<T>  //   при захвате результатов LINQ всегда использовать var.
        //   методы ты        //   . Тем не менее, класс System.Array не      //   (хоть в подавляющем большинстве случаев тип результата и
        //   можешь увидеть   //   поддерживает этот контракт:                //   будет реализовывать IEnumerable<>, но не всегда)
        //   с помощью точки  //       public abstract class Array :          //
        //   (interrupt       //       ICloneable, IList, ICollection,        //
        //   point'а)(**как?) //       IEnumerable, IStructuralComparable,    //
        //   и средства       //       IStructuralEquatable {..}              //
        //   IntelliSense     //   На самом деле класс получает нужную        //
                              //   функциональность посредством статических   //
                              //   расширяющих методов класса                 //
                              //   System.Linq.Enumerable (о нём ниже)(это    //
                              //   работает, потому что нигде здесь явно не   //
                              //   трубуется совместимость с IEnumerable<T>). //
                              //   В нём определено множество обобщённых      //
                              //   полезных методов                           //
                              /////////after reading////////////////////////////
                              //   (таких как Aggregate<T>(), First<T>(),     //
                              //   Max<T>() и т.д.)                           //
                              //////////////////////////////////////////////////
                              //   , которых получают в ряспоряжение          //
                              //   System.Array и многие другие типы          //


        // Статический класс System.Linq.Enumerable определяет в себе расширяющие методы. А ещё он предоставляет пачку других обычных
        //   статических методов, что помогут тебе при работе с Linq to Objects
        //
        var range1to10 = Enumerable.Range(0, 8);  // Range() - просто создаёт коллекцию с числами от start до count (не включительно)
                                                  //   (перегрузок 0)(такой же метод повсеместно использовался в Python)
                                                  // range1to10 - хранит в себе { 0, 1, 2, 3, 4, 5, 6, 7, 8 }


        // Ты можешь почитать о неудобстве использования LINQ запросов в структурах/классах в комментариях к LINQBasedFieldsAreClunky


        System.Collections.ArrayList someObjects = new System.Collections.ArrayList { 1, "two hundred", 3.5, 642, 444 };
        var onlyInts = someObjects.OfType<int>();               // OfType<..>() - этим ты можешь получить
        var bigInts = from n in onlyInts where n > 56 select n; //   System.Collections.Generic.IEnumerable<T> объект, что нужен в работе с
                                                                //   запросами LINQ


        var subset = from n in numbers where n < 10 select n;  // from.. - важная особенность запросов в том, что, фактически, они не
        foreach (var curr in subset)                           //   выполняются до тех пор, пока ты не воспользуешься значениями в
            Console.WriteLine("{0} < 10", curr);               //   полученном контейнере. Формально, это называется отложенным
        Console.WriteLine();                                   //   выполнением. Здесь это выражение впервые задействовалось при операторе
                                                               //   foreach
        numbers[0] = 4;                                        //
        foreach (var curr in subset)              // foreach - преимущество такого подхода в том, что один и тот же запрос может быть
            Console.WriteLine("{0} < 10", curr);  //   использован многократно (т.к. его контейнер будет обновлятся при каждом использовании).
        Console.WriteLine();                      //   Здесь мы изменили один элемент в начальном массиве, и при новом применении foreach
                                                  //   хранилище subset незаметно для нас обновилось
                                                  // VS - ради интереса, ты можешь поставить точку остановки в коде (нажав на поле, левее
                                                  //   отсчёта строк и то, что светлее). Наведя курсор на subset и нажав ПКМ, тебе
                                                  //   тебе откроется нужное меню (****меню для чего?)
                                                  //
        List<int> subsetList = (from n in numbers where n < 10 select n).ToList<int>();  // ..ToList<>() - если ты хочешь сразу работать
        // Скорее всего, при вовзрате результатов запросов ты будешь применять именно    //   с полученными данными в удобной манере,
        //   его, т.к. спецефичные для LINQ типы малопригодны для работы вне             //   можешь привести их к списку или массиву
        //                                                                               //   (это называется немедленным выполнением)
        //                                                                               // ..ToList<int>() - да, совсем необязательно было
        //                                                                               //   явно указывать int здесь
        //                                                                               //
        int[] subsetArr = (from n in numbers where n < 10 select n).ToArray();           // ..ToArray() - получаем массив с int'ами


        "rr".Distinct();  // "rr".Distinct<T>() - возвращает объект типа, совместимого с System.Collections.Generic.IEnumerable<T>, хранящий в
                          //   себе уникальные элементы


        "rr".Count();                     // "rr".Count<T>() - выдаст количество элементов в этом контейнере. Да, Count'ами также назывались
        "rr".Count(curr => curr == 'r');  //   свойства в некторых типах контейнеров
                                          // "rr".Count<T>(Func) - 2-ая (и последняя) версия этого метода возвращает количество элементов, что
                                          //   удовлетворяют условию (ты отправляешь функцию, что принимает элемент, а она отправляет либо true
                                          //   , либо false)
                                          //
        "rr".LongCount();                 // "rr".LongCount<T>() - то же самое, но выдаст long


        "rr".Select(c => char.IsLetter(c));  // "rr".Select<T,Y> - выдаст коллекцию с элементами, что выдал твой делегат, получая старые
                                             //   элементы


        "1f44.5".Where(c => char.IsDigit(c));
        // output: [ 1, 4, 4, 5 ]   // "..".Where<T>() - фильтрует элементы в своей коллекции по фильтру в делегате predicate (есть 1-а
        //                          //   перегрузка). Твой делегат, получает поочереди каждый элемент и должен возвратит либо true, либо false
        //
        "abcrrfg".Where((c, i) => c == 'a' + i);
        // output: a b c f g    // "..".Where<T>() - фильтрует элементы в своей коллекции по фильтру в делегате predicate (1-а перегрузка).
        //                      //   Твой делегат, что должен возвратить bool, вызвается на каждом элементе и получает 2-е вещи - сам элемент и
        //                      //   его индекс


        int[] arr = new int[] { 4, 0, 2, 6, 0, 9, 12, 0, 5, 5 }.OrderBy(delegate (int x) { return x == 0; }).ToArray();
        // int[] { .. }.OrderBy<T,Y>() - этот метод отсортирует коллекцию по заданному условию. Метод сравнивает (с помощью object.Equals())
        //   результаты вывода твоего делегата от каждого int и по ним строит новую коллекцию. Здесь я отправил делегат, что возвращает true,
        //   если элемент окажется 0-ём. Т.к. true больше false, 0-ли окажутся в конце выходной коллекции
        //
        int[] arr1 = new int[] { 4, 0, 2, 6, 0, 9, 12, 0, 5, 5 }.OrderByDescending(delegate (int x) { return x == 0; }).ToArray();
        // int[] { .. }.OrderByDescending<T,Y>() - а этот метод соритирует в обратном порядке
        var sortedSubset = from p in new int[] { 4, 0, 2, 6, 0, 9, 12, 0, 5, 5 } orderby p select p;
        // orderby (как и подобное)  // orderby - а так это делается с помощью операций
        //   должно находится где-то //   По умолчанию сортировка идёт по возрастанию, но ты можешь изменить это,
        //   между from/in и select  //   добавив сюда операцию descending:    orderby .. descending
        // А ascending и descending  //   . Для явной сортировки по возрастанию используй ascending
        //   сразу после orderby ..  //


        "rrRr".GroupBy(c => char.IsUpper(c));               // "rrRr".GroupBy<T,Y>() - этот расширяющий метод выдаёт тебе некий контейнер, тип
        // output: что-то вроде словаря                     //   элементов которого сомвестим с интерфейсом System.Linq.IGrouping<T,Y>, по
        //       { true:  { 'R' },                          //   факту представляющего половину интерфейса словоря - он даёт свойство Key, т.е.
        //         false: { 'r', 'r', 'r' } }               //   возможность получить объект ключа (да, само значение получается как-то иначе).
        //                                                  //   В сам GroupBy() этой версии ты должен послать делегат, что должен по очереди
        //                                                  //   получать элементы коллекции, а затем возвращать подходящий ключ для каждого из
        //                                                  //   них
        //
        "rrRr".GroupBy(c => char.IsUpper(c), c => (int)c);  // "rrRr".GroupBy(


        "rrrrFFFF".Skip(4);                   // "rrrrFFFF".Skip<T>() - пропускает столько-то первых элементов, оставляя на выходе коллекцию
        // output: { 'F', 'F', 'F', 'F' }     //   без них
        "rrrrFFFF".SkipWhile(c => c == 'r');  // "rrrrFFFF".SkipWhile<T>() - тут также просто - ты пропускаешь те первые элементы, на которых
                                              //   отправленный делегат возвращает true (есть перегрузка, в которой делегат будет получать
                                              //   не только сам элемент, но ещё и его id)


        //****"rrr".ToLookup()


        List<string> myCars = new List<string> { "Yugo", "Aztec", "BMW" };
        List<string> yourCars = new List<string> { "BMW", "Saab", "Aztec" };
        //                                                    //
        var carDiff = (from c in myCars select c).Except(from c in yourCars select c);
        Console.WriteLine("Cars you don't have, but I do:");  // Как уже говорилосЬ, в классе Enumerable от LINQ определено достаточно
        foreach (string curr in carDiff)                      //   много различных методов для работы с несколькими наборами
            Console.WriteLine("\t{0}", curr);                 // (from..)Except<T>() - конкретно этот может находить их разность (ещё, можно
        Console.WriteLine();  // from.. - да, здесь проще     //   сказать, он исключает из элементы левого контейнера элементы правого)
                              //   использовать объекты       // На самом деле местные методы для нескольких контейнеров сделаны так, чтобы
                              //   напрямую, но ведь здесь мы //   вести себя как описывал Джон Венн для всякого рода множеств
                              //   хотим использовать именно  //
                              //   синтаксис LINQ, верно?     //


        var carIntersect = (from c in myCars select c).Intersect(from c in yourCars select c);
        Console.WriteLine("Here are cars we have in common:");  // (from..).Intersect<T>() - а этот метод сделан для возвращения общих
        foreach (string curr in carIntersect)                   //   элементов для двух наборов
            Console.WriteLine("\t{0}", curr);
        Console.WriteLine();


        var carUnion = (from c in myCars select c).Union(from c in yourCars select c);
        Console.WriteLine("Here are each car marks we have:");  // (from..).Union<T>() - этот метод берёт и складывает элементы из обоих
        foreach (string curr in carUnion)                       //   контейнеров, но без повторов
            Console.WriteLine("\t{0}", curr);
        Console.WriteLine();


        var carConcat = (from c in myCars select c).Concat(from c in yourCars select c);
        Console.WriteLine("Here are the cars we actually have:");  // (from..)Concat<T>() - этот метод просто склеивает два контейнера в один
        foreach (string curr in carConcat)
            Console.WriteLine("\t{0}", curr);
        Console.WriteLine();


        double[] winterTemps = { 2.0, -21.3, 8, -4, 0, 8.2 };

        Console.WriteLine("Max temp is {0}", winterTemps.Max());            // LINQ также предоставляет немного методов для агрегирования
        Console.WriteLine("Min temp is {0}", winterTemps.Min());            //   контейнеров (т.е. эти методы затронут все элементы в
        Console.WriteLine("Average temp is {0}", winterTemps.Average());    //   их хранилищах)
        Console.WriteLine("Sum of all temps is {0}\n", winterTemps.Sum());  // winterTemps.Max<T>() - этот расширяющий метод может выдать
                                                                            //   наибольший элемент в контейнере
                                                                            // winterTemps.Min<T>() - этот - наименьший. Как и Max<T>(),
        // Многие эти методы прототипированы для принятия делегата Func<>   //   перегружен для получения специальной функции, по которой он и
        //   (разных его версий) для дополнительной трансформации объектов, //   будет сравнивать
        //   если это надо                                                  // winterTemps.Average<T>() - этот метод вычисляет среднее (тоже
                                                                            //   перегружен для получения функции, чьи выводы и будут
                                                                            //   учавствовать)
                                                                            // winterTemps.Sum<T>() - а этот метод просто элементы (тоже
                                                                            //   перегружен)


        //****одна странность связана с расширяющими методами этими. Параллельно, видимо, они выполняются. Вот этот код странно ведёт себя:
        //
        //        int zeroCount = 0;
        //        var _  = new int[] { 235, 253, 4, 4, 0, 4, 0, 4, 0 }.Where(delegate (int n)
        //            {
        //                System.Console.WriteLine(".");
        //                if (n != 0)
        //                    return true;
        //                else
        //                {
        //                    zeroCount++;
        //                    return false;
        //                }
        //            }).Select(delegate (int n)
        //            {
        //                Console.WriteLine("count: {0}", zeroCount);
        //                return n;
        //            });
        //        Console.WriteLine("_.Length: {0}", _.Count());
        //
        //    Точка выводится по очереди с count: .. . Не должно быть так. Ещё есть странность похожая. На этот код погляди:
        //        int zeroCount = 0;
        //        return nums.Where(delegate (int n)
        //            {
        //                if (n != 0)
        //                    return true;
        //                else
        //                {
        //                    zeroCount++;
        //                    return false;
        //                }
        //            }).Concat(new int[zeroCount]).ToArray();
        //    new int[zeroCount] здесь раньше вызывается, всегда нулевой массив создаётся (не смотря на nums)
        //    Возможно система вызовов по CIL коду виновата. В Си с конца всё это вызывалось


        //****ещё одна странность - расширяющие методы почему-то не действуют


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   LinqANDSystemLinqEnumerable()");
    }
    class LINQBasedFieldsAreClunky
    {
        private static string[] currentGames = { "Factorio", "Uncharted 2", "Fallout 3", "Dexter", "Oxygen Not Included" };
        private IEnumerable<string> subset = from g in currentGames where g.Contains(' ') select g;
        public void DisplayGames()                       // IEnumerable<> - для запросов LINQ в классах устоялись весьма неблагоприятные
        {                                                //   условия: мало того, что var не работает с полями, так ещё и целевой контейнер
            foreach (var curr in subset)                 //   должен быть не привязан к объектам (****это значит, что объект должен хранить
                Console.WriteLine("item is {0}", curr);  //   в себе коллекцию с объектами, о которых станет известно позже?). С учётом
            Console.WriteLine();                         //   этого необходимость написания такого кода возникает довольно редко
        }
    }
}