/*
 * creation date  12 dec 2020
 * last change    12 oct 2021
 * author         artur
 */
using System;

class ClassDesigner_ErrorList_SystemConsole
{
    static void Main()
    {
        Console.WriteLine("***** SystemDayOfWeek *****");

        ClassDesigner_Silent();
        ErrorList();
        SystemConsole();

        Console.ReadLine();
    }
    static void ClassDesigner_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   ClassDesigner_Silent()\n");


        // Среди средств VS есть одна очень интереснаящ штука - Class Designer. С помощью неё ты можешь слепить класс мышкой! Код в методах, ты
        //   конечно этим не получишь, но это может помочь для общего осмотра кода. Ещё эта утилита способна изменять отношения между типами в
        //   проекте. В производственных условиях её использует 2.5-ть человека (во всей индустрии), т.к. многие о ней и не знают, а те, что
        //   знают, просто забыли про сие изобритение
        // Поставляется эта утилита в виде индивидуального компонента (поэтому тебе скорее всего придётся использовать Visual Studio Installer
        //   и протыкать Installed -> Visual Studio .. -> Modify -> Individual Components -> Code Tools -> Class Designer и нажать на Modify)
        // В VS Class Designer представлен в виде возможности создать диаграмму классов (Project -> Add New Item... -> Installed ->
        //   -> Visual C# Items -> General -> Class Diagram). При добавлении таковой в проекте появится пустой файл .cd, но ты можешь
        //   перетащить на поверхность диаграммы файлы из Solution Explorer
        // Щёлкнув на значке стрелки нужного типа, ты раскроешь список его членов
        // При использовании Class Designer часть панели инструментов VS заменяется кнопками, специфичными для этой утилиты (вообще, панель
        //   инструментов делится на 2-е части - обще-VS-овскую и специфичную под текущее окно. Эти части делятся широкой точечной линией)
        // Диаграммы классов всегда показывают текущее положение дел в твоём проекте, и сами мгновенно обновляют код при изменении в них

        // Утилита Class Designer работает в сочетании с двумя другими сердствами VS - окном Class Details (появляется в View -> Other Windows,
        //   если активное окно - это окно диаграммы ) и средством ToolBox (автор называет это панелью инструментов Class Designer)(в левом
        //   краю окна VS есть кнопка с ним. Ещё можно пройти по View -> ToolBox. Оно применяется к текущему активному окну, поэтому у тебя
        //   должна быть открыта диаграмма). Окно Class Detials не только показывает сведения обо всех членах выбранного класса, но также
        //   позволяет модифицировать их и вставлять новые (правда, всё это не заходит дальше определения прототипа). Окно ToolBox полезно тем,
        //   что из него можно перетаскивать нужне тебе элементы прямо на плоскость диаграммы, создав этим новый тип
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   //   (в ToolBox также есть такой элемент, как Inheritance, позволяющий строить иерархию наследования классов)
        //   /////////////////////////////////////////////////////////////////////////////////////////////


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   ClassDesigner_Silent()");
    }
    static void ErrorList()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   ErrorList()\n");


        // Это окно, куда VS выводит найденные ошибки в коде. Также туда попадают warning'и (т.е. сомнительные команды) и другая
        //   диагностическая информация


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   ErrorList()");
    }
    static void SystemConsole()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   SystemConsole()\n");


        // Статическией запечатанный класс System.Console (как нетрудно догадаться) представляет из себя консоль программы (а консоль, в свою
        //   очередь, - это ввод/вывод текста, а также стандартный поток для вывода ошибок)


        // Вот несколько интересных членов класса System.Console

        Console.Title = "musya";                         // Title - имя программы (типа string)

        Console.Beep();                                  // Beep() - бип консоли. Перегружен в две функции: Beep() (стандартный бип) и
                                                         //   Beep(int, int) (для задания частоты и длительности в мс)

        Console.BackgroundColor = ConsoleColor.White;    // BackgroundColor - цвет фона консоли (типа перечисления System.ConsoleColor, что
        Console.ForegroundColor = ConsoleColor.Green;    //   хранит цвета специально для System.Console)
                                                         // ForegroundColor - цвет переднего плана (т.е. символов)

        Console.WindowHeight = 21;                       // WindowHeight - высота окна консоли. Как и другие родственные параметры, считается в
        Console.WindowWidth = 53;                        //   символах (типа int)
        Console.WindowTop = 1;                           // WindowWidth - этим задаётся ширина
        Console.WindowLeft = 1;                          // WindowTop - с какой строки начинать выводить в окне
                                                         // WindowLeft - с какого символа начинать вводить (фактически, этим свойствами задётся
                                                         //   размер сдвига от краёв в окне)

        Console.ReadLine();                              // ReadLine() - этот метод читает строку из стандартного входного потоко и выдаёт её
                                                         //   тебе (в виде string)

        Console.BufferHeight = 25;                       // BufferWidth - размер вместимости в символах. Всегда должен быть больше, чем может
        Console.BufferWidth = 56;                        //   показать окно

        Console.Write("---|\n---|\n");                   // "---|\n.." - это продемонстрирует интересную особенность cmd - фон изменится только
        Console.WriteLine("---height: {0}, width: {1}",  //   там, где обновляется часть поля, а она обновляется там, где что-то пишется (или
                                                         //   ещё можно мышкой изменить размер окна cmd. Это обновит всё поле)
                Console.WindowHeight, Console.WindowWidth);
        Console.Read();                                  // Write() - этот метод выпустит строку в стандартный выходной поток. Имеет ещё 17
        Console.Read();                                  //   перегрузок для разных нужд. Многие перегрузки принимают тип object (т.е. они
                                                         //   способны принять вообще что угодно), и в этом случае в консоль будет выводиться
                                                         //   результат их метода ToString(). Благодаря магии наследования, ты можешь отправить
                                                         //   в эти методы любой объект, и оно будет работать)
                                                         // WriteLine() - делает то же, что метода Wirte() плюс добавит символ новой строки.
                                                         //   Имеет на одну перегрузку больше (18 перегрузок). В VS есть сниппет cw, что
                                                         //   рисует тебе команду    Console.WriteLine();    в текущей строке и перемещает
                                                         //   курсор в скобки
                                                         // Read() - в отличии от ReadLine(), умеет считывать только один символ. Почему тут
                                                         //   2-а вызова? А из-за того, что в винде новая строка - это два символа: "\r\n" (на
                                                         //   сколько я помню, ещё со времён MS-DOS)(а не стандартное Unix'овское '\n')

        Console.ReadKey();                               // ReadKey() - считывает и возвращает нажатый символ на клавиатуре. Метод не
                                                         //   завершится, пока клавиша не будет нажата
        Console.ReadKey(true);                           // ReadKey(..) - вторая версия этого метода принимает bool, указывающий, надо ли
                                                         //   выводить нажатый символ на экране (по умолчанию все Read-методы разрешают
                                                         //   консоли делать это)

        Console.Clear();                                 // Clear() - стандартная чистка экрана. cmd в винде просто опускается вниз (также, как
        Console.WriteLine("---musya");                   //  в консоли Unix'ов), а затем удаляет предыдущие записи (в Unix'ах они сохраняются).
        Console.ReadLine();                              //  Это поведение, кстати, обновляет весь фон у нас

        Console.ResetColor();                            // ResetColor() - этот метод сбросит цвета в консоли. Возвращает void
        Console.Clear();



        Console.Write("Please enter your name: ");
        string userName = Console.ReadLine();
        Console.Write("And enter your age: ");
        string userAge = Console.ReadLine();

        ConsoleColor defColor = Console.ForegroundColor;
        Console.ForegroundColor = ConsoleColor.Yellow;

        Console.WriteLine("Hello {0}! You are {1} years old", userName, userAge);

        Console.ForegroundColor = defColor;  // defColor - вовращаем всё как было, иначе же в cmd так и останется жёлтый шрифт. Так бы делали
                                             //   все, если бы не создали метод Console.ResetColor()
        Console.ReadLine();


        // А вот как происходит принятое в C# форматирование
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // (метод для форматирования есть в самой структуре string. System.Console.WriteLine() лишь повторяет поведение этого метода)
        //   /////////////////////////////////////////////////////////////////////////////////////////////

        Console.WriteLine("{2}, Number {0}, Number {0}\n", 9, -5, 1);
        Console.WriteLine("The value 9999 in various formats:");
        Console.WriteLine("    c format:  {0:c}", 9999);    // c - для представления денег. По умолчанию используется знак локальной валюты
        Console.WriteLine("    d9 format: {0:d9}", 99999);  //   (для US это $)
        Console.WriteLine("    f3 format: {0:f3}", 9999);   // d - для десятичных чисел. Эта буква была и в printf() в Си. Число здесь задаёт
        Console.WriteLine("    n format:  {0:n}", 9999);    //   минимальное кол-во цифр в выводе
        Console.WriteLine("    g format:  {0:g}\n", 9999);  // f - для вещественных чисел. Число здесь означает минимальное кол-во цифр после
                                                            //  запятой в выводе. Также было в printf() из Си
        Console.WriteLine("    E format:  {0:E9}", 9999);   // n - для чисел в общем. Число задаёт минимальное кол-во цифр после запятой в
        Console.WriteLine("    e format:  {0:e}", 9999);    //   выводе
        Console.WriteLine("    X format:  {0:X}", 9999);    // g - автор говорит, что это может использоваться и как E, и для вывода
        Console.WriteLine("    x format:  {0:x9}", 9999);   //   вещественных чисел, но записи E я таки не видел. Именно g используется в
                                                            //   форматировании по умолчанию
                                                            // E или e - воводит число в экспоненциальной форме. От регистра зависит регистр
                                                            //   символа e в выводе. Число задаёт минимальное кол-во символов в выводе
                                                            // X или x - для записи в 0x формате (16-ричная запись). При записи X представление
                                                            //   будет тоже использовать символы верхнего регистра. Число задаёт минимальное
                                                            //   кол-во символов в выводе (это цифры и символы)
                                                            

        // Некоторые редко вспоминаемые управляемые последовательности:
        //
        //   > \a - издать звук
        //   > \' - символ одинарной кавычки
        //   > \n - символ новой строки
        //   > \t - таб
        //   > \r - возврат картеки
        //
        //   В общем, всё как в Си


        // Если не использовать Console.ReadLine() в конце - программа завершится мгновенно, также мгновенно закрыв консоль


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   SystemConsole()");
    }
}