/*
 * creation date  28 oct 2021
 * last change    28 oct 2021
 * author         artur
 */
using System;
using System.Threading;
using System.Threading.Tasks;

class __AsyncAwait
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        AsyncAwaitANDStuff_Silent();

        Console.ReadLine();
    }
    static void AsyncAwaitANDStuff_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   AsyncAwaitANDStuff_Silent()\n");


        // WhatItIs
        //
        //   На самом деле (как говорит автор) многое в этой (довольно длинной, кстати) части энциклопедии было представленно в сжатом ввиде.
        //     Хотя использование делегатов, TPL и PLINQ нередко значительно упрощают жинзь программистам, они всё-таки должны знать детали
        //     различных расширенных приёмов
        //   .NET 4.5 привнёс в C# (и ещё в VB) два новых ключевых слова: async и await. И да, они дополнительно упращают процесс написания
        //     асинхронного кода. По правде говоря, они (как и lock) просто переводятся компилятором в цепочку команд (довольно
        //     большую), связанных с потоками. Там применяются многочисленные вызовы членов из System.Threading и System.Threading.Tasks
        //


        // Using
        //
        //   На деле async - это приставка к объявлению метода, и оно ставится перед возвращающим типом. Сам по себе async не
        //     делает метод асинхронным (да, это так). Это просто указание компиялтору, что скорее всего в методе будет применено ключевое
        //     слово await
        //   async может ставиться в объявлении только перед возвращаемым типом Task, Task<>, IAsyncEnumerable<> или IAsyncEnumerator<>
        //     (VS не даст тебе забыть о этой части)
        //   Ещё async применим ко всякого рода наслойкам на методы (вроде делегатов, анонимных методов, лямбда-выражений и локальных
        //     функций)
        //   Основной же интерес представляет ключевое слово await. Суть такова: ты запускаешь async метод, он выполняется как обычный (т.е.
        //     тем же потоком), как только встречается вызов метода с await впереди (типа    await DoItAsync();    ), то, по задумке,
        //     начинается асинхронщина (но её начинает не
        //     await). await может применятся только с методом, что возвращает Task (или Task<>), и именно этот метод должен обеспечить
        //     создание нового потока (но, как ты понял, этого может и не происходить)
        //   В качестве await метода обычно применяют ..Task.Run() (т.к. он заточен под это дело). Я не знаю как, но вызов ..Task.Run()
        //     сбрасывает текущий поток (что запустил async-метод) обратно вниз, после чего тот продолжает выполнять код, что находится за
        //     async-методом (****скорее всего применялась yield-инструкция). Перед тем, как вылететь, поток успевает создать нового работника
        //     в ...Task.Run(), что и запускает делегат, посланный в ...Task.Run().
        //     После выполнения этого задания второстепенный поток продолжает выполнять код за await-методом. Он
        //     может встретить дальше новые await-вызовы с ..Task.Run(), но это уже не заставляет его создавать новый поток, и он сам
        //     выполняет второй await-вызов, затем снова продолжив код в async-методе (на самом деле вызов вотрого await ..Task.Run() может
        //     привести к созданию уже 3-его потока. Всё зависит от настроения пула потоков)
        //
        //
        //System.Collections.Generic.List<int> l = default;  // default - как говорит автор, для того, чтобы всё заработало, проект должен
                                                             //   конфигурироваться под C# 7.1. На вермя написания книги (~2017 год) VS не
                                                             //   считала это изменение нужным, поэтому автор (уже Филипп Джепикс) применил в
                                                             //   коде эту приманку для подсказки (VS должна спросить тебя о переводе проекта
                                                             //   на C# 7.1, но в моём времени эта версия стоит по умолчанию)
        //
          async Task<string> DoWorkAsync()              // async - мы даём понять компилятору, что эта локальная фукнция может
          {                                             //   рассинхрониться с текущим потоком (он выдаст предупреждение, если await'а
                                                        //   внутри таки не нашлось)
                                                        // Task<string> - страшный зверь, скрытый под капотом этих ключевых слов, даёт о себе
                                                        //   знать. Мы действительно возвращаем Task<string>. Вообще, объекты типа Task (и
                                                        //   Task<>) - это представители асинхронных операций (методов), что возвращают
                                                        //   значения (т.е. не void. Для void методов незачем создавать Task-объект, ведь
                                                        //   такой метод просто тихо завершится, никому ничего не оставив)
              Console.WriteLine("We are running it!");  // ..WriteLine() - эту команду выполнит старый поток, ведь здесь нет await (и быть не
              return await Task.Run(() =>               //   может, ведь метод - не async)
                  {                                     // await Task.Run() - здесь мы и разделим ход нашей реки. Текущий поток продолжит
                      Thread.Sleep(5_000);              //   выполнять команды, что находятся после вызова DoWorkAsync()
                      return "He have done work!";      // System.Threading.Tasks.Task.Run() - этот static (и async) метод запустит делегат
                  });                                   //   в новом потоке. Судя по описанию, он просто просто воспользуется пулом потоков.
          }                                             //   На деле, в нём создастся аж 2-а новых потока: 1-н для продолжения
                                                        //   Почти что сразу он возвратит нам объект Task<>
        //
          Console.WriteLine("We are starting it");
          Console.WriteLine(DoWorkAsync().Result);   // ..WriteLine(DoWorkAsync()) - из объекта Task<> можно получить результат асинхронной
          Console.WriteLine("We are again here\n");  //   операции, (через свойство Result). Метод ToString() переопределён на вызов
                                                     //   ToString() из результата
                                                     // ..Result - если результат ещё не готов, потоку придётся подождать его (посмотреть
                                                     //   готовность можно через свойство Status, что хранит значение перечисления
                                                     //   System.Threading.Tasks.TaskStatus
        //
        //
        //   Следует отметить, что async методы не могут иметь параметры с модификаторами out и ref
        //   В .NET есть соглашение - асинхронные посредством async методы имеют в своём имени суффикс Async.
        //
        //           В основном это члены классов для работы с файлами, сетью и базами данных
        //           Обработчики события элементов управления GUI, вроде события Click кнопки, не
        //             ледуют этому соглашения, хотя в них применяются async и await
        //
        //     Как видишь, мы его тоже выполнили
        //
        //   В подсказках методов, что имеют await в своём блоке, VS добавляет надпись    (awaitable)
        //   Некоторые смотрят на async и await как на основной инструмент многопоточного проектирования в C#
        //   Джепикс в книге пишет неправду, и код его неправильный (****скорее всего так сильно налажали переводчики)
        //
        //   Ну и ещё кое-что. В случае нужности параллельщины, на данный момент везде применяется именно Класс Task (а точнее его метод
        //     Run()), ведь в нём уже всё продумано. Как говорилось в начале раздела, TPL очень прост в использовании, но не гибок
        //
        //


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   AsyncAwaitANDStuff_Silent()");
    }
}