/*
 * creation date  18 dec 2020
 * last change    22 aug 2021
 * author  artur
 */
using System;

class NETAndBCL_COM_CLI_CLRAndJIT_TypeAndCTS_CLS
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        NETAndBCL_Silent();
        COM_Silent();
        CLI_Silent();
        CLRAndJIT_Silent();
        TypeAndCTS_Silent();
        CLS_Silent();

        Console.WriteLine();
    }
    static void NETAndBCL_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   NETAndBCL_Silent()\n");


        // Платформа .NET Framework увидел свет в 2002, и (как говорит автор) она быстро стала главной опорой индустрии разработки ПО (ведь
        //   появилась в противовес Java, успевшему занять большой кусок разработчиского рынка). C#, кстати,
        //   разрабатывался параллельно с .NET и сильно связан с ним (сразу скажу, что это не .NET писался для C#, а C# для .NET). По факту,
        //   эта платформа - гигантская структурированная библиотека, что покрывает 95% нужд при написании любого ПО. В ней числятся такие
        //   API-интерфейсы, как ADO.NET и Entity Framework (EF) - для баз данных, Windows Forms и Windows PresentationFoundation (WPF) - для
        //   постройки GUI (Graphical User Interface, если что), ASP.NET MVC - для веб-служб и сайтиков, WCF (Windows Communication Foundation)
        //   - для обмена данными между .NET приложениями
        // Вместе эти составные части .NET Framework'а зовутся BCL (base class library)
        //
        // На самом деле до июня 2016 кода .NET не был кросс-платформенным вовсе. Выход NET Core в июне 2016 года, что представляет
        //   кросс-платформенную (Windows/Linux/macOS) версию .NET (очень небольшую. В ней есть только всё самое необходимое), создал
        //   достаточно много шумихи вокруг себя. На данный момент все силы развития .NET направленны именно на увеличение .NET Core
        // Для ясности: .NET Core - это не часть .NET Framework, это его будущая замена. Microsoft'цы усердно стараются пробить себе место в
        //   богатейшем мире серверов, на которых с вероятностью 98% стоит какой-нибудь *nix (мы все знаем, где сейчас Windows Server). И таки
        //   в ноябре 2020-го Microsoft выкатили .NET 5, продолжение .NET Core'а, оффициально заменив им .NET Framework (что остановил
        //   развитие на версии v4.8). замена произошла неполная, графическая часть .NET Framework'а таки ещё не стала cross-platform'енной на
        //   тот момент. Но таки скоро оффициально станет. Java'исты жмутся, а мы запасаемся попкорном
        //
        // Дальше по тексту под .NET я буду подразумевать вообще всю экосистему (.NET Core, и .NET Framework, они в общем и целом по структуре
        //   похожи, хоть и несовместимы)

        // .NET - это не один сверхтяжёлый .dll, это множество мелких (или среднего размера) .dll-ешек
        /////////after reading///////////////////////////////////////////////////////////////////////
        //   Говоря иначе, это общеязыковая исполняющая среда common language runtime (CLR) +
        //   библиотека классов framework class library (FCL) (оно же BCL)
        /////////////////////////////////////////////////////////////////////////////////////////////

        // На самом деле, .NET - весьма удобная вещь, т.к. в нём принят ряд соглашений, что распространяется абсолютно на все его части. Вид и
        //   структура в ASP.NET та же, что и в WPF, поэтому не придётся привыкать к новым выдумкам и фокусам. Если ты раньше использовал
        //   сторонние библиотеки для разных частей своего приложения, то, значит, прекрасно понимаешь какого это - быть мостиком между
        //   образами мышления разных команд разработчиков

        // Природа .NET независима от языка и оси (что очень нравится всем, у каждого свой вкус). Ты можешь посмотреть на все .NET языки в
        //   педевикии (они помечены как CLI языки). Половина из них никому не нужна, а четверть используется 2.5-ой человеками. Нормально себя
        //   чуствует лишь остальная часть, но когда говорят о .NET - чуть менее, чем всегда имеют ввиду C#. Код библиотеки, написанной на
        //   каком-нибудь F#, по большей части будет совместим с C# кодом (ты пишешь код на F#, компилируешь его в некий промежуточный язык -
        //   некий CIL. Этот код на промежуточном языке ты затем сможешь использовать в коде C#). Да, ни один .NET язык не поддерживает все
        //   возмножнсти .NET полностью (разве этот промежуточный язык, который очень напоминает ассемблер)
        // Для каждого из этих языков есть свой компилятор (что переводит их код в .NET-овский CIL)
        // Иногда солянка из языков в проекте только способствует его разработке, ведь можно грамотно распределить языки по частям проекта.
        //   Одни языки имеют прекрасную поддержку для реализации сложных математический задач (Fortran всё-ещё жив), другие приспособлены к
        //   финансовым или логическим вычеслениям (COBOL), взаимодействиям с мейнфреймами (Lisp)
        // Изначатльно Visual Studio (VS) предлагает 5-ть .NET языков - C#, Visual Basic (VB), C++/CLI, JavaScript и F# (F# хоть и расщитан на
        //   функциональное программирование, но всё-же поддерживает ООП, ведь без этого в .NET никак. BCL - это по большей части классы)
        // Ну и ещё - освоив один язык .NET, легко изучить другой, ведь весь костяк приложений находится именно в BCL, а синтаксис - только
        //   инструмент для использования типов оттуда

        /////////after reading///////////////////////////////////////////////////////////////////////
        // BCL полностью входит в границы CLS. А ещё она часто инкапсулирует всякого рода ненужные тебе детали (вроде многопоточности,
        //   использования файлового ввода-вывода, системы для работы со внешними устройствами)
        /////////////////////////////////////////////////////////////////////////////////////////////

        // Безопасность - неотъемлемая часть .NET (здесь имеется ввиду безопасностью в плане данных. В плане недоступности кода - увы, .NET
        //   приложения всегда опенсорсны, и каждый может проглядывать твой код вплоть до имён переменных)
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // ildasm.exe выскажет любому абсолютно всё о твоём коде, и даже то, что ты сам не знаешь
        //   /////////////////////////////////////////////////////////////////////////////////////////////

        // Полная документация по .NET находится по адресу https://docs.microsoft.com/en-us/dotnet/. Нельзя стать могучим .NET-овцем, ниразу не
        //   взглянув на эти страницы. Непременно выдели время на освоение работы с этой справочной системой - они окупятся сторицей (слова
        //   Троелсена, и с ними трудно не согласится)
        // Эта документация известна как msdn (Microsoft Document Network) и существовала аж с 1992-го. Начиная с января 2020, msdn полностью
        //   перешёл в состав Microsoft Docs (эта штука была создана в 2016-ом, и изначально содержала доки только к .NET Framework)
        // На данный момент там наклёпан ряд мини-туториалов, что не может не радовать. Читаются они легко, поэтому это может стать весьма
        //   занимательным досугом


        // Во время чтения ты можешь задаться вопросом: "Почему даже такие мелочи, как дни недели, уже определены в .NET?". А я отвечу: "А
        //   потому что здесь не принято строить велосипеды". Лучше пусть будет стандартизированный для всех тип, ведь это убережёт от многих
        //   проблем в будущем
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Перечисление со днями недели - System.DaysOfWeek
        //   /////////////////////////////////////////////////////////////////////////////////////////////


        /////////after reading///////////////////////////////////////////////////////////////////////
        // System.Runtime.Serialization.Formatters.Binary.BinaryFormatter - одно из самых длинных имён в .NET
        /////////////////////////////////////////////////////////////////////////////////////////////


        // На сегодняшний день (2017 год), помимо дистрибутива .NET Framework от Microsoft, существуют ещё 3-и крупные реализации. Вот они:
        //
        //   > Проект Mono  - это open source'ный дистрибутив
        //                    /////////after reading///////////////////////////////////////////////////////////////////////
        //                    // (дистрибутив CLI)
        //                    /////////////////////////////////////////////////////////////////////////////////////////////
        //                    с открытым исходным, что позволяет писать аж целый UI (графический, веб и в консоли) на C# (только под него есть
        //                    компилятор) для ещё большего количества платформ (Windows/macOS/Linux/ IBM AIX/IBM i)(Выкуплен Microsoft с
        //                    потрохами в 2016). Создатель - Miguel de Icaza
        //   > Xamarin SDK  - проект Xamarin был основам в 2011 году людьми, что создавали Mono. Из себя он представляет его расширенную версию
        //                    (работает поверх Mono) для запуска твоих поделий под мобилки (Android/iOS). Проект выкуплен Microsoft в 2016
        //                    (собственно, Microsoft через Xamarin получила и Mono в подарок) и начала поставлять комплект Xamarin SDK в
        //                    составе VS начиная с 2017-го (а владельцы VS 2017 Enterprise получали также Xamarin Enterprise в своё имение)
        //
        //                    У Xamarin есть даже собственна интегрированная среда - Xamarin IDE, умеющая читать VS'овские проекты
        //   > .NET Core    - а это уже официальный межплатформенный дистрибутив .NET Framework от Microsoft (вышел в том же 2016-ом).
        //                    Поддерживает C#, VB (частично) и F#. .NET Core 3.0 (сентябрь 2019-го) уже почти полностью догнал
        //                    .NET Frawework 4.8 по функциональности, а следующая его версия официально получила название .NET 5.0, став единой
        //                    платформой для .NET, заменяя Mono и .NET Framework. Работает на Windos, Linux и macOS
        //
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Проект Mono, кстати, - это тоже дистрибутив .NET. Помимо поддержки самого CLI в нём есть
        //   //   реализации аналогов ASP.NET, ADO.NET и других разнообразных инфраструктур для создания
        //   //   GUI (т.е. на *nix'ах будут работать библиотеки, написанные командой Xamarin)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // На данный момент мы все можем свободно переезжать на Linux (единственная проблема в том, что там не будет VS. Придётся разбираться с
        //   утилитой dotnet или платить на JetBrains Rider. Остальные IDE там - унылое говно)


        // Other .NETs
        //
        //   Сам .NET Framework, кстати, изначально не хотели так сильно привязывать к Windows. Но, т.к. в то время стимула лезть на GNU/Linux
        //       и Apple системы не было, индусы быстро привязали .NET'ец к only-Windows штучкам
        //   Позже Microsoft таки полез на другие рынки (это те самые Windows Mobile и их Windows CE для встраиваемых систем). Но, т.к.
        //       сам .NET Framework имел тяжелейшие зависимости от desktop-штучек, переносить его туда полностью не решились. Его просто
        //       распилили , и так на свет появились .NET Compact Framework для смартфонов и планшетов, .NET Micro Framework для Arduino-like
        //       устройств
        //  
        //   На самом деле это всё превратилось в небольшой ад. C#'овец, решивший портировать своё поделие на мобилки, не мог этого сделать так
        //       гладко, ведь тучи всего, что он использовал, там не имеется. А если и имеется (например, XML генератор), то оно работает иначе


        // .NET Standard
        //
        //   А ещё есть такое понятие, как ".NET Standard". Это просто спецификации по тому, как надо
        //       строить .NET API'шки (чтоб они были единообразны и на десктопе, и на мобилках), и тебе этот стандарт не нужны (если ты не
        //       куёшь сам .NET, конечно)
        //   .NET Standrad, конечно, не запрещает создавать что-то платформо-зависимое поверх себя. Он стандартизирует лишь общую для всех
        //       реализаций базу
        //   К сожалению, .NET Standard на данный момент не обеспечивает заветное "write once run everywhere"


        // В итоге у .NET есть 2-е киллер-фичы - это гигантская BCL и отсутсвие мук выбора ("one true way". Здесь всё стандартизированно)


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   NETAndBCL_Silent()");
    }
    static void COM_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   COM_Silent()\n");


        // До прихода .NET для склейки кода разных языков массово использовалась другая штука от Microsoft - модель программирования COM
        //   (Component Object Model). На своё время (с 1993 до 2002) это была лучшая технология для склейки кода разных языков во что-то
        //   работающее. Например, человек, пишущий на C++, мог построить библиотеку кода (на винде это .dll или .lib), которой затем мог
        //   воспользоваться разработчик на Visual Basic
        // Да, это было весьмя удобно с точки зрения менеджера, ведь не нужно было переучивать или нанимать новый персонал при изменении
        //   вектора направления компании. Тем не менее, технология COM досаждала своей усложнённой инфрастуктурой, хрупкой моделю
        //   развёртывания и возможностью работы только с оконной осью. Аналоги были, но с ними всё ещё печальнее
        // На сегодняшний день Microsoft для создания мультиязыковых приложений для Windows рекомендует использовать именно .NET, но всё же не
        //   перестаёт поддерживать и обновлять COM. По словам представителей Microsoft, COM (а точнее COM+) и .NET - прекрасные
        //   взимодополняющие технологии (уже написанные COM+ библиотеки могут смешиваться с новым .NET кодом и наоборот)(технология COM+
        //   появилась в составе Windows 2000, и некоторые идеи оттуда перекочевали в .NET)


        // С использованием модели COM всё же было создано бесчисленное количество приложений, многие из которых живут до сих пор (весь
        //   MS Office, например)


        // В отличие от COM, библиотеки .NET не регистрируются в системной реестре. А ещё платформа .NET разрешает хранить несколько версий
        //   одной и той же .dll на одном компьютере (конфликта не возникает, т.к. либы лежат в папках, имя которых и описывает имя либы,
        //   её версию и ещё кое-что
        //   /////////after reading: CLR//////////////////////////////////////////////////////////////////
        //   // . CLR спроектирован так, чтоб ориентироваться по именам папок для поиска нужной .dll'ки
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   )


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   COM_Silent()");
    }
    static void CLI_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   CLI_Silent()\n");


        // CLI (Common Language Infrastructure) - это технический стандарт, описывающий то, каким должен быть язык, чтобы успешно работать в
        //   условиях .NET (точнее, что должен выдавать его компилятор, ведь .NET - это код некого CIL, и этот код может работать только с
        //   другим кодом CIL)

        // Когда компания Microsoft выпустила язык платформу .NET и язык C# для неё, также был разработан и набор официальных документов, что
        //   описывали синтаксис и семантику языков C# и CIL, основные пространства имён .NET
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // также там были описаны формат сборок .NET и механика действия исполняющей среды
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   Документы были переданы в организацию Ecma International (www.ecma-international.org) и утверждены ею в качестве официальных
        //   международных стандартов (да, Microsoft знает что делать, чтобы подсадить весь мир на себя). Наибольший интерес из них
        //   представляют эти спецификации:
        //
        //   > ECMA-334: C# Language Specification
        //   > ECMA-335: Common Language Infrastructure (CLI)
        //
        //   В чём их важность? Помимо того, что это были (скорее всего) первые инструкции к этим языкам, они также дали третьим лицам опору
        //   для реализации своих дистрибутивов .NET под свои ОС и процессоры. Спецификация ECMA-335 оказалась более объёмной. Настолько
        //   объёмной, что её решили поделить на разделы:
        //
        //       Раздел 1. Концепции и    - сначала была исповедь о общей структуре CLI
        //       архитектура                /////////after reading///////////////////////////////////////////////////////////////////////
        //                                  // в том числе о правилах CTS и CLS и механике функциональности исполняющей среды
        //                                  /////////////////////////////////////////////////////////////////////////////////////////////
        //
        //       Раздел 2. Определение и  - /////////after reading///////////////////////////////////////////////////////////////////////
        //       семантика метаданных       // затем великий Microsoft поведал нам о деталях метаданных и формате сборок .NET
        //                                  /////////////////////////////////////////////////////////////////////////////////////////////
        //
        //       Раздел 3. Набор          - на 3-ем разделе смертным представились описания синтаксиса и семантики языка титанов, языка CIL
        //       инструкций CIL
        //
        //       Раздел 4. Профили и      - затем все узрели высокоуровневый разбор минимальных библиотек классов, что должны поддерживаться
        //       библиотеки                 каждым дистрибутивом .NET (это коллекции, консольный ввод-вывод, файловый ввод-вывод, многопоточная
        //                                  обработка, рефелексия, доступ в сеть, основные средства защиты, манипулирование с XML данными. Да,
        //                                  в CLI не определены пространства ASP.NET, ADO.NET, WPF и Windows Forms)
        //
        //       Раздел 5. Формат обмена  - 5-е деление привнесло сведения о стандартном способе обмена информацией отладки между создателями и
        //       информацией отладки        потребителями CLI
        //
        //       Раздел 6. Дополнения     - наконец, на 6-ой раз небеса опустили нам набор разрозненных деталей, таких как указания по
        //                                  проектированию своих библиотек классов и деталей реализации компилятора CIL
        //
        // Иногда, когда говорят о .NET, имеют ввиду именно CLI


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   CLI_Silent()");
    }
    static void CLRAndJIT_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   CLR_Silent()\n");


        // Среда CLR (Common Language Runtime) - это один из трёх ключевых взаимосвязанных компонентов .NET (CLR и некие CTS и CLS). Именно
        //   эта часть отвечает за запуск и выполнение .NET приложений (и поэтому её часто зовут исполняющей средой .NET)(да, при запуске .NET
        //   приложения запускается именно CLR, и уже эта штука выполняет твоё поделие). Она автоматически обнаруживает, загружает и управляет
        //   такими вещами, как библиотеки .dll (что использует твоя программа). Вдобавок, CLR заботится о таких низкоуровневых (по местным
        //   меркам) аспектах, как управление памятью, координирование потоков и выполнение базовых проверок безопасности (помимо всего
        //   прочего). И ещё она делает некоторые проверки безопасности
        // Если разработчикам на Java при развёртывании (установки) своего приложения на новой машине требуется удоставериться в том, что на
        //   ней имеется JVM (Java Virtual Machine), то .NET-овцы не обременены этим, если они знают, что приложение будет запускаться только
        //   под Windows (т.е. в 95% случаев им не нужно делать эту работу)

        // Файлы приложений .NET (полученные после компиляции кода одного из CLI языков), как и программы Java, не хранятся в виде готовых к
        //   запуску бинарников (хоть и имеют расширение .exe). В них прописан всё-ещё читабильный для человека (уже упомянутый) CIL код, для
        //   запуска которого потребуется ещё один компилятор. И этим компилятором является довольно значительный кусок CLR под именем JIT
        //   (Just In Time compiler, иногда зовётся jitter). Именно он и производит спецефичные для платформы инструкции
        // Для каждого вида машины в среде CLR есть свой JIT компилятор, заточенный под её характеристики (да, CLR перед запуском читает их,
        //   включая марку CPU, чтоб затем выпускать ловко седлающий его особенности инструкции). Например, если твоё .NET приложение будет
        //   заускаться на мобильном устройстве (Windows Phone, например), то будет использован JIT compiler, что имеет способность работать в
        //   среде с ограниченным объёмом памяти. С другой стороны, если приложение будет развёртываться на целом сервере, то JIT компилятор не
        //   будет стеснятся расходовать всевозможные ресурсы машины для максимальной производительности твоего поделия
        // Ну и ещё - во время трансляции кода CIL в машинный код JIT компилятор кеширует результаты. Так ему не придётся компилировать один и
        //   и тот же код дважды
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Если нужно, то можно выполнить предварительную JIT компиляцию сборки. Делается это через утилиту ngen.exe (поставляется в
        //   //   .NET Framework SDK)
        //   /////////////////////////////////////////////////////////////////////////////////////////////

        // Гланвый механизм физически представлен библиотекой по имени mscoree.dll (также известной как Common Object Runtime Execution Engine
        //   - coree)(видимо, это не .NET библиотека). Когда ты применяешь своё .NET поделие (.exe или .dll файл), mscoree.dll загружается
        //   автоматически и загружает этот файл
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Сборка mscoree.dll в действии
        //   //
        //   //       ┌──────────────────────────┐           ╔═════════════════╗
        //   //       │ Исходный код на некотором├─────>─────╢ Некоторый .NET  ║
        //   //       │ .NET языке               │           ║ компилятор      ║
        //   //       └──────────────────────────┘           ╚════════╤════════╝
        //   //                                                       │
        //   //                                                       v
        //   //                                      ┌────────────────┴──────────────┐
        //   //                                      │        Исполняющая среда .NET │
        //   //                                      │        (mscoree.dll)          │
        //   //                                      │                               │
        //   //       ┌──────────────────────┐       │   ┌───────────────────┐       │
        //   //       │ Библиотека базовых   ├───────┼─>─┤ Загрузщик классов │       │
        //   //       │ классов (mscoree.dll │       │   └─────────┬─────────┘       │
        //   //       │ и другие)            │       │             v                 │
        //   //       └──────────────────────┘       │   ┌─────────┴─────────┐       │
        //   //                                      │   │ JIT компилятор    │       │
        //   //                                      │   └─────────┬─────────┘       │
        //   //                                      │             v                 │
        //   //                                      │   ┌─────────┴───────────────┐ │
        //   //                                      │   │ Инструкции, специфичные │ │
        //   //                                      │   │ для платформы           │ │
        //   //                                      │   └─────────┬───────────────┘ │
        //   //                                      │             v                 │
        //   //                                      │   ┌─────────┴─────────────┐   │
        //   //                                      │   │ Выполнение кода члена │   │
        //   //                                      │   └───────────────────────┘   │
        //   //                                      └───────────────────────────────┘
        //   //
        //   /////////////////////////////////////////////////////////////////////////////////////////////


        /////////after reading: dotnet///////////////////////////////////////////////////////////////
        // ****что такое .NET runtimes? это не CLR? если ввести dotnet --info, то в блоке
        //     .NET runtimes installed есть разные runtime'ы: Microsoft.AspNetCore.App ...
        //                                                    Microsoft.NETCore.App ...
        /////////////////////////////////////////////////////////////////////////////////////////////


        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   CLR_Silent()");
    }
    static void TypeAndCTS_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   CTS_Silent()\n");


        // "Тип" в мире .NET - это общий термин, под которым подразумевают что-то из набора класс, структура, перечисление, ..
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Ещё интерфейс, делегат. Всего 5 видов типов
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // CTS (Common Type System) - это формальная спецификация того, что может представлять из себя твой новый тип (по CTS он должен быть
        //   либо классом, либо структурой, перечислением и т.п.). CLR умеет работать только с заранее заданными в него видами схем данных
        //   (т.е. с заранее заданными типами), и для них уже были описаны все детали их работы (CLR следует этой спецификации, и поэтому она
        //   знает о том, как расположить объект твой стркутуры в памяти, и как затем он может общаться с другими объектами различного рода)
        // Эти спецификации обычно читают только те разработчики, что создают свой собственный компилятор или инструментарий

        // Большинство типов CTS могут распологать любым количеством "членов". Формально член типа в CTS - это что-то из набора конструктор,
        //   статический конструктор, вложенный тип, метод, поле, поле только для чтения, константа
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Ещё операция (в C++ звалась оператором), свойство, индексатор, событие
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // К каждому виду члена (также как и к видами типа) определены разнообразные характеристики
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Каждый член типа имеет видимость (модификатор доступа), некоторые члены могут быть объявлены как абстрактные или как
        //   //   виртуальные, большинство членов могут быть статическими, некоторые могут иметь характеристику обобщённости
        //   /////////////////////////////////////////////////////////////////////////////////////////////

        // Ну и ещё - CTS определяет чёткий набор фундаментальных типов данных. В каждом языке под каждый фундаментальный тип данных выделено
        //   по ключевому слову. Ну так вот, все эти ключевые слова в .NET языках - это всего-лишь сокращения для имён этих CTS типов. Кстати,
        //   вот они (и ключевые слова для них в нескольких .NET языках)(System - это пространство имён):
        //
        //       Тип данных CTS            Ключевое слово VB         Ключевое слово C#         Ключевое слово C++/CLI
        //
        //       System.Byte               Byte                      byte                      unsigned char
        //       System.SByte              SByte                     sbyte                     signed char
        //       System.Int16              Short                     short                     short
        //       System.Int32              Integer                   int                       int / long
        //       System.Int64              Long                      long                      __int64
        //       System.UInt16             UShort                    ushort                    unsigned short
        //       System.UInt32             UInteger                  uint                      unsigned int / unsigned long
        //       System.UInt64             ULong                     ulong                     __uint64
        //       System.Single             Single                    float                     float
        //       System.Double             Double                    double                    double
        //       System.Object             Object                    object                    object^
        //       System.Char               Char                      char                      wchar_t
        //       System.String             String                    string                    String^
        //       System.Decimal            Decimal                   decimal                   Decimal
        //       System.Boolean            Boolean                   bool                      bool
        //
        // Что есть System.Deciaml? Это такой тип с дробным числом, что даже точнее, чем double! Если double занимает в памяти 8 байт, и может
        //   хранить 16 знаков после запятой, то decimal занимает аж 16 байт, и хранит до 28 знаков. Ну и ещё - decimal более нацелен на дробь
        //   чем double. Хотя он и занимает больше места в памяти, его максимальный потолок по значинию меньше, чем у double. Вот их сравнение:
        //
        //       Decimal            Double
        //
        //       ~10^28             ~10^308      Наибольшее значение                    
        //       10^-28             ~10^-323     Наименьшее значение (без учёта 0-я)
        //       28                 15-16        Знаков после запятой
        //       16 байт            8 байт       Разрядность
        //       сотни миллионов    миллиарды    Операций в секунду
        //
        // Ключевые слова C++/CLI выглядят так, буд-то ими хотят запугать? Это вынужденная мера, т.к. C++ - изначально не .NET язык, и вообще
        //   плюсы были созданы в начале 1980-х (правда, создатели .NET брали за основу C++98). Некоторых BCL вещей в нём просто нет (например,
        //   тип object), а половина остальных (для которых уже были выделены ключевые слова) не совпадали по своему строению с .NET-овскими. В
        //   итоге пришлось добавлять ряд своих дополнений к синтаксису.
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Тем не менее, для писания на C++/CLI есть резон - т.к. вся мощь языка никуда не девается, его возможности, вроде ручного
        //   //   управления памятью, остаются доступными, а сборки после его компилятора содежрат как CLI код, так и готовые машинные команды.
        //   //   Как в таком случае дела обстоят с кроссплатформенностью? Никак, это расплата за использование такого рода нелегальщины в .NET
        //   // На самом деле .NET-овщики создали аж две своих версии C++. Первоначально был создан MC++ (Managed C++ или C++ with managed
        //   //   extensions), но т.к. он был ещё более ужасен (чуть менее, чем полнсотью вызывал отвращение), мелкомягкие решили создать
        //   //   новую ревизию языка - C++/CLI (всё ещё малочитабельно, как видишь)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   На сегодняшний день из-за ужасного синтаксиса и отсутсвия поддержки некоторых критических .NET частей C++/CLI используется разве
        //   что как клей между основной C# базой и уже написанными C++ библиотеками. Ну и ещё иногда на него переделывают узкие места в
        //   нагруженных приложениях. Необходимость в этих занятий встречается крайне редко, поэтому специализированные C++/CLI программисты в
        //   дикой природе практически не обитают
        // Как и всё в .NET, эти стандартные типы (все они - структуры, кстати, за исключением System.String) защищены по максимому, поэтому ты
        //   можешь не волносться о всякого рода потерях данных (здесь не бывает незаметных переполнений) и внутреннем устройстве этих типов в
        //   разных языках (т.к. они одинаковы везде)
        // Вот ещё немного полезной информации:

        bool a; System.Boolean a_;     // bool - или true, или false
        sbyte b; System.SByte b_;      // sbyte - 8-битное, от -128 до 127,                        не совместим с CLS
        byte c; System.Byte c_;        // byte - 8-битное, от 0 до 255
        short d; System.Int16 d_;      // short - 16-битное, от - 32'768 до 32'767
        ushort e; System.UInt16 e_;    // ushort - 16-битное, от 0 до 65'535,                      не совместим с CLS
        int f; System.Int32 f_;        // int - 32-битное, от -2'147'483'648 до 2'147'483'647
        uint g; System.UInt32 g_;      // uint - 32-битное, от 0 до 4'294'967'295,                 не сомвестим с CLS
        long h; System.Int64 h_;       // long - 64-битное, от -9'223'372'036'854'775'808 до 9'223'372'036'854'775'807
        ulong i; System.UInt64 i_;     // ulong - 64-битное, от 0 до 18 446 744 073 709 551 615,   не совместим с CLS
        char j; System.Char j_;        // char - 16-битное (Unicode), от U+0000 до U+ffff
        float k; System.Single k_;     // float - 32-битное, от -3.4х10^38 до +3.4х10^38 (по заявлению автора)
        double l; System.Double l_;    // double - 64-битное, от ±5.0х10^324 до ±1.7х10^308 (по заявлению автора)
        decimal m; System.Decimal m_;  // decimal - (от -7.9х10^28 до 7.9х10^28) / (10^от О до 28) (по заявлению автора)
        string n; System.String n_;    // string - набор символов Unicode. Ограничен объёмом системной памяти
        object o; System.Object o_;    // object - базовый класс для всех типов .NET. Может быть любым типом

        // Все эти типы (и отсальной самый важный кусок BCL) объявлены в созданной когда-то давно .NET библиотеке mscorlib.dll


        // В .NET каждый тип по умолчанию входит в иерархию классов, начинающуюся от System.Object
        //
        //       Object <- ValueType
        //       ^            ^
        //       |- Type      |- структуры и перечисления                      // Любой тип, производный от ValueType является
        //       |- String           ^                                         // структурой или перечислением, но не классом
        //       |- Array            |- Boolean UInt16 Byte Char DateTime ...
        //       |- Exception         
        //       |- Delegate
        //           ^
        //           |- MulticastDelegate
        //   
        //   System.Object даёт небольшой набор стандартных методов для абсолютно всех типов (т.к. они все тянутся от него). Потомки ValueType
        //   размещаются в стёке и имеют предсказуемое время жизни, поэтому довольно эффективны. Остальные типы же (вроде String или Array)
        //   живут в куче с автоматической сборкой мусора


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   CTS_Silent()");
    }
    static void CLS_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   CLS_Silent()\n");


        // Эта как раз та штука, на которой держится мультиязыковость .NET'а. Т.к. .NET поддерживает слишком много разных возможностей и
        //   парадигм, разным CLI языкам есть где разгуляться. Ну так вот, чтобы заинтересованные в общении языки умели понимать друг друга,
        //   были созданы спецификации, которых прозвали Common Language Specifications (CLS). Из себя они представляют ряд базовых
        //   возможностей, только которые они и должны выставлять в открытом доступе. CLS стремятся к тому, чтобы их могло поддерживать
        //   максимальное кол-во языков, и поэтому они включает в себя только самое необходимое
        // Возможности, что разрешает CLS, довольно сильно ограничены. Эти спецификации запрещают даже беззнаковые числа. Ещё CLS рассказывают
        //   то, как должны представляться строки, как внутренне представлять перечисления, как следует определять статические члены и т.д.
        // Каждое правило CLS имеет простое назнвание (например, "правило номер 6"). Вот пример правила:
        //
        //   > Правило номер 1. Правила CLS применяются только к тем частям типа, которые видны извне определяющей сборки.
        //
        //   Как видишь, не очень замысловато
        // Чтобы стать умелым .NET разработчиком запоминать все правила CLS не обязательно (достаточно лишь инструктировать компилятор о том,
        //   чтобы он следил за их соблюдением в коде). В общем и целом глубоко разбираться в спецификациях CTS и CLS должны лишь создатели
        //   инструментов и компиляторов
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Чтобы компилятор C# следил за CLS сомвестимостью в коде, достаточно использовать атрибут сборки
        //   //       [assembly: CLSCompliant(true)]
        //   /////////////////////////////////////////////////////////////////////////////////////////////

        // Если твой язык поддерживает CLS, то будь уверен, что ты сможешь работать со всеми другими CLS-поддерживающими языками. Ты можешь
        //   удивиться, но C# имеет много того, чего CLS не разрешает (например, всякого рода указатели и беззнаковые числа).  Для более полной
        //   картины, вот схема системы отношений языков:
        //
        //   ┌──────────────────────────────────────────┐
        //   │ CLI                                      │
        //   │                                          │
        //   │┌────────────────────────────────────┐    │
        //   ││ CTS/CLR ┌──────────────┐           │    │  CTS/CLR - можно было написать и просто CST, ведь схемы типов CTS и схема типов,
        //   ││         │ Visual Basic │           │    │    поддерживаемые средой CLR - это одно и то же
        //   ││        ┌┼──────────────┼─────────┐ │    │  Да, ни C#, ни VS, ни Fortran не поддерживают CST полностью. Фактически, единственным
        //   ││ ┌──────┼┼────────────┐ │ Fortran │ │    │    языком, что поддерживает весь CST - это IL (он же CIL, он же MSIL)
        //   ││ │ C#   ││    CLS     │ │         │ │    │  Языки общаются между собой через понятные для всех типы в CLS, скрывая друг от
        //   ││ └──────┼┼────────────┘ │         │ │    │    друга свои специфичные приколы (В CLS совместимых библиотеках Fortran'а ты не
        //   ││        │└──────────────┘         │ │    │    встретишь его специфичных массивов, например)
        //   ││        └─────────────────────────┘ │    │  Конечно, пропорции здесь не соблюдены
        //   │└────────────────────────────────────┘    │
        //   │                                          │
        //   │                                          │
        //   └──────────────────────────────────────────┘
        //

        // Как говорит автор, CLS должны поддерживать вообще все языки .NET


        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   CLS_Silent()");
    }
}