/*
 * creation date  26 jun 2021
 * last change    26 jun 2021
 * author         artur
 */
using System;

class _SystemObject_Attributes_Exceptions
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        SystemObject();
        Attributes();
        Exceptions();

        Console.ReadLine();
    }
    static void SystemObject()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   SystemObject()\n");


        // Вот все методы, что имеет класс System.Object. Они имеются у абсолютно всех типов в C# (т.к. всякий тип - потомок object'а), Но
        //   стоит сказать, что обычно каждый тип в .NET переопределяет эти методы под себя (как минимум ToString() переопределён почти везде)
        //
        //       class Object
        //       {
        //           public virtual bool Equals(object obj);  // Виртуальные члены:
        //           protected virtual void Finalize();       //   Equals() - в object он возвращает true только когда обе ссылки указывают на
        //           public virtual int GetHashCode();        //     одну запись в памяти, но обычно потомками этот метод переопределён для
        //           public virtual string ToString();        //     сравнения состояния (классом ValueType он переопределён). Автор говорит,
        //                                                    //     что при переопределении этого метода следует переопределить и
        //                                                    //     GetHashCode(), т.к. они оба используются типами Hashtable для извлечения
        //                                                    //     подобъектов из контейнера
        //                                                    //   Finalize() - метод для освобождения выделенной памяти под внутренние
        //                                                    //     неупровляемые объекты (те, память для которых выделялась в стиле Си)
        //                                                    //     перед его уничтожением. Версия в System.Object ничего не далает
        //                                                    //   GetHashCode() - возвращает хеш-код. Реализация из object применяет адрес
        //                                                    //     ячейки памяти, где расположен объект. Вообще, хешкод - это число, которое
        //                                                    //     представляет внутреннее состояние экземпляра (если несколько экземпляров
        //                                                    //     равны, то и хешкод у них будет равен). Он используется для быстрого
        //                                                    //     сравнения нескольких экземпляров, чтобы не вызывать более точный, но
        //                                                    //     дорогой Equals(), но если хешкоды всё-таки совпадают, то вызывается и
        //                                                    //     Equals() (поэтому его следует переопределить для точного сравнения
        //                                                    //     объектов)
        //                                                    //   ToString() - в object этот метод настроен на возвращение полностью заданного
        //                                                    //     имени (e.g. "_.MainObject+Rp"), часто переопределяется для вывода
        //                                                    //     состояния внутренних полей объекта
        //           public Type GetType();               // Невиртуальные члены, но на уровне экземпляра:
        //           protected object MemberwiseClone();  //   GetType() - метод возвращает объект Type, полностью описывающий тип ссылки
        //                                                //     экземпляра
        //                                                /////////after reading///////////////////////////////////////////////////////////////
        //                                                //     . Используется для получения инфо о типе в RTTI (runtime type information)
        //                                                /////////////////////////////////////////////////////////////////////////////////////
        //                                                //   MemberwiseClone() - метод для почленного копирования текущего экземпляра (т.е.
        //                                                //     клонирования)
        //           public static bool Equals(object objA, object objB);           // Статические члены
        //           public static bool ReferenceEquals(object objA, object objB);  //   Equals() - если обе ссылки одинаковы - возвращает true
        //       }                                                                  //     . Если нет - возвращает результат вызова
        //                                                                          //     objA.Equals(objB)
        //                                                                          //   ReferenceEquals() - true, если оба объекта ссылаются
        //                                                                          //      на одно и то же место в памяти. Да, фактически все
        //                                                                          //      эти методы сравнения возвращают одно и то же
        //
        Console.WriteLine("12.GetHashCode:  {0}", 12.GetHashCode());  // 12.GetHashCode() - возвращает хеш-код объекта (в виде int). Здесь
        Console.WriteLine("12.Equals(3):    {0}", 12.Equals(3));      //   используется реализация метода из структуры int, ведь метод
        Console.WriteLine("12.ToString():   {0}", 12.ToString());     //   переопределён
        Console.WriteLine("12.GetType():    {0}", 12.GetType());      // 12.Equals() - сравнивает один объектов с другим и, если она равны,
                                                                      //   возвращает true (наш метод также переопределён). При сравнении
                                                                      //   ссылочных типов по умолчанию сравнивается адрес памяти, куда они
                                                                      //   указывают. Имеется как static Equals(), так и Equals() уровня
                                                                      //   экземпляра
                                                                      // 12.ToString() - получаем string представление из объекта (по умолчанию
                                                                      //   выводится полное имя типа, вроде System.UInt64, но в int метод
                                                                      //   переопределён под вывод числа)
                                                                      // 12.GetType() - выдаст объект класса System.Type этого типа


        //  // public override string ToString() => $"[FirstName: {FirstName}, LastName: {LastName}, Age: {Age}]";
        //  // ToString() - это дело предпочтений, но обычно его переопределяют для вывода строки с состоянием каждого поля (от предков
        //  //   тоже), именно в таком формате ("[*:*; *:*; ..]"). Такому принципу следуют многие классы .NET. Это помогает при отладке


        //  //return obj?.ToString() == ToString();  // ToString() - это распространённое сокращение для сравнения объектов (если ToString()
        //                                           //   определён нужным образом)


        //  // return ToString().GetHashCode();  // ToString() - в большенстве случаев достаточно использовать эффективный GetHashCode()
        //                                       //   от строкового представления экземпляра. Если в классе уже есть уникальный
        //                                       //   идентефикатор (вроде номера карточки SSN - Social Security Number), то лучше
        //                                       //   использовать его


        //****BaseType - у объекта System.Type, полученного из System.Object, это свойство выдаст null


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   SystemObject()");
    }
    static void Attributes()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Attributes()\n");


        // Как мы знаем, одной из задач компилятора .NET является создание описаний метаданных для всех определяемых типов и типов, на
        //   которые в коде есть ссылки. Помимо этого, .NET поставляет возможность встраивать в сборку дополнительных метаданных с
        //   помощью "Атрибутов" ("Attributes()"). Если кратко, то это просто аннотации (примечания) к типу (класс, структура, интерфейс,
        //   перечисление), члену (свойству, методу и т.д.), сборке или модулю
        // Чем является атрибут на деле? Это обыкновенные классы, что исходят из абстрактного System.Attribute (что из mscorlib.dll и
        //   System.Runtime.dll). На самом деле любой класс можно использовать в качестве атрибута. Но чтоб они явно чем-то отличались, в .NET
        //   принято условное соглашение, что все классы атрибутов по имени кончаются на Attribute (например, System.ObsoleteAttribute.
        //   Один из поставляемых в BCL'е атрибутов, кстати)(это как интерфейсами, чьё имя также по всеобщему соглашению начинают с I)
        //   /////////after reading:info in Motorcycle class//////////////////////////////////////////////
        //   // . Но сказать стоит, что прибавка Attribute нечто большее чем условность есть. Компилятор
        //   // опускать Attribute в именах атрибутов в []'ках разрешает
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // И ещё - среда CLR знает в лицо некоторые атрибуты, и с
        //   типом/членом/сборкой/модулем под ним она будет работать как-то по особому. Компилер также к некоторым атрибутам дышит неровно
        //
        // В пространствах базовых классов есть rое-какое количество стандартных атрибутов, что можешь использовать и ты. Вот немногие из них:
        //
        //   > [CLSCompliant]     - System.CLSCompliantAttribute (mscorlib.dll, System.Runtime.dll). Заставляет элемент следовать правилам CLS
        //                          (Common Language Specification). Это гарантирует то, что тип будет работать во всех языках .NET
        //                          /////////after reading://////////////////////////////////////////////////////////////////////
        //                          // . К классу Motorcycle этот атрибут применяется. Ещё немного инфы найдёшь ты там
        //                          /////////////////////////////////////////////////////////////////////////////////////////////
        //   > [DllImport]        - System.Runtime.InteropServices.DllImportAttribute (mscorlib.dll, System.Runtime.InteropServices.dll).
        //                          Позволяет коду
        //                          обращаться к любой неуправляемой библиотеке кода C или C++ (включая API самой оси). Но этот атрибут не
        //                          предназначен для для библиотек COM
        //   > [Obsolete]         - System.ObsoleteAttribute (mscorlib.dll, System.Runtime.dll). Этим помечают устаревший член. Если кто-то
        //                          решит воспользоваться таким, то он получит предупреждение
        //                          от компилятора
        //   > [Serializable]     - System.SerializableAttribute (System.Runtime.dll)
        //                          /////////after reading:****сериализация//////////////////////////////////////////////////////
        //                          // Помечает класс или структуру как сериализируемую (т.е.
        //                          // их можно будет сохранить состояния их объектов.
        //                          // Как говорит автор, сохраняются они в потоке)
        //                          /////////////////////////////////////////////////////////////////////////////////////////////
        //   > [NonSerialized]    - System.NonSerializedAttribute (System.Runtime.dll)
        //                          /////////after reading:****сериализация//////////////////////////////////////////////////////
        //                          // Этим помечаются поля, что не должны учавствовать в
        //                          // сериализации (они просто не сохраняются с объектом).
        //                          /////////////////////////////////////////////////////////////////////////////////////////////
        //   > [ServiceContract]  - System.ServiceModel.ServiceContractAttribute (System.ServiceModel.Primitives.dll)
        //                          /////////after reading:****сериализация//////////////////////////////////////////////////////
        //                          // Помечает метод как контракт, реализованный службой WCF (Windows Communication Foundation)
        //                          /////////////////////////////////////////////////////////////////////////////////////////////
        //
        //   Если этого покажется мало, никто не запрещает построить и свой собственный атрибут ****как познакомить его с CLR и компилиром?
        // Почему я писал имена этих атрибутов в []'ках и без окончания Attribute? Прочто они на деле всегда так и используются. Ниже ты
        //   увидишь демонстрацию
        //
        // Ещё стоит понимать, что атрибут (или, как говорит автор, встроенные метаданные) сами по себе ни на что не влияет, и вызывающий код
        //   даже не знает о его существовании,
        //   пока сам не спросит посредством рефлексии


        //****пример использования атрибута


        // Конечно, .NET поставляет достаточно много утилит, созданных для работы с атрибутами. Сам компилятор C# запрограммирован на
        //   обнаружение их при компиляции. Например, встретив атрибут [CLSCompliant], компилятор проверяет, действительно ли помеченный
        //   им элемент использует только совместимые с CLS конструкции. И ещё пример: при обнаружении [Obsolete] он будет выводить
        //   предупреждение, если кто-то воспользовался таким элементом
        // И ещё - многие методы базовых классов .NET сделаны так, чтобы распознавать определённые
        //   атрибуты через рефлексию
        /////////after reading:****сериализация//////////////////////////////////////////////////////
        //   . Например, если ты хочешь сохранить состояние объекта в файл, вызвав
        //   метод Serialize() класса BinaryFormatter (что находится в
        //   System.Runtime.Serialization.Formatters.Binary), то этот метод
        //   сначала проверит, есть ли у типа этого объекта
        //   атрибут [Serializable]. И только затем, если действительно есть, Serialize() приступит
        //   к его упаковыванию в файл в компактный двоичный формат
        /////////////////////////////////////////////////////////////////////////////////////////////
        // Наконец, ты можешь сам построить приложение, способное распознавать специальные атрибуты


        // Предположим, у нас есть класс Motorcycle, что мы хотим сделать CLS'угодным. Нам просто нужно добавить атрибут
        //   [CLSCompliant] перед class. Также мы имеем в нём 1-но уже устаревшее поле. Нам следует приставить атрибут
        //   [Obselete] к нему спереди. Класс определён ниже (не пропускай комментарии к ним, там также очень много ключевой инфы!)
        // После компиляции через ildasm.exe (именно в нём, а не в его дополнительных окнах) можно увидеть, что в классе Motorcycle
        //   в красном треугольнике (чья инфо начинается с .class, указывающей на хранение метаданных класса) появилось слово
        //   serializable, а после поля weightOfCurrentPassengers помимо private и float32 вписано ещё и notserialized
        //   ****блок выше пишет про то, что появилось после применения атрибута [Serializable] и [NonSer..]. Но в определениях в поставил
        //       другие атрибуты. Что появилось из-за них?
        // private - да, выходит, что это такой же атрибут, хоть и неявный
        //
        HorseAndBuggy myMule = new HorseAndBuggy();  // HorseAndBuggy - т.к. этот класс помечен как устаревший (атрибутом [Obsolete..]),
                                                     //   VS выдаёт предупреждения (это видно прямо здесь и ещё в окне Error List). Здесь
                                                     //   той частью, что применила рефлексию, является компилятор
                                                     // Вот общая сводка о атрибутах .NET:
                                                     //   > атрибуты - это классы, что расширяют System.Attribute
                                                     //   > атрибуты дают в результате встроенные методанные для своего элемента
                                                     //   > атрибуты бесполезны до тех пор, пока какой-то агент не получит их (методами
                                                     //     рефлексии)
                                                     //   > в C# атрибуты применяются с использованием символов []


        AttributeDemo _;  // AttributeDemo - этот класс создан для демонстрации нескольких дополнительных крупиц инфы, что я вычитал в статье


        // Не откланяясь от автомобильной темы (через которую идёт вся книга. Ну и энциклопедия), в этой сборке будет созданы новые версии транспортных
        //   средств, но теперь помеченные нашим собственным атрибутом VehicleDescriptionAttribute (он создан ниже)
        //
        VehicleDescriptionAttribute myAttribute;  // myAttribute - как уже говорилось, атрибуты - это обычные классы. И от них можно создавать
                                                  //   объекты
                                                  // VehicleDecriptionAttribute - у определения этого атрибута много поясняющих комментариев


        Motorcycle2 motory2;    // Motorcycle2 - в комментах к этому классу описан ещё один синтаксис (синтаксис "именнованного свойства")
        /////////after reading:Serialization/////////////////////////////////////////////////////////
        HorseAndBuggy2 buggy2;  // HorseAndBuggy2 - просто ещё 1-н пример использования атрибутов
        /////////////////////////////////////////////////////////////////////////////////////////////
        Winnebago winny;        // Winnebago - а у этого класса в комментариях есть пример того, что компилер выдаёт после прочтения атрибутов


        // По умолчанию новосозданные атрибуты могут применятся к почти любому аспекту кода (метод, поле, структура..). Согласись, ты бы хотел
        //   отключить возможность назначения [VehicleDescription] какому-нибудь методу. Примерно такая же проблема уже была занозой в заднице
        //   у многих программистов,
        //   поэтому в .NET ввели стандартный атрибут [System.AttributeUsage] (mscorlib.dll, System.Runtime.dll), что может ограничить
        //   местность обитания и настроить повадки другого атрибута. [System.AttributeUsage] довольно мелкий, вот
        //   всё его определение:
        //
        //       [AttributeUsage(AttributeTargets.Class, Inherited = true)]     // [AttributeUsage..] - да, атрибут атрибутит сам себя
        //       public sealed class AttributeUsageAttribute : Attribute        //   ****тонкости компилятора?
        //       {
        //           public AttributeUsageAttribute(AttributeTargets validOn);
        //   
        //           public bool AllowMultiple { get; set; }   // AllowMultiple - свойство типа bool, указывающее, может ли атрибут применятся
        //                                                     //   к одному и тому же элементу (полю, структуре..) более одного раза (по
        //                                                     //   умолчанию это false) (например, сначала задействовав один конструктор
        //                                                     //   атрибута, а затем чуть ниже в других [] - другой). В BCL я почему-то такой
        //                                                     //   ещё не видел, чтобы какому-то атрибуту выставляли AllowMultiple в true
        //           public bool Inherited { get; set; }       // Inherited - указывает, будет ли атрибут также применяться и к классам, что
        //                                                     //   расширяют текущий (т.е. если true, то тебе не нужно будет повторно писать
        //                                                     //   этот атрибут в [] у классов-наследников). Если такой inherited-true
        //                                                     //   атрибут применяется к методам, то при их перезаписи (ключевым словом
        //                                                     //   override) также не нужно будет повторять [] перед ними
        //           public AttributeTargets ValidOn { get; }  // ValidOn - (с надмозг. действующий на) это значение перечисления
        //                                                     //   System.AttributeTargets (об это ниже)
        //           ****по msdn'у здесь должны быть ещё TypeId
        //       }
        //
        // Как видишь, этот over-атрибута хранит свойство с типом перечисления System.AttributeTargets (mscorlib.dll, System.Runtime.dll). Вот
        //   из чего это перечисление состоит:
        //
        //       ..                                                // .. - у перечисления есть 1-н свой атрибут
        //       public enum AttributeTargets
        //       {
        //           All, Assembly, Class, Constructor,
        //           Delegate, Enum, Event, Field,
        //           GenericParameter, Interface, Method, Module,
        //           Parameter, Property, ReturnValue, Struct
        //       }
        //
        VehicleDescription_1Attribute myRestrictedAttr;  // VehicleDescription_1Attr.. - на этом атрибуте опробован [System.AttributeUsage]
                                                         //   (у него несколько интересных комментариев)


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Attributes()");
    }
    static void Exceptions()
    {
        //****проблемы с форматированием комментариев
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Exceptions()\n");


        // Три распространённых термина, описывающие разновидности аномалий:
        //   Дефект - это ошибка по вине программиста. Например, этим может быть неосвобождённая память, которая стала утечкой
        //   Пользовательские ошибки - ошибка, возникающая из-за пользователя. Например, он мог ввести Chucky в поле для номера телефона. Это
        //     почти наверняка приведёт к ошибке, если в программе не предусмотрена обработка некорректного ввода
        //   Исключения - это ошибки выполнения, которые трудно (а может и невозможно) учесть при проектировке. Например, программа может
        //     попытаться подключиться к несуществующей базе данных или подключится к машине, что отключена в данный момент из сети


        // Может показаться интересным, что генерироваться исключения в C# будут часто даже и для дефектов, и для пользовательских ошибок, т.к.
        //   в библиотеках .NET определены многие виды исключений (вроде FromatException, IndexOutOfRangeException, FileNotFoundException и
        //   т.д.), и почти все методы типов генерируют какие-то из них в случае возникновения проблем
        // Стоит знать, что до появления общей системы исключений в каждом проекте придумывалась своя собственная структура обработки аномалий.
        //   Например, в WinAPI (это Си) определили сотни дефайнов для кодов различных ошибок, а также множество вариантов одного и того же
        //   типа для разных потенциально опасных функций (bool, BOOL, VARIANT_BOOL и т.д.), каждый для своего исключения. .NET же
        //   стандартизировал свою структуру для своих языков, предложив ещё несколько дополнительных преимуществ. Обработка исключений здесь
        //   не ограничивается одной сборкой, твои исключения могут обрабатываться на другом языке .NET. Ещё одно преимущество в том, что
        //   каждое исключение здесь хорошо задокументировано, а также при его генерации автоматом создаётся детальный снимок стёка вызовов


        // Основная начинка класса System.Exception
        //
        //     class Exception : ISerializable, _Exception  // Iserializable, _Exception - это интерфейсы (гл. 8), не классы. Интерфейс
        //     {                                            //   _Exception (да, имя без I) здесь позволяет каждому исключению .NET
        //                                                  //   обрабатываться неуправляемым кодом (если используется COM).
        //                                                  /////////after reading/////////////////////////////////////////////////////////////
        //                                                  //   ISerializable нужен для выбора что нужно сериализировать, а что нет
        //                                                  ///////////////////////////////////////////////////////////////////////////////////
        //         public Exception(string message, Exception innerException);
        //         public Exception(string message);
        //         public Exception();

        //         public virtual Exception GetBaseException();
        //         public virtual void GetObjectData(SerializationInfo info,
        //             StreamingContext context);

        //         public virtual IDictionary Data { get; }      // Data - это коллекция пар ключ-значение только для чтения для дополнительной
        //         public virtual string HelpLink { get; set; }  //   информации. По умолчанию пуст
        //         public Exception InnerException { get; }      // HelpLink - это URL для доступа к файлу или сайту с подробным описанием
        //         public virtual string Message { get; }        //   исключения
        //         public virtual string Source { get; set; }    // InnerException - это информация о других исключениях, виновных в данном.
        //         public virtual string StackTrace { get; }     //   Только  для чтения, а устанавливаться может через конструктор при
        //         public MethodBase TargetSite { get; }         //   создании
        //     }                                                 // Message - сообщение о самой ошибки. Также задаётся только при генерации
        //     // Заметь, что почти все члены в System.Exception // Source - свойство для установки сборки или объекта, привёдшего к исключению
        //     //   - виртуальные                                // StackTrace - это свойство хранит строку, что содержит имена вызовов методов
        //                                                       //   в момент создания исключения. Полезно при отладке
        //                                                       // TargetSite - свойство для хранения снимка метода, в котором произошло
        //                                                       //   исключение. Тоже полезен


        try                                           // try-catch - стандартная обработка исключений, почти как в C++. Если исключение не
        {                                             //   будет отловлено этим блоком, то оно пойдёт дальше вниз по стёку. Если стёк кончится,
                                                      //   а исключение всё-ещё не отловлено, тогда (в случае Debug режима) VS остановит
                                                      //   выполнение программы и тыкнет на место где оно произошло, а также покажет окно
                                                      //   с инфо о исключении
            Battary battary = new Battary(400, 480);  // Battary - класс, что способен сгенерировать исключение в конструкторе, если стартовая
                                                      //   вместимость каким-то фигом окажется больше общей ёмкости аккамулятора
                                                      // new Battary(400, 480) - собственно, так и происходит. Стандартная единица ёмкости для
                                                      //   аккамуляторов, кстати, - это ампер-час
        }                                             //
        catch (Exception e)  // catch - может отлавливать только System.Exception-совместимые типы. После отлавливания тебе решать что
        {                    //   делать с полученными данными в e. Если throw не был задействован, то catch блоки пропустятся
            Console.WriteLine("#######       Error       #######");
            Console.WriteLine("Method: {0}", e.TargetSite);  // e.TargetSite - объект с информацией о методе, сгенерировавшем исключение
            Console.WriteLine("Message: {0}", e.Message);    // e.Message - сообщение, которые мы записали при его создании
            Console.WriteLine("Source: {0}", e.Source);      // e.Source - сборка, которая создала исключение (или имя виновного объекта)
            Console.WriteLine("Stack:\n{0}", e.StackTrace);  // e.StackTrace - строка с трассировкой методов, которые привели к исключению (оно
            Console.WriteLine("HelpLink: {0}", e.HelpLink);  //   же зовётся слепком стёка)
                                                             // e.HelpLink - ссылка на сайт помощи
            Console.WriteLine("Custom Data:");               // Заметь, что большая часть свойств назначается автоматически при создании
            foreach (System.Collections.DictionaryEntry de in e.Data)  // System.Collections.DictionaryEntry - с помощью этого можно
                Console.WriteLine("|---{0}: {1}", de.Key, de.Value);   //   получать пары ключ-значения из экземпляра IDictionary
            Console.WriteLine("####### End of the error #######");     // Data - удобен в том смысле, что избавляет от необходимости
        }  // Если произошло что-то действительно серьёзное, то по     //   создавать кастомные версии System.Exception, упаковывая
           //   возможности надо осавить программу в рабочем состоянии //   некоторую информацию в себе. Тем не менее, разработчики .NET
           //   , хоть и с некоторыми недееспособными возможностями    //   всё-равно строят свои типы, что даёт возможность применять
           //                                                          //   отдельные catch-блоки для каждого из них
        Console.WriteLine();


        //  // Икслючения уровня системы (System.SystemException) - в библиотеках .NET определено множество исключений, которые созданы для
        //  //   семантики своих пространст имён (например, в System есть исключения, которые связаны со стандартными типами, вроде
        //  //   IndexOutOfRangeException, StackOverflowException, ArgumentOutOfRangeException и т.д.). Исключения, генерируемые самой
        //  //   платформой .NET - это и есть исключения уровня системы. Обычно они фатальны. Системные исключения исходят прямо от общего
        //  //   для них класса System.SystemException (который сам исходит из System.Exception, а дальше System.Object). Из себя этот класс
        //  //   представляет всего лишь набор специальных конструкторов. Зачем он вообще тогда нужен? Автор говорит, что через него можно
        //  //   определить, что исключение сгенерировала исполняющая среда .NET, а не часть твоей сборки:
        //  //       if (e is SystemException) { ... }
        //  // Исключения уровня приложения (System.ApplicationException) - а это специальная отправная точка для исключений твоего приложения.
        //  //   Также, как и System.SystemException, этот класс не привносит ничего нового, кроме набора новых конструкторов, и его цель та же
        //  //   - т.е. дать возможность различать System.ApplicationException от других исключений. На самом деле (как говорит автор) лишь
        //  //   небольшая часть разработчиков .NET вспоминает про него. Большая часть погромистов наследует свои исключения прямо от
        //  //   System.Exception. Ничего страшного, правда, в этом нет


        // Класс CarIsDeadException - пример эталонного класса исключения
        CarIsDeadException _;


        // Выбрашенное исключение будет отловлено первым подходящим catch блоком (т.е. если catch ловит тип исключения, несовместимого с
        //   текущим, то этот блок пропускается), а catch блоков может быть много
        // Стоит сразу сказать, что в цепочке catch блоков сначала будет отлавливаться исключения какого-то типа (например, System.Exception),
        //   а затем типа его потомка (любого другого exception'а), то компилятор выдаст ошибку
        try
        {
            uint inp;
            Console.Write("Enter value that less than 10: ");
            inp = uint.Parse(Console.ReadLine());
            Console.WriteLine($"122 / {inp}: {122 / inp}");  // 122 / 0 - стоит помнить, что при использовании double или float
            Console.WriteLine("Luck!");                      //   исключение не сбрасывается, т.к. у них есть зарезервированное NaN для
        }                                                    //   подобных случаев
        catch (OverflowException ex)                         // System.OverflowException - на случай, если кто-то введёт число за пределами
        {                                                    //   нужных границ (для uint это любое число с минусом)
            Console.WriteLine("\n### OverflowException ###");
            Console.WriteLine("Message: {0}", ex.Message);
            Console.WriteLine("HelpLink: {0}", ex.HelpLink);
            Console.WriteLine("Error code: {0}", ex.HResult);
        }
        catch (FormatException ex)                           // System.FormatException - на случай, если Parse() решит, что ввод не похож на
        {                                                    //   uint (например "hello")
            Console.WriteLine("\n### FormatException ###");
            Console.WriteLine("Message: {0}", ex.Message);
            Console.WriteLine("HelpLink: {0}", ex.HelpLink);
            Console.WriteLine("Error code: {0}", ex.HResult);
        }
        catch (DivideByZeroException)                        // ex - catch блоки могут отлавливать икслючения, не сохраняя их. Такое не
        {                                                    //   работает с методами
            Console.WriteLine("\n### DivideByZeroException ###");
            Console.WriteLine("It is zero");
        }
        catch (Exception ex) when (DateTime.Now.DayOfWeek < DayOfWeek.Saturday)
        {                                                    // when - это фильтрация исключений. Ключевое слово
                                                             //   знакомо по switch, смысл тот же, но с здесь
                                                             //   обязательны скобки. Это появилось в C# 6. Использование этого сберегает от
                                                             //   ошибки, что я описал в начале пункта. Конечно, такое ветвление можно сделать
                                                             //   и внутри блока catch, но использование when даёт чуть большую гибкость (и
                                                             //   элегантность)
        }
        catch (Exception ex)                                 // System.Exception - понятно, что Exception способен отлавливать абсолютно всё.
        {                                                    //   Компилятор даже не допустит того, чтобы за таким catch следовали другие catch
                                                             //   блоки. Автор говорит, что везде, где только можно отлавливать исключения
                                                             //   специального типа и не использовать сразу Exception
            Console.WriteLine("\nUnidentified error: {0}", ex.Message);
        }
        catch                                                // catch - можно вообще оставить catch без ничего. Такой catch блок сработает с
        {                                                    //   любым исключением. Ты можешь увидеть, что VS выдаёт предупреждение о том, что
                                                             //   до этого catch всё итак будет отловлено. Почему не ошибка о которой я
                                                             //   говорил? Почему-то компилятор более благосклонен к этому catch
            throw;                                           // throw - но если исключение ловится, но всё же хочется отправить его ниже, то
                                                             //    можно снова воспользоваться throw. Необязательно даже писать ex (которого в
                                                             //    этом catch то и нет)
        }
        finally                                              // finally - будет выполнятся всегда независимо от того, сгенерировалось ли
        {                                                    //   исключение или нет. Этот блок необязателен. Если исключение было, выполняется
                                                             //   после catch. В C++ такого нет. Этот блок часто используется для закрытия
                                                             //   файла или освобождения объектов из неуправляемой кучи
        }


        //  // Может быть такая ситуация, что при возниковении исключения, вроде CarIsDeadException, ты бы хотел записать это событие
        //  //   во внешний файл carErrors.txt, но при попытке открыть также возникает исключение. Ты можешь также покрыть эту часть
        //  //   кода try-catch блоком и использовать свойство InnerException, чтобы не потерять первоочередное CarIsDeadException:
        //  //      try
        //  //      {
        //  //          ...
        //  //      }
        //  //      catch (CarIsDeadException ex)
        //  //      {
        //  //          try
        //  //          {
        //  //              System.IO.FileStream file = System.IO.File.Open("C:\carErrors.txt", System.IO.FileMode.Open);
        //  //              ...                     // System.IO - рассматривается позже
        //  //          }
        //  //          catch (Exception ex2)
        //  //          {
        //  //              throw new CarIsDeadException(ex.Message, ex2);  // new - придётся создать новое исключение, т.к. поле
        //  //          }                                                   //   свойства InnerException можно задать только
        //  //      }                                                       //   конструктором
        //  //   Дальнейшую обработку мы перекладываем на уровень ниже


        // Класс System.ArgumentException - специальное ответвление для ислключений, связанных с аргументами
        System.ArgumentException ex1;


        // Класс System.InvalidOperationException - это исключение, что создано для выбрасывания в методе при неподоходящем внутреннем
        //   положении объекта
        /////////after reading///////////////////////////////////////////////////////////////////////
        //   . Например, объекты типа System.Collections.Stack при использовании их метода Peek()
        //   выбросят его, если в стёке нет элементов
        /////////////////////////////////////////////////////////////////////////////////////////////
        System.InvalidOperationException ex2;


        object obj = 5;
        try                             // try - для опеспечения высокой безопасности следует применять try-catch блоки при распаковке
        {
            Console.Write("short myShrt = (short)obj: ");
            short myShrt = (short)obj;  // short - в куче должен быть записан тот тип, которые мы пытаемся извлечь
        }
        catch (InvalidCastException e)  // System.InvalidCastException- исключение, генерирующееся при неправельном извлекаемом типе
        {
            Console.WriteLine(e.Message);
        }
        finally
        {
            Console.WriteLine();
        }


        // Класс System.IO.IOException - ответвление для исключений, связанных с Input/Output


        double rate2;
        try
        {
            rate2 = 4.5d;  // try { rate2 = .. } - компилятор знает о том, что в try-блоках частенько выбрасываются Exceptions, и поэтому не
        }                  //   признаёт присваивания в нём (ведь что делать, если перед присваиванием запустится throw?)(rate2 в итоге за
        catch              //   пределами try {} для компилятора остаётся unsigned переменной)
        {                  // Да, похоже на то, что разработчики просто поленились научить компилятор отслеживать использование throw в таких
        }                  //   блоках (здесь же ясно видно, что никакого throw в коде не имеется!)
        //Console.WriteLine("rate2: {0}", rate2);
        

        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Exceptions()");
    }
    class Battary
    {
        public uint MaxCapacity { get; }
        public uint CurrentCharge { get; set; }
        public Battary(uint maxCapacity, uint currentCharge)
        {
            MaxCapacity = maxCapacity;
            CurrentCharge = currentCharge;
            if (currentCharge > maxCapacity)
            {
                //throw new Exception(...);                       // ex - обычно не создают отдельную переменную для throw, если она не нужна
                Exception ex = new Exception("Battary got charge that exceeds MaxCapacity");
                ex.HelpLink = "http://www.icbe.org/";             // ex... - помним про инициализацию в стиле Си
                ex.Source = "currentCharge";                      // HelpLink - по умолчанию строка свойства пуста
                ex.Data.Add("currentCharge", currentCharge);      // Data.Add() - используем интерфейс IDictionary. О типах контейнеров ты
                ex.Data.Add("maxCapacity", maxCapacity);          //   детально узнаешь позже
                throw ex;
                //                                                // throw - объявляет об исключении, также как в C++. До C# 7
                // Обычно исключения используются там, где        //   throw был оператаром, так что его можно было ставить там,
                //   происходит что-то действительно критичное,   //   где разрешены операторы. С C# 7 же throw стал ещё и
                //   и лучше используй их там, где они могут      //   выражением, и теперь он доступен там, где разрешены и они.
                //   действительно сократить объёмы кода          //   В C# throw не может выбрасывать что-то кроме
                //                                                //   System.Exception-совместимых экземпляров
            }
        }
    }
    [Serializable]                                     // [] - это атрибут (этот вроде позволяет упаковывать класс в файл). Передовой опыт .NET
    // В VS есть сниппет exception                     //   говорит, что каждое исключение должно:
    //   , выдающий нужную                             //   > Быть производным от Systme.Exception/System.ApplicationException
    //   заготовку для кастомных                       //   > Почтено атрибутом [Serializable]
    //   исключений, отвечающую                        //   > Иметь стандартный конструктор
    //   всем требованиям                              //   > Иметь конструктор, что устанавливает значение в свойство Message
    //                                                 //   > Иметь конструктор, который способен принимать внутреннее исключение
    //                                                 //   > Иметь конструктор для поддержки серриализации
    class CarIsDeadException : ApplicationException    // CarIsDead.. - это пример того, когда полезно определять собственное исключение
    {                                                  // ..Exception - по негласным правилам все имена классов исключений заканчиваются на
        private string messageDetails = String.Empty;  //   Exception
        public string CauseOfError { get; set; }       // Cause - здесь польза (хоть и небольшая) в том, что нужную нам информацию мы можем
                                                       //   получить из свойства, а не через интерфейс Data
        public DateTime ErrorTimeStamp { get; set; }


        public CarIsDeadException() { }
        public CarIsDeadException(string message, string cause)
        {
            messageDetails = message;
            CauseOfError = cause;
            ErrorTimeStamp = DateTime.Now;             // ErrorTimeStamp - здесь польза в том, что нам не нужно вручную при генерации задавать
        }                                              //   время генерации, всё сделает кастомный конструктор
        public CarIsDeadException(string message, Exception inner) : base(message, inner) { }
        // Не хватает только конструктора для          //
        //   сериализации                              //


        public override string Message => string.Format("Car Error Message: {0}", messageDetails);
        public void Display()                          // Display() - полезность в том, что мы добавили дополнительную нужную нам возможность
        {                                              //   вывода всего на экран
            Console.WriteLine("Message: {0}", Message);
            Console.WriteLine("Cause: {0}", CauseOfError);
            Console.WriteLine("DateStamp: {0}", ErrorTimeStamp);
            if (HelpLink != null)
                Console.WriteLine("HelpLink: {0}", HelpLink);
        }
    }
}
[CLSCompliant(true)]
class Motorcycle        // ..Motorcycle - этот и классы ниже энкциклопедии ещё понядобсятся, поэтому для удобства я вынес их в общее
{                       //   пространство
                        //
                        // [..] - этим атрибутом мы даём понять интерисующемуся коду (ну и компилятору), что этот класс
                        //   полностью CLS совместимый, и его 100% можно использовать в проектах на других языках.
                        //   Компилер, увидев этот атрибут, станет проверять содержимое класса Motorcycle, чтоб
                        //   удостовериться в CLS'ности. Если компилер внезапно наткнётся на что-то неугодное, выдаст error
                        // System.CLSComp..Attribute - ты заметил, что здесь опущено окончание Attribute, да? И это
                        //   будет работать (компилятор поймёт, что мы хотим использовать именно
                        //   System.CLSCompliantAttribute). Это значит, что компилятор поддерживает это соглашение. Но
                        //   Имей ввиду, что такая сокращённая система обозначения атрибутов имеется только в C#
                        //   , и её поддерживают не все языки .NET (ну, может, ещё это есть в F#)
                        // Как оказалось, атрибут нельзя дублировать (в VS выходит Error в окне Error List)
                        // Ты также можешь писать полное имя класса атрибута в [],
                        //   получив тот же результат:
                        //       [System.CLSCompliantAttribute(true)]
                        //   (VS 2019 даже выделит суффикс другим оттенком с предложением
                        //   упростить имя)
                        // [CLSCompliant(..)] - да, так мы отправляем аргументы конструктору. Если ты заглянешь в определение атрибута
                        //   (класса), то увидишь, что его строение очень просто:
                        //
                        //       ..
                        //       public sealed class CLSCompliantAttribute : Attribute
                        //       {
                        //           public CLSCompliantAttribute(bool isCompliant);
                        //           bool IsCompliant { get; }
                        //       }
                        //
                        //   (да, всё просто)
    float weightOfCurrentPassengers;
    [Obsolete]                        // [Obsolete] .. - при этом поле под атрибутом устаревшее (атрибут отностися только
                                      //   к чему-то одному)
    bool hasRadioSystem;              // [][] - если тебе нужно указать сразу несколько атрибутов к одному элементу, можешь писать   
                                      //   так:
                                      //       [Serializable, Obsolete("Use another vehicle!")]
                                      //       ...
                                      //   Или можно просто писать их друг за другом:
                                      //       [Serializable]                                           
                                      //       [Obsolete("Use antoher vehicle!")]
                                      //       ...
                                      //   Конечный результат будет одинаков
    bool hasHeadSet;
    bool hasSissyBar;
}
[ObsoleteAttribute("Use another vehicle!")]
class HorseAndBuggy  // [ObsoleteAttribute(..)] - если заглянуть в определение
{                    //  , можно увидеть, что у него три версии конструктора:
}                    //       public sealed class ObsoleteAttribute
                     //       {
                     //           public ObsoleteAttribute();
                     //           public ObsoleteAttribute(string message);
                     //           public ObsoleteAttribute(string message, bool error);
                     //           public string Message { get; }
                     //           public bool IsError { get; }
                     //       }
                     //   Важно понимать, что этот атрибут не разместится в памяти до тех пор, пока к нему не будет применена 
                     //   рефлексия со стороны другого типа (например, где-то в недрах специальной утилиты). Переданные в конструктор
                     //   атрибуты просто сохранятся в сборке в виде блока метаданных

class AttributeDemo  // AttributeDemo - несколько дополнительных крупиц инфы, что я вычитал однажды статье
{
    [Obsolete("Too old func")]
//  [return: Obsolete("It is too old too")]       // [return:] - атрибуты можно прикреплять даже к возвращаемым значениям методов
//  //****[Obsolete] не уметь применятся к возвращаемым значения. здесь нужно вставить что-то другое
    private void FTest() { }

    [field: Obsolete("This field also too old")]  // [field:] - и к полям, что появляются при компиляции свойства тоже
    private string PTest() => "";                 // Вообще, подобные ключевые слова можно просмотреть в меню IntelliSense, что
                                                  //   может появится при наборе в [] (у этих слов своя особая метка)
}
public class VehicleDescriptionAttribute : System.Attribute  // .. : System.Attribute - не забываем, что все атрибуты должны исходить
{                                                            //   из этого класса (кстати, абстрактного)
    public string Description { get; set; }                  // sealed - по причинам, связанным с безопасностью, устоявшейся практикой
                                                             //   в .NET стало проектирование кастомных атрибутов как запечатанных
                                                             //   (но здесь эта часть была удалена, т.к. я таки намерен наследовать)
    public VehicleDescriptionAttribute() { }                 // VS - существует snippet    Attribute    , что при двойном нажатии <Tab>
                                                             //   сгенерирует класс, производный от System.Attribute
    public VehicleDescriptionAttribute(string vehicleDescription) => Description = vehicleDescription;
}                                                                   // VehicleDescription.. - вообще, атрибут будет просто хранить
                                                                    //   дополнительную строку информации для классов (т.е. мы будем
                                                                    //   привязывать экземпляры этого класса к объявлениям других типов.
                                                                    //   Это такая стандартизированная альтернатива статическому полю)
[CLSCompliant(true)]
[VehicleDescription(Description = "Roxy for everyone")]                                 // [VehicleDescription] - если бы этот класс не
                                                                                        //   наследовал System.Attribute, его нельзя было
                                                                                        //   бы здесь писать
public class Motorcycle2  // Хоть и такой синтаксис называется именованным свойством,   // Description = .. - заметь, в конструкторе нашего
{                         //   он также применяется и к полям                           //   атрибута был использован пока не виданный нами
}                         // Применятся синтаксис именованных свойств может только к    //   синтаксис "именованного свойства", что создан
                          //   тем свойствам (или полям), что допускают запись в себя   //   специально для атрибутов (работает только в
                          // Наша строка установится в свойство только когда агент из   //   []'ках у атрибутов). Мы просто пишем имя
                          //   вне с помощью рефлексии сам не заденет этот атрибут      //   свойства и через знак = его значение (не
                          // [].. - класс Motorcycle будет CLS угодым и имеющим         //   путать с именованными атрибутами, что задаются
                          //   дополнительную строку описания                           //   через символ ':'. Там это именно атрибуты
                                                                                        //   метода)
                                                                                        // Это как бы просто дополнение к основной начинке
                                                                                        //   конструктора. Поэтому ты можешь сначала задать
                                                                                        //   обычные атрибуты (и только затем их)
/////////after reading:Serialization/////////////////////////////////////////////////////////
[Serializable]
[Obsolete("Use another vehicle!")]
public class HorseAndBuggy2  // [].. - этот класс будет сериализируемым, но также и
{                            //   устаревшим
}
/////////////////////////////////////////////////////////////////////////////////////////////
[VehicleDescription("A very long, slow, but feature-rich auto")]
public class Winnebago  // [].. - а Winnebago просто будет иметь дополнительную строку описания
{                       // В итоге прямо в главном окне ildasm.exe за красными треугольниками уже видны следы использования конструкторов
}                       //   атрибутов (нашего и ObsoleteAttribute). Если открыть метаданные класса (дважды тыкнув по его части, что
                        //   начинается с .class), можно увидеть то же (но в другой форме)(пример для Motorcycle):
                        //       .class public auto ansi serializable beforefieldinit ..Motorcycle  // .. - там на деле стоит полностью
                        //              extends [mscorlib]System.Object                             //   заданное имя Motorcycle'а
                        //       {
                        //         .custom instance void ...VehicleDescriptionAttribute::.ctor() = ( 01 ... 69     // ....T..Descripti
                        //                                                                           6F ... 72     // on.Roxy for ever
                        //                                                                           79 ... 65 )   // yone
                        //       } // end of class VehiclesLibrary.Motorcycle
                        //   ****я убрал атрибут [Serializable] у него и поставил [CLSCompliant]. что выходит? вместо serializable
                        //       вставилось clscompliant?
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = true)]
public sealed class VehicleDescription_1Attribute : VehicleDescriptionAttribute   // VehicleDescription_1Attr.. - это наш новый собственный
{                                                                                 //   атрибут. Это полная копия нашего первого
                                                                                  //   атрибута, но имеющая свой атрибут, что
                                                                                  //   ограничивает область использования. Компилятор
                                                                                  //   знает об [System.AttributeUsage] и его начинке, и
                                                                                  //   поэтому не
                                                                                  //   выдаст ошибку, только если этот атрибут будет
                                                                                  //   применён к классу или структуре
    public VehicleDescription_1Attribute() { }
    public VehicleDescription_1Attribute(string vehicleDescription)  // ..Class | ..Struct - если нам нужно выбрать несколько
        : base(vehicleDescription) { }                               //   назначений перечисления AttributeTargets, то мы просто
}                                                                    //   используем битовый оператор "или" (имеющийся у этого
                                                                     //   перечисления). Оно сконструировано специально с расчётом на
                                                                     //   это (каждое его поле - это битовый флаг. Типа 00..000100..0, но
                                                                     //   как int, - это одно его поле) (интересным остаётся
                                                                     //   то, как оператор может выдавать значение перечисления,
                                                                     //   которого в типе этого перечисления нет)