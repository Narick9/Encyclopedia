/*
 * creation date  06 aug 2021
 * last change    19 aug 2021
 * author         artur
 */
using System;

class _CILExtraANDReverseEngineering
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        CILExtraANDReverseEngineering_Silent();

        Console.ReadLine();
    }
    static void CILExtraANDReverseEngineering_Silent()  //****здесь быть попытка использовать --- вместо - в комментариях
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   CILExtraANDReverseEngineering_Silent()\n");


        // Веришь ты, или нет, но понимание CIL-кода может быть полезным при постройке сложных приложений (когда стандартных средств
        //   недостаточно или они слишком неуклюжи.
        //   /////////after reading: this method//////////////////////////////////////////////////////////
        //   // например, смог бы конструировать новые сборки во время выполнения? может и смог, но .NET
        //   // поставляет более лучшее средство
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   )
        //
        // Для закрепления ясности повторю, что CIL-код - независим ни от языка, на котором он написан, ни от системы, на которой он
        //   был создан. Один и тот же CIL-код можно получить и с использованием C#, и C++/CLI, и из него получаются
        //   одинаковые программы, не зависимо от системы, где он будет использоваться (при использовании чистого .NET Core, конечно)


        // В CIL коде, подобно всякому ассемблеру, стёковым переменным память выделяется
        //   в самом начале функции (с этим связано несколько приколов). Эти участки
        //   памяти доступны для использования во время жизни этой функции


        // Хоть ты можешь работать в полной мере и не разбираясь в CIL-коде, здесь ты прочитаешь введение в его синтаксис и семантику
        //
        //
        // Young fighter course 
        //
        //       static Add(int x, int y)  // ..Add(..) - исходная функция C#
        //       {                         //
        //           return x + y;         //
        //       }                         //
        //
        //
        //       .method private hidebysin static int32 Add(int32 x,  // ..Add(..) - а это ты получишь из компилятора
        //         int32 y) cil managed
        //       {
        //         // Code size 9 (0x9)
        //         .local init ([0] int32 CS$1$0000)
        //         IL_0000: nop
        //         IL_0001: ldarg.0
        //         IL_0002: ldarg.1
        //         IL_0003: add
        //         IL_0004: stloc.0
        //         IL_0005: br.s IL_0007
        //         IL_0007: ldloc.0
        //         IL_0008: ret
        //       }
        //                                // CIL - это полноценный язык .NET со своим собственным синтаксисом, семантикой и компилятором
        //                                //   ilasm.exe (т.к. ты поставляешь готовый код, этот компилятор лишь создаст дополнительные приблуды
        //                                //   сборки, вроде манифеста, а код он просто переоформит, и затем упаковывует всё это в двоичный
        //                                //   формат. также мы видели дизассемблер ildasm.exe
        //                                //   /////////after reading: /////////////////////////////////////////////////////////////////////
        //                                //   // они оба поставляются с .NET Framework SDK
        //                                //   /////////////////////////////////////////////////////////////////////////////////////////////
        //                                //   )
        //                                // Сейчас пройдёшь через курс молодого бойца по родному языку .NET. Ты сможешь различать "директивы",
        //                                //   "атрибуты" и "коды операций" CIL. Затем пройдёт ознакомление с ролью
        //                                //   "возвратного проектирования сборок" .NET. И в завершении ты ознакомишься с пространством
        //                                //   System.Reflection.Emit и узнаешь, как можно конструировать сборки прямо в runtime
        //                                // Конечно, потребность в повседневном использовании CIL есть у очень немногих программистов (если
        //                                //   такие вообще есть), но изучение CIL может оказаться полезным. Язык CIL - это истинный и родной
        //                                //   язык платформы .NET, и всё работает на нём. Его изучение чрезвычайно интересно, да и попросту
        //                                //   говоря, чем лучше ты знаешь CIL - тем больше способен погрузиться в мир расширенной разработки
        //                                //   .NET. Вот что отличает разработчиков, разбирающихся в CIL:
        //                                //     > Они смогут дизассемблировать существующие сборки .NET, отредактировать код CIL и заново
        //                                //       компилировать их в *.exe (или *.dll) . В некоторых случаях это действительно полезный навык 
        //                                //       (скажем, для взаимодействия с расширенными средставми COM)
        //                                //     > Умеют строить динамические сборки с применением пространтсва System.Reflection.Emit (этот
        //                                //       API позволяет генерировать в памяти сборку .NET, и, если нужно, сохранить её на диск)
        //                                //     > Понимают аспекты CTS (Common Type System), что не поддерживаются высокоуровневыми
        //                                //       управляемыми языками, но существуют на уровне CIL
        //                                // CIL, кстати, разрешает иметь члены глобального уровня (так Троелсен обозвал глобальные переменные)
        //                                //   , что, не разрешены в C#
        //                                // Проще говоря, знание CIL аналогично знанию ассемблера программистом на Си и C++. Т.е. те,
        //                                //   кто разбирается в низкоуровневых деталях, способны создавать более совершенные решения и глубже
        //                                //   понимают все вещи. Готов ли ты принять вызов?
        //                                // Конечно, этот курс не претендует на всеобъемлющее руководство по CIL. Если ты хочешь именно этого,
        //                                //   то тебе стоит загрузить официальную спецификацию ECMA из сайта ECMA International (это *.pdf на
        //                                //   574стр.)
        //                                //
        //                                //
        //                                //
        //                                // .method, private.. - ну что ж, у CIL есть свой набор понятий (хотя, они похожи на уже знакомые
        //                                //   тебе концепции).
        //                                //   Например, тебе должны быть отлично знакомы эти ключевые слова, которые ты можешь посчитать
        //                                //   ключевыми словами C# (на самом деле это также правильно):
        //                                //
        //                                //         new, public, this, base, get, set, explicit, unsafe, enum, operator, partial
        //                                //
        //                                //   Тем не менее, в CIL коде каждое из этих слов имеет радикально отличающуюся семантику. Скажем,
        //                                //   enum здесь определяет производный от System.Enum тип, а this и base ссылают на текущий объект и
        //                                //   его родительский класс. Ключевое слово unsafe применяется для уставновления блока кода, что не
        //                                //   может быть напрямую отслеживаться CLR, а operator создаёт скрытый специально именованный метод,
        //                                //   который будет вызываться определённой специфической операцией в C# (такой как '+'') Разительный
        //                                //   контраст между высокоуровневым языком вроде C# и CIL добавляется также тем фактом, что в CIL не
        //                                //   просто есть общий набор ключевых слов. Лексемы, что распознаются компилятором CIL,
        //                                //   подразделяются на 3 обширные категории по их семантике. Это:
        //                                //     > директивы CIL
        //                                //     > атрибуты CIL
        //                                //     > коды операций CIL
        //                                //   Ключевые слова каждой категории выделяются отдельным синтаксисом и комбинируются для получения
        //                                //   нужной цели
        //                                //
        //                                //
        //                                //   Directives
        //                                //
        //                                //     Вот они:
        //                                //
        //                                //         .namespace .class .publickeytoken .override .method .assembly .entrypoint
        //                                //
        //                                //     Как видишь, синтаксически директивы записываются в коде с префиксом в виде точки. Эта
        //                                //         категория используется для описания общей структуры (начинки) сборки
        //                                //     Таким образом, если в твоём файле .il (а это общепринятое расширение для CIL кода) есть одна
        //                                //         директива .namespace и три .class, то компилятор сгенерирует сборку с одним пространством
        //                                //         имён и тремя классами в нём
        //                                //
        //                                //
        //                                //   Attributes
        //                                //
        //                                //     Простого объявления класса, конечно, недостаточно, мы хотим
        //                                //         задать более конкретные детали для него (кого он наследует, sealed ли он и т.д.).
        //                                //         Атрибуты CIL созданы для этого. Они почти всега присутсвуют при объявлении типов
        //                                //     Да, не стоит путать атрибуты в C# (полноценные классы) и атрибуты в CIL (что являются частью
        //                                //         языка)
        //                                //
        //                                //
        //                                //   OperationCodes
        //                                //
        //                                //     Выглядят так:
        //                                //
        //                                //         ldstr box unblox throw sizeof
        //                                //
        //                                //     Описав класс, осталось лишь добавить логику. Делается это "кодами операций". (следуя традициям
        //                                //         низкоуровневых языков) Коды операций CIL обычно имеют (..) совершенно нечитабельный вид.
        //                                //         Например, для загрузки в память переменной string применяется код операции    ldstr    
        //                                //         (почему бы не назвать этот код    LoadString    ? ****скорее всего, есть причины)
        //                                //     Стоит сказать, что некоторые коды операций CIL довольно естественно отображаются на свои
        //                                //         аналоги из C# (например, box, unbox, throw и sizeof). Как ты увидишь позже, коды операций
        //                                //         всегда находятся внутри области какого-нибудь члена (например, функции) , т.к. логика
        //                                //         может быть только там
        //                                //         Operation codes (рус. коды операций) - вот как они правильно зовуться. Троелсен использует
        //                                //         для них сокращение opcodes
        //                                //
        //                                //
        //                                //   Мы уже знаем, что для загрузки строки string в память используется код операции ldstr. Но на
        //                                //       самом деле такие лексемы - это "мнемонические эквиваленты" к двоичным кодам операций CIL.
        //                                //       Вот у нас есть простая функция сложения на C#. В терминах CIL действие сложения выражается 
        //                                //       через код операции 0X58 (и да, код операции - это числовой номер операции). Следующим идёт 
        //                                //       вычитание, реальный код операции которого выглядит как 0X59. Действие для размещения нового 
        //                                //       объекта в куче - это код операции 0X73. Именно двоичный коды операций CIL читает из сборки
        //                                //       JIT-компилятор внутри CLR
        //                                //   К счастью, для каждого двоичного кода операции CIL есть свой мнемонический эквивалент. Например,
        //                                //      вместо кода 0X58 можно писать его мнемонический эквивалент add, вместо 0X59 - более 
        //                                //      человечиский sub, вместо 0X79 - newobj. Декомпиляторы CIL (вроде ildasm.exe) как раз
        //                                //      выводят человеку не двоичные коды, а их мнемонические эквиваленты. Ты сейчас смотришь на то,
        //                                //      как ildasm.exe представляет наш метод Add() в виде кода CIL.
        //                                //   Если ты не занимаешься разработкой исключительно низкоуровневого ПО на базе .NET (например,
        //                                //     своего компилятора), то иметь дело с числовыми двоичными кодами CIL никогда не
        //                                //     придётся. Программисты .NET, говоря о "кодах операций CIL", скорее всего имеют в виду набор
        //                                //     дружественных мнемонических эквивалентов (собственно, как в этой книге), а не действительные
        //                                //     коды
        //                                //
        //                                // void [mscorlib]System.Console::WriteLine(string) - как писалось когда-то давно, в CIL коде
        //                                //   всегда используются полностью заданные имена. Теперь мы так же
        //                                //   знаем, что в каждом вызове метода следует указать ещё и тип                                          
        //                                //   возвращаемого значения и сборку в [] (и немного другой                                         
        //                                //   синтаксис принодлежности к типу)                                         
        //                                // И, как видишь, стандартные типы здесь также имеют просты имена                                         
        //                                //   (void, string и т.д.)                                         
        //                                //
        //                                // Следует сказать, что при использовании другой версии .NET Framework здесь может получится другой
        //                                //   CIL код (****где-то об этом уже писалось)
        //                                // IL_0000 --- Как ты, наверное, заметил, каждый код операции в коде предваряется лексемой в форме
        //                                //   IL_xxxx: (вроде IL_0000:, IL_0001:). Они называются "метками кода" и могут быть любой другой
        //                                //   лексемой, по твоему желанию, главное, чтобы в одном блоке не оказалось повторения. ildasm.exe
        //                                //   следует соглашению об именовании вида IL_xxxx: (но, видимо, следует своему порядку. После
        //                                //   IL_0002: в блоках кода следует IL_0006:, а дальше применяются даже буквы)
        //                                // Вообще, метки кода служат, собственно, чтобы пометить код. Есть такой код операции, что позволяет
        //                                //   переместится затем к этой метке (да, отсюда растут ноги всех циклов,
        //                                //   ветвлений и, конечно, goto). Если это не требуется, метки кода можно удалить безо всяких
        //                                //   последствий
        //                                //
        //                                //
        //                                //
        //                                // В языках .NET высокого уровня (вроде C#) предпринята попытка насколько возможно скрыть
        //                                //   низкоуровненвые детали CIL. Один из самых скрытых аспектов - тот факт, что CIL использует стёк.
        //                                //   CIL основан на принципе LIFO (First In - Last Out), и формально сущностью, что он использует для
        //                                //   хранения результатов вычеслений (не переменных), "называют виртуальным стёком выполнения".
        //                                //   Здесь ты увидишь, что CIL имеет несколько кодов операций для помещения значений в стёк (этот
        //                                //   процесс называется "загрузкой", как ни странно), а также перемещения верхнего значения стёка в
        //                                //   память (скажем, в локальную переменную)(такой процесс прозвали "сохранением")
        //                                // В мире CIL невозможно напрямую получить доступ к элементам данных, даже если это локальная
        //                                //   переменная. Вместо этого нужные данные предлагается сначала загрузить в стёк и затем (как
        //                                //   только понадобятся) извлечь их оттуда (собственно, именно эта необходимость и делает блоки CIL
        //                                //   кода выглядящеми так громоздко)
        //                                // Стоит сказать, что при компиляции CIL кода (а, как мы знаем, это происходит только при запуске
        //                                //   сборки), многие избыточные аспекты реализации оптимизируются. Если у тебя включена оптимизация
        //                                //   для проекта (Solution Explorer -> Solution '..' -> -> .. (ПКМ) -> Properties -> Build ->
        //                                //   General), то компилятор даже будет удалять разные избыточные детали CIL
        //                                //
        //                                //
        //                                // nop --- ****
        //                                // ldarg.0 --- загрузить аргумент под номером 0
        //                                // ldarg.1 --- загрузить аргумент под номером 1
        //                                // add --- взять 2'а объекта в стёке, сложить их, записать результат в стёк
        //                                // stloc.0 --- взять 1'н объект в стёке, записать в переменную с индексом 0
        //                                // ret --- наконец, выйти из функции
        //
        //
        //
        //
        //       public void PrintMessage()
        //       {
        //           string myMsg = "Hello.";
        //           Console.WriteLine(myMsg);
        //       }
        //                                      // PrintMessage() - допустим, у нас есть ещё один метод PrintMessage(), что не принимает
        //                                      //   аргументов и возвращает void. Также метод имеет локальную переменную, которую он отправит
        //                                      //   в stdout
        //
        //
        //       .method public hidebysig instance void PrintMessage() cil managed
        //       {                                                          // Если посмотреть на полученный код CIL, можно кое-что обнаружить
        //           .maxstack 1                                            //   (коды операции nop и ret, а также метки кода были убраны)
        //           .locals init ([0] string myMsg)                        //
        //           ldstr "Hello."                                         //
        //           stloc.0                                                //
        //                                                                  //
        //           ldloc.0                                                //
        //           call void [mscorlib]System.Console::WriteLine(string)  //
        //       }                                                          //
        //                                                                  // .maxstack .. --- первым делом там определяется вместимость
        //                                                                  //   стёка - 1 (директивой .maxstack 1)(компилятор csc.exe понял,
        //                                                                  //   что здесь хватит и одной записи в стёке)
        //                                                                  // .locals .. --- дальше определяется ячейка
        //                                                                  //   памяти для локальной переменной (через директиву .locals).
        //                                                                  // ldstr ".." --- затем строка с нашим сообщением
        //                                                                  //   загружается (в стёк, кодом операции ldstr)
        //                                                                  // stloc.0 --- и сохраняется (из
        //                                                                  //   стёка) в этой локальной переменной (stloc.0, 0 здесь - это
        //                                                                  //   номер ячейки с нужной локальной переменной)
        //                                                                  // ldloc.0, call .. --- дальше (с помощью ldloc.0) загружаем (в стёк)
        //                                                                  //   данные, что находятся в локальной ячейке 0 для использования
        //                                                                  //   их в вызове метода System.Console.WriteLine() (вызываем с
        //                                                                  //   кодом операций call)
        //                                                                  //
        //                                                                  // Здесь мы вызвали метод с одним аргументом, и нам достаточно
        //                                                                  //   загрузить в стёк один объект. Что, если метод будет принимать
        //                                                                  //   больше параметров? Просто записывай их всех в стёк, метод
        //                                                                  //   залпом их всех прочитает (так, что последний параметр получит
        //                                                                  //   последнюю запись в стёке, первый параметр получит первую
        //                                                                  //   запись)
        //                                                                  //
        //                                                                  // Ну и ещё, CIL на самом деле поддерживает комментарии (несколько
        //                                                                  //   раз мы это уже видели). И //, и /**/. Компилятором они
        //                                                                  //   игнорируются
        //                                                                  //


        // (ещё один блок read after разблокирован) О том, как доставать CIL код из сборок, ты теперь можешь почитать в методе о Ildasm.exe
        //
        // Если ты хочешь читать CIL код из VS Code, то ты сразу заметишь, что подстветки по умолчанию для этого языка нету. Но сообщество
        //   поставляет несколько расширений (я поставил расширение IL)


        // Reverse Engineering
        //
        //   Как ты только что узнал, ildasm.exe может не только показывать тебе код CIL из сборки, но ещё и умеет
        //       сбрасывать его в отдельный файл. Да, тебе открыт полный комплект возможностей для этого файла. Ты можешь отредактировать код в
        //       нём и затем компилировать обратно (формально, такой подход называется "обратным проектированием", или не по православному -
        //       "reverse engineering"). Это может помочь в случае:
        //             > Если тебе нужно модицировать сборку, исходный код которого недоступен
        //             > Если твой компилятор настолько плох, что генерирует недостаточно эффективный для тебя код
        //             > Если твой код должен работать с рядом атрибутов COM IDL (Interface Description Language), которые теряются при
        //               компиляции в CIL-код (вроде атрибута [helpstring])
        //
        //  Как там всё устроены, в этих *.il файлах? В энциклопедии есть проект ./ReverseEngineering_18.2.1_HelloProgram/. В этом проекте
        //     есть простой исходник и сборка к нему (компилировал я, используя csc.exe). С помощью ildasm.exe я получил
        //     ./ReverseEngineering_18.2.1_HelloProgram/ourCIL.il и ./.../ourCIL.res (в ./.../ourCIL.il есть поясняющие комментарии ко всему,
        //     что я могу пояснить)
        //
        //     Заметь, что файлы с CIL-кодом должны прямо в себе хранить инфо о всех нужных внешних сборках и самой сборке (как и в настоящих
        //     |       ассемблерах. В .NET эта часть зовётся метаданными сборки)


        // IL Program From Scratch
        //
        //   Теперь, когда мы знаем достаточно о устройстве CIL, мы попытаемся создать совершенно новую сборку на CIL, с нуля (правда,
        //     напишем мы самый минимум для компиляции, не вдаваясь в директивы и прочие атрибуты). Да, многое мы оставляем на рассмотрение
        //     компилятора. Если же ты хочешь узнать что нужно иметь в сборке, чтобы компилятор затем даже не заморачивался, то тебе следует
        //     просмотреть будущую скомпилированную сборку через ildasm.exe
        //   Файлом с нашим самописным CIL-кодом
        //     станет ./ILProgramFromScratch_18.2.2_WinFormsMessage/ourNew.il, а код в нём выведет простенький message-box с небольшим
        //     сообщением. Всё что можно было выкинуть из
        //     файла, я выкинул (а к тому, что осталось, я подробно описал причину надобности в виде комментариев)(там также есть описание
        //     ещё одного кода операций - pop)
        //  
        //   Как и говорилось, для компиляции CIL-кода используется ilasm.exe, и этот компилятор поддерживает 38 параметров коммандной строки
        //     (или примерно столько)(всех из с описанием можно просмотреть, просто введя параметр -?). Вот самые интересные:
        //  
        //     > /debug   - позволяет включить отладочную инфо (вроде имён локальных переменных и аргументов, а также номера строк). Разницы
        //                  в весе выходного файла нет (те же 2кб. В C++ разница могла быть в разы). Также генерирует одноимённый .pdb
        //                  (program database) с дополнительной debug инфо
        //     > /output  - имя выходного файла (вместе с расширением). Если опция не указана, то будет использовано имя
        //                  со входного .il-файла (но расширение файла заменится)
        //     > /dll     - выходная сборка будет .dll (т.е. устройство сборки будет по схеме dll, и, если /output не задан, то и файл)
        //     > /exe     - выходная сборка будет .exe (также внутренне, и, если не задан /output, то и файл). Это опция по умолчанию
        //     > /key     - эта опция для указания файла *.snk с открытым и секретным ключом. Сборка будет иметь строгое имя
        //     > -?       - выведет все остальный параметры с их описанием
        //  
        //   Введя
        //  
        //         ilasm /exe .\ourNew.il /output=ourNew.exe
        //  
        //     , мы получим вполне работающее приложение (а главное - на CIL!)
        //  
        //  
        //   Да, пример не особо впечатлителен, но зато мы видели один из сценариев использования применения CIL (в книге был пример
        //     вовзратного проектирования, т.к. там модифицировали существующую сборку)
        

        // PEVerify
        //
        //   После получения сборки .NET из модифицированного (или нового) кода CIL рекомендуется проверить её на правильность логики.
        //     Делается это с помощью утилиты командной строки PEVerify.exe:
        //  
        //         peverify ourNew.exe
        //  
        //     Эта утилита проверяет достоверность всех кодов операций CIL в указанной сборке. Например, CIL требует, чтобы перед выходом
        //     из функции стёк вычислений был пуст. Как говорит автор, если это будет не так, то ilasm.exe всё равно сгенерирует сборку,
        //     т.к. этого компилятора заботит только синтаксис (хотя наш код не пропускал без инструкции pop). PEVerify.exe же
        //     проконтролирует правильность семантики, и, если стёк не был опустошён к концу функции, то она уведомит нас об этом


        // Semantics and Syntax (deeper)
        //
        //   Сейчас мы чуть глубже погрузимся в детали семантики и синтаксиса. Всё это будет происходить по ходу постройки новой библиотеки
        //     кода на CIL
        //   Здесь я также создал новый файл, написал подходящий код CIL. Это ./SemanticsAndSyntaxDeeper_18.3.1_ClassLibrary/CILTypes.il.
        //     Основная информация находится там, в файле ./.../CILTypes.il, но здесь также описаны некоторые аспекты
        //
        //   Помимо .assembly CILTypes и .module (о .module рассказано в нашем ./.../CILTypes.il-файле), есть ещё и другие директивы для
        //     уточнения общей структуры создаваемого файла .NET (на самом деле их не много). Вот некоторые самые распространённые из них:
        //       > .mresources  - если код сборки использует внутренние ресурсы (вроде растровых изображений или таблиц строк), то эти
        //                        директивы должны быть применины для ссылка на имена файлов с этими ресурсами (дальше они встроятся в сборку)
        //       > .subsystem   - эта директива используется для указания предпочитаемого UI, в рамках которого желательно запускать сборку.
        //                        Например, значение 2 говорит CLR о том, что сборка должна выполнятся с графическом пользовательским
        //                        интерфейсом, а 3 - в консольном
        //  
        //   Т.к. пустое пространство имён нам не интересно, в нём были определны два класса (в ./.../CILTypes.il есть пояснения к директивам
        //     .namespace и .class). Т.к. этих классов из них наследует другой, был применён атрибут extends. Другого компилятор не пропустит
        //   Помимо атрибутов public и extends (что мы использовали), CIL имеет в своём арсенале ещё довольно много атрибутов, и все они
        //     созданы для уточнения природы своего класса (каждый из них также имеет свой код). Вот избранные:
        //       > public, private, nested assembly,   - это атрибуты для указания видимости класса. Да набор CIL более гибче, чем набор C#. О
        //         nested famandassem, nested famitly    назначении каждого из этих квалификаторов ты можешь почитать в документе ECMA 335
        //         nested famorassem, nested public
        //         nested private
        //       > abstract, sealed                    - эти два атрибута обозначают абстрактность и запечатанность класса
        //       > auto, sequential, explicit          - эти атрибуты инструктируют CLR о том, как размещать данные полей в памяти. Для обычных
        //                                               типов подходит auto. Если класс будет использовать P/Invoke для обращения к
        //                                               неуправляемому коду Си, тебе может быть удобнее использовать вместо auto что-то другое
        //       > extends, implements                 - для указания базового класса и реализуемых интерфейсов
        //       > ansi, unicode, autochar             - они задают режим маршализации (перевода в и из) строки при работе с неуправляемым
        //                                               кодом. Это режим маршализации к ansi (Си-стилю), к UTF-16 Unicode (это родной для .NET
        //                                               стандарт кодирования символов) или к тому, к которому распологает система (видимо,
        //                                               что-то из первых двух)
        //       > beforefieldinit                     - этот атрибут фактически говорит CLR о том, что она может инициализировать созданный
        //                                               экземпляр этого класса в любой момент до первого его использования. Если этого
        //                                               атрибута не будет, объект начнёт инициализироваться, как только появится нужда в его
        //                                               памяти (полях). csh.exe выставляет beforefieldinit всем класса по умолчаню
        //  
        //
        //   Если ты попробуешь скомпилировать файл на данном этапе, то сборку ты получишь, но peverify.exe выдаст вот такой список ошибок:
        //  
        //       [MD]: Error: Value class has neither fields nor size parameter. [token:0x02000007]
        //       [MD]: Error: Value class has neither fields nor size parameter. [token:0x02000008]
        //       [MD]: Error: Value class has neither fields nor size parameter. [token:0x02000009]
        //       [MD]: Error: Enum has no instance field. [token:0x02000009]
        //       [MD]: Error: Value class has neither fields nor size parameter. [token:0x0200000A]
        //       [MD]: Error: Enum has no instance field. [token:0x0200000A]
        //       6 Error(s) Verifying CILTypes.exe
        //  
        //     При запуске никаких исключений CLR не выборосит, т.к. свои типы мы ещё не использовали. Из этого выхлопа понятно, что нам не
        //     хватает начинки в
        //     типах (пока не кодов операций), но для того, чтобы её добавить, нужно сначала ознакомится с фундаментальными типами данных CIL
        //   Чтобы освободить место под новые комментарии, я создал копию имеющегося ./.../CILTypes.il и убрал оттуда их. Теперь у нас
        //     есть ./SemanticsAndSyntaxDeeper_18.3.2_ClassLibrary/CILTypes.il (да, также была создана собственная директория для нового файла)
        //
        //   А вот и, собственно, имеющиеся в .NET базовые классы  + соотвествующие ключевые слова C# + их представления в CIL. Ещё для
        //     каждого стандартного типа CIL здесь приведено его сокращённое "константное значение":
        //  
        //         Базовый тип .NET     Ключевое слово C#     Представление CIL     Константное обозначение CIL
        //         System.SByte         sbyte                 int8                  I1
        //         System.Byte          byte                  unsigned int8         U1
        //         System.Int16         short                 int16                 I2
        //         System.UInt16        ushort                unsigned int16        U2
        //         System.Int32         int                   int32                 I4
        //         System.UInt32        uint                  unsigned int32        U4
        //         System.Int64         long                  int64                 I8
        //         System.UInt64        ulong                 unsigned int64        U8
        //         System.Char          char                  char                  CHAR
        //         System.Single        float                 float32               R4
        //         System.Double        double                float64               R8
        //         System.Boolean       bool                  bool                  BOOLEAN
        //         System.String        string                string                -
        //         System.Object        object                object                -
        //         System.Void          void                  void                  VOID
        //  
        //     Да, это всё завётся именно базовыми классами (классами! Изначально это всё классы)
        //     Как ты позже увидишь, эти константы (константные сокращения CIL) часто используются в кодах операций CIL
        //   Типы System.IntPtr и System.UIntPtr в CIL коде - это те же int32 и unsigned int32 (или int64 и unsigned int64, если у клиента
        //     x64 система)(т.е. в CIL, как и в Си, тоже есть широкие возможности для применения арифметики указателей)
        //
        //   Прочитав столько файлов энциклопедии ты уже несколько раз понял, что CIL нативно поддерживает все возможности (или не очень) C#'па
        //     в плане членов для типов
        //     (для классов и структур - конструкторы, поля, методы, свойства, статические члены и т.д.. для перечислений - пары
        //     "ключ-значение"). В ./SemanticsAndSyntaxDeeper_18.3.2_ClassLibrary/CILTypes.il описаны все детали их определения (но сильно
        //     отличающийся фундамент описан здесь)
        //   Например, конструкторы. Спецификация CTS поддерживает создание конструкторов как уровня экземпляра - .ctor, так и уровня класса
        //     - .cctor (class constructor). Обе директивы должны сопровождаться атрибутами specialname и rtspecialname (return type
        //     special name). Эти атрибуты указывают на то, что текущая лексема специфична. Разные .NET языки используют разные намёки на
        //     необходимость добавления этих атрибутов. В C#, например, конструкторам не ставится возвращаемый тип (хотя на самом деле, как
        //     видишь, это void)
        //
        //   На данным момент мы имеем наброски для методов в базовом классе, небольшой набор полей также в нём, и даже готовое перечисление
        //   Интересно, что ilasm.exe замечает, что метод set_.. (который отностися к свойству MyNamespace.MyBaseClass.TheString),
        //     недееспособен. Если закомментировать определение самого свойства, то всё будет ок


        // Operation Codes
        //
        //   Все коды операций (а их достаточно много) условно
        //     разделяются на 3 обширные категории:
        //  
        //     > коды операций, что управляют потоком выполнения программы
        //     > коды операций, что вычисляют выражения
        //     > коды операций, что получают доступ к значениям в памяти (через параметры, локальные переменные и т.д.)
        //  
        //   Вот наиболее полезные коды операций, что напрямую связаны с логикой (сюда входит 1-ая и 2-ая категория)(они также
        //     сгруппированы по функциональности):
        //  
        //         add, sub, mul,       - делают сложение, вычитание, умножение, деление, нахождение остатка от деления для двух чисел
        //         div, rem               (берут две последний записи в стёке, делают дело, результат записывают в стёк)
        //         and, or, not, xor    - побитовые операции двух значений
        //         ceq, cgt, clt        - инструкции для сравнений:
        //                                ceq - сравнение на равенство
        //                                cgt - сравнение "больше ли, чем"
        //                                clt - сравнение "меньше ли, чем"
        //         box, unbox           - созданы для преобразовния значений между ссылочными типами и типами значений (берут значение из
        //                                стёка, делают дело, записывают результат в стёк)
        //         ret                  - для выхода из метода и (если надо) возврата значений вызывающему коду (значений, что находятся в
        //                                стёке)
        //         beq, bgt, ble,       - коды операций для ветвления (b - branch)(они берут два последних значения в стёке):
        //         blt, switch            beq - переход к метке кода, если равно (eq - equal)
        //                                bgt - переход к метке кода, если больше чем (gt - greater than)
        //                                ble - переход к метке кода, если меньше или равно чем (le - less equal)
        //                                blt - переход к метке кода, если меньше чем ( lt - less than)
        //         br <int32 (target)>  - перейти к метке кода (берёт запись в стёке, если она - истина, переходит). Также есть
        //                                br.s <int8 (target)> (s - short)
        //         call                 - создан для вызове члена заданного типа (смотрит сколько параметров принимает этот член, берёт столько
        //                                параметров из стёка, отправляет их в этот член. если есть результат - записывает в стёк)
        //         callvirt             - ****то же самое, но с виртуальной функцией?
        //         newarr, newobjt      - размещают в памяти новый массив или новый объект (эту новую вещь записывает в стёк)
        //  
        //   Коды операций из 3-ей обширной категории применяются для работы со стёком. Вот те из них, что созданы для заталкивания
        //     аргументов в виртуальный стёк выполнения (заметь, что все они имеют префикс ld - загрузить):
        //  
        //         ldarg <uint32> (и его        - загружает в стёк аргумент текущего метода. Он принимает uint16 число (номер)
        //         многочисленные вариации)       справа, по которому и загрузит агрумент. Как мы видели, ещё есть очень удобные вариации
        //                                        этого метода ldarg_x (ldarg_0, ldarg_1, ..). Их иногда называют Ldarg_x (Ldarg_0,
        //                                        Ldarg_1..). Как я понял, в этом случае имеют ввиду одно из статических полей
        //                                        System.Relfection.Emit.OpCodes.Ldarg_x (их всего 3. Так вот). Ещё есть
        //                                        ldarg.s <uint8 (num)> (принимает небольшое 1-байтное число, .s - short form). Получить
        //                                        адрес памяти (указатель) определённого аргумента можно через ldarga <uint16 (num)> (или через
        //                                        ldarga.s <uint8 (num)>)
        //         ldc.i4 (а также другие       - загружает в стёк константное значение (i4 - int 4 byte)(как такового кода операций ldc нет)
        //         многочисленные вариации)
        //         ldfld <typeAttr> <field>     - загружает в стёк значение поля определённого экземпляра определённого типа. Ещё есть
        //         (и многочисленные вариации)    ldflda <typeAttr> <field> для загрузки в стёк адреса этого поля и ldfldn <method> для
        //                                        загрузки указателя на функцию
        //         ldloc (и                     - загружает в стёк значение локальной переменной
        //         многочисленные вариации)
        //         ldobj                        - копирует все значения, что хранит этот объект, в стёк
        //         ldstr                        - загружает в стёк строковое значение (т.е. литерал)
        //  
        //     Вторая часть этой категории - коды операций, что созданы для получения/удаления значений со стёка. Обычно извлечённое
        //     значение сразу записывают во временную локальную переменную (или куда-нибудь ещё). Многие методы сохранения снабжены префиксом
        //     st (store - хранить). Вот некоторые распространённые:
        //  
        //         pop                       - просто удаляет значение на вехрушке стёка (т.е. не заботится о его сохранении)
        //         starg <uint16 (num)>      - берёт значение с верхушки стёка, сохраняет его в агрументе метода под заданным индексом
        //         stloc <uint16 index> (и   - извлекает значение из стёка и вставляет его в локальное хранилище (переменную) под этим индексом
        //         многочисленные вариации)
        //         stobj <typeTok>           - берёт значение типа <typeTok> из стёка, сохраняет его ****куда-то
        //         stfld <typeAttr> <field>  - берёт два значения из стёка - ссылку на объект и значение, сохраняет это значение в поле <field>
        //                                     этого обеъкта. Тип данных узнаёт из атрибута, что следует поставить после stfld (например,
        //                                         stfld string <field>    )
        //  
        //     Ко всем из них есть доступ через класс System.Reflection.Emit.OpCodes (что странно, не статический)(..OpCodes.Ldarg_0 ты уже
        //     видел в таблице)
        //   Имей ввиду, что различные коды операций CIL будут неявно извлекать значения из стёка. На самом деле довольно очевидно, что
        //     инструкция sub, например, во время своей работы достанет из стёка 2 значения, а затем запишет в стёк результат


        // LocalVariablesDefinition
        //
        //   Теперь давай слегка детальнее посмотрим на объявление локальных переменных в функциях/методах CIL. Всё описано в
        //     ./LocalVariablesDefinition_18.4.1_SimpleFuncs/SomeCILInfo.il (а если конкретнее, то в функции LocalVariables())
        //
        //
        // ParametersAndLocalVariablesDefinition_Silent
        //
        //   Пример простенькой функции сложения двух чисел также находится в ./.../SomeCILInfo.il (это функция Add(), и она снабжена
        //     пояснениями)
        //   Также не стоит забывать про то, что каждый метод первым парметром получает ссылку на свой объект (в C# этот
        //     параметр доступен через ключевое слово this)
        //
        //
        // CyclesInCIL_Silent
        //
        //   Все циклы C# (for, foreach, while, do-while) построены на простеньких операциях ветвления в CIL, чья суть походит на эпический
        //     goto (скорее наоборот, это goto походит на них). Это значит, что для чтения сколь-нибудь сложной программы уже
        //     потребуется по настоящему прямой мозг. В нашем ./.../SomeCILInfo.il есть функция, что просто выводит числа с 0 до 9 (это
        //     CountToTen(). там также есть несколько комментариев)


        // AssemblyBuildingWithCIL
        //
        //   Теперь самое время построить что-то действительно цельное, а не собранное из кусков демонстративного кода. Здесь мы построим
        //     одну .dll библиотеку с двумя типами и консольную программу типа .exe, использующую их. И всё это с текстовым редактором по
        //     своему выборку и ilasm.exe
        //   Для .dll сборки была выделена папка ./CILCarsDLL_18.5.1_TwoTypes/, для .exe - ./CILCarClientExe_18.5.2_OneType/
        //
        //   CILCarsDll
        //
        //       Собственно говоря, это и будет нашей закрытой библиотекой кода. Файл ./CILCarsDLL_18.5.1_TwoTypes/CILCars.dll имеет
        //         комментарии (помимо начинки библиотеки этой библиотеки)
        //       Как ты видишь, в коде этого файла определены два открытых класса. Первый, CILCar, - простенькая CIL версия знакомого нам Car,
        //         а второй класс, CILCarInfo, служит контейнером статического метод Display(), принимающего ссылку он экземпляр CILCar и
        //         выводящего инфо о его содержимом
        //       Для компиляции сборки из ./.../CILCars.il был задействован параметр компилятора /dll (уже не новый для нас параметр):
        //      
        //             ilasm /dll .\CILCars.il
        //      
        //         Проверка PEVerify.exe сейчас тоже выдаёт валидный результат
        //      
        //   CILCarClientExe
        //      
        //       Теперь перейдём к исполняемой части. Файл ./CILCarClientExe_18.5.2_OneType/CILCarClient.il уже будет содержать .entrypoint, а
        //         его код будет задейтствовать типы из сборки CILCars.dll
        //       После создания этой сборки нам следует как-то поместить в поле досягаемости среды CLR нашу библиотеку CILCars.dll. Т.к. эта
        //         сборка не имеет строгого имени, применять <codeBase> в config-файле приложения не удасться (а задавать его мне лень). Я
        //         просто копировал её в ./CILCarClientExe_18.5.2_OneType/ к только что созданному .exe. Так PEVerify.exe перестанет выдавать
        //         ошибку о ненахождении нужной сборки
        //       После исправления ещё пары косяков (что выдал PEVerify.exe), наше уже не монолитное приложение завершено и готово к работе


        // А ещё ilasm.exe (также, как и компилер C#) автоматически снабжает классы стандартным конструктором, если они не имеют своего
        

        // Afterword
        //
        //   Как ты понял, построение сложных приложений на CIL - это для фанатиков. Да, CIL очень гибок, т.к. он поддерживает все
        //     программные конструкции, что разрешены CTS, но, как мы видели, это дело весьмя времязатратное и больше подвержено ошибкам, чем
        //     писание на каком-нибудь C# (собственно, CIL здесь - это как-бы местный cross-platform ассемблер)
        //   Но всё-таки знанине - сила, хоть скорее всего большая часть рассмотренного материала врядли будет использована тобой в деле даже
        //     однажды


        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   CILExtraANDReverseEngineering_Silent()");
    }
}