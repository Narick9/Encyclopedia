/*
 * creation date  27 oct 2021
 * last change    17 nov 2021
 * author         artur
 */
using System;
using System.Threading;
using System.Linq;

class __CLRThreadPool_TPL
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        CLRThreadPool_Silent();
        TPL_Silent();

        Console.ReadLine();
    }
    static void CLRThreadPool_Silent()  //after System.Threading Namespace, System.Threading.Thread
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   CLRThreadPool_Silent()\n");


        // WhatItIs
        //
        //   Пула поток CLR уже упоминался пару раз
        //
        //   При асинхронном вызове метода (через BeginInvoke()) CLR не создаёт поток в прямом смысле
        //     слова. В целях эффективности BeginInvoke() задействует пул рабочих потоков, которая, если говорить вкратце, по своему организует
        //     уже имеющиеся потоки (автоматически).
        //     Для взаимодействия с этим пулом предлагается статический класс System.Threading.ThreadPool (по размерам
        //     он чуть меньше среднего)
        //   Чтобы получить поток из пула для обработки какого-нибудь метода, можно использовать ...ThreadPool.QueueUserWorkItem(). Он имеет
        //     перегрузку, которая в дополнении к экземпляру делегата ...WaitCallback (что создан специально для работы с ...ThreadPool) может
        //     принимать необязательный параметр object для последующей передачи его в метод 
        //
        //         В случае использования первой версии ThreadPool.QueueUserWorkItem() параметру object передаётся
        //         просто null
        //
        //     Если запрос прошёл хорошо, возвращается true. Если
        //     что-то пошло не так - сразу выбрасывается исключение System.NotSupportedException
        //   Сами экземпляры делегата WaitCallback могут хранить любые функции и методы, что соответсвуют сигнатуру void (object)
        //


        // Using
        //
        //void PrintNumbersParameterized(object printer)
        //{
        //    ((Printer)printer).PrintNumbers();          // (Printer)printer - вызывать метод PrintNumbers() мы будем из того объекта, что
        //}                                               //   будет нам сослан
        //
        //Printer myPrinter = new Printer();
        //for (int _ = 0; _ < 3; _++)
        //{
        //    ThreadPool.QueueUserWorkItem(new WaitCallback(PrintNumbersParameterized), myPrinter);  // myPrinter - а использовать мы будем
        //}                                                                                          //   один объект для всех вызовов
        //
        //Thread.Sleep(100);      // Thread.Sleep() - нам стоит приостановить основной поток, чтобы заврешились все второстепенные
        //Console.Write("\n\n");
        //


        // Advantages of using ThreadPool
        //
        //   Чем же выгоднее использовать пул потокв, поддерживаемый средой CLR, по сравнению с ручным созданием объектов Thread? Вот
        //     преимущества, что обеспечиваются им:
        //  
        //     > Пул потоков эффективно управляет потоками, сводя к минимуму их количество (как ты знаешь, каждый поток должен создаваться,
        //       запускаться и останавливаться, а ведь эти операции стоят процессорного времени)
        //     > Пул потоков берёт на себя управление потоковой инфраструктурой приложения, и ты можешь лучше сосредоточиться на решении
        //       своих задач
        //  
        //   Тем не менее, в некоторых случая лучше всё-таки управлять потоками вручную. Ниже есть примеры
        //  
        //     > Когда нужны потоки именно переднего плана или должен устанавливаться приоритет потока. Потоки пула всегда фоновые и обладают
        //       стандартным приоритетом (т.е. ThreadPriority.Normal)
        //     > Когда требуется гибкость, вроде возможности прервать, приостановить или находить по имени отдельный поток
        //  


        // Afterwords
        //
        //   Итак, на этом исследование пространства System.Threading завершено. Полученные отсюда сведения несомненно ценны при
        //     написании многопоточных приложений. А теперь давай переключим
        //     внимание на несколько новых аспектов, связанных с потоками, что появились в .NET 4.0. Для начала мы обратимся к альтернативной
        //     потоковой модели, что называется TPL (Task Parallel Library)


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   CLRThreadPool_Silent()");
    }
    //[System.Runtime.Remoting.Contexts.Synchronization]
    //public class Printer : System.ContextBoundObject  //****System.Runtime.Remoting.Contexts.Synchronization - не входит в .NET Core
    //{                                                 // System. - этим я делаю акцент на принадлежность сущности
    //    public void PrintNumbers()
    //    {
    //        for (int i = 0; i < 7; i++)
    //        {
    //            Console.Write("{0} ", i);
    //        }
    //    }
    //}
    static void TPL_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   TPL_Silent()\n");


        // WhatItIs
        //
        //   Ты уже знаешь 2'е технологии програмирования для создания многопоточных приложений (асинхронный вызов и члены в пространстве
        //     System.Threading
        //
        //         да, автор называет это технологиями
        //
        //     ), и обе они работают в любой версии .NET
        //
        //   Начиная с .NET версии 4 Microsoft ввели новый подход - применение библиотеки TPL (Task Parallel Library). С помощью типов из
        //     System.Threading.Tasks (все они вместе и есть TPL) можно строить мелкомодульный масштабируемый код безо всякой необходимости
        //     работать с потоками напрямую (и с пулом потоков тоже). Это небольшое пространство, и в нём всего 2'а несущих класса и набор
        //     вспомогательных к ним
        //
        //   На самом деле это не значит, что тебе не придётся использовать типы из System.Threading. Они всё ещё естественно сочетаются
        //     с TPL. Суть в том, что с TPL можно решать те же самые задачи гораздо проще (примитивы из System.Threading, вроде Monitor или
        //     Interlocked, файтически делают то же самое, что и древнейшие мьютексы из Си. System.Threading.Mutext, кстати, тоже есть)
        //   Кстати, имей в виду, что ключевые слова async и await (о которых чуть позже) базируются на разнообразных членах пространтсва
        //     System.Threading.Tasks
        //
        //   Библиотека TPL (а если точнее, типы в ней) распределяют нагрузку приложения между доступными процессорами в динамическом
        //     режиме, т.к. применяет пул потоков CLR. Также TPL может разбить работу на части, планировать потоки, управлять их
        //     состоянием и управлять ещё многими другими низкоуровневыми деталями. Т.е. начиная с .NET 4 ты можешь полностью доверится
        //     TPL, получая при этом почти максимальную производительность при этом ничего не делая (т.е. делая даже меньше, чем при
        //     работе с потоковым пулом)
        //
        //   Вообще, пространство насчитывает 17 типов
        //


        // System.Threading.Tasks.Parallel
        //  
        //   Основной класс TPL - это ...Parallel. Этот статиеческий тип имеет набор методов для итерации по коллекциям в параллельной
        //     манере. В нём определно всего 3 метода - Parallel.For(), Parallel.ForEach() и Parallel.Invoke() (но каждый из них имеет
        //     перегруженные версии. И часто много). Как ты понял, его главные методы повторяют семантику циклов for и foreach.
        //     Преимущество в том, что Parallel будет сам извлекать потоки из пула и управлять ими
        //   И Parallel.For(), и Parallel.Foreach() требуют передачи совместимого с IEnumerable или IEnumerable<T> контейнера
        //     (Parallel.For() получает i начального элемента и i конечного, а Parallel.Foreach() просто проходит по контейнеру).
        //     Вдобавок понадобится применять делегаты System.Func<T> и System.Action<T>, т.к. именно они применяются для указания кода
        //     блока
        
        // Data Parallelism of Task Parallel Library
        //
        //   Слышал ли ты когда-нибудь о "параллелизме данных"? Это когда коллекция данных делится на какие-то (обычно равные) части,
        //     каждую из которых обрабатывает свой отдельный процесс. Собственно, это и происходит в методах Parallel.For() и
        //     Parallel.ForEach()

        // Using System.Threading.Tasks.Parallel.For()/Foreach()
        //
        //****дальше идёт куча малосвязанной с текущей темой инфы, что следует перенести в методы о WPF и WinForms
        //****примеры использования находятся в проекте в директории ./SomewhatWithWinFormes_19.6.1_TPL/
        //   В документации .NET Framework 4.7 SDK приведён пример решения задачи, когда требуется загрузить в память много *.jpg
        //     изображений, повернуть их и сохранить модифицированные копии в новое место. Мы решим её с использованием графического
        //     интерфейса, чтобы взглянуть на "анонимных делегатов" (так автор прозвал делегаты с анонимными методами), позволяющих
        //     вторичным потокам обновлять поток пользовательского интерфейса
        //
        //         На самом деле доступ к окну GUI может иметь только поток, в котором он создан, т.к. элементы упровления (это кнопки,
        //           текстовые поля, метки, индиакторы хода работ и т.п.)(VS выведет исключение времени
        //           выполнения System.Runtime.InteropServices.ExternalException: 'A generic error occurred in GDI+.'). Здесь мы решим эту
        //           проблему через общие переменные, что будут изменятся вторичными потоками и читаться потоком, отвечающим за GUI. Конечно же
        //           , всё это в безопасной к потокам манере (хотя здесь это не столь критично). Когда мы узнаем побольше о async и await языка
        //           C#, будет предложен более простой подход
        //
        //   Подробнее о VS: при отладке многопоточного приложения VS часто способна перехватывать ошибки, когда вторичный поток обращается к
        //     элементам управления GUI, созданным в первичном потоке. Однако нередко при запуске того же приложения в не-Debug режиме,
        //     оно может выглядеть, как работающее корректно, не падая от этого исключения (или же ошибка может возникнуть позже). Не стоит
        //     оставлять программу с потенциальной ошибкой
        //   Автор решает создать новый проект шаблона WPF App (.NET Framework). Изначально я планировал остаться здесь и зделать всю
        //     работу для использования графики вручную (так мы бы знали все аспекты, что задействованы в ней), но изрядно помучавшись,
        //     я решил всё-таки следовать книге. В папке 19.6.1 текущего проекта будет создан новый проект, и работа будет вестись в нём
        //     (но общее описания процесса проходит здесь, в этом файле)
        //   Сама инфраструктура Windows Presentation Foundation будет подробно рассматриваться в гл.24-26, но все типы и их члены, что
        //     здесь применяется, имеют описание в моих комментариях
        //  
        //   Для начала автор приказал поместить довольно большой код в файл MainWindows.xaml (этот файл появляется вместе с проектом),
        //     сказав не заморачиваться на счёт его содержимого сейчас (мы всё-таки немало времени проведём над этм вопросом в будущем).
        //     Видимо, это код разметки содержимого окна, что будет выводить наше новое приложение. Вообще, XAML -
        //     eXtensible Application Markup Language (т.е. расширяемый язык разметки приложений)
        //   В этом файле этим кодом мы разметили окно, что будет содержать многострочное текстовое поле (в файле это область TextBox),
        //     и одну кнопку (область Button, имя кнопки - cmdProcess). Суть нашего GUI в том, что пользователь будет способен вводить
        //     туда что-то своё во время выполнения обработки картинок, и это должно демонстрировать многопоточность приложения
        //  
        //   В файле MainWindow.xaml.cs (Solution Explorer -> .. -> MainWindow.xaml -> MainWindow.xaml.cs) написан код некоторой логики.
        //     Картинки я решил взять из папки, где винда хранит обои экрана блокировки (их там немного, но они красивые)
        //  
        //   В отдном из методов применяется такой класс, как System.Windows.Threading.Dispatcher. В комментарии его метода уровня
        //     экземпляра Invoke() в общих чертах описана суть этого класса, но более обширное объяснение я напишу здесь (****здесь вырезан
        //     небольшой участок текста об STA и MTA).
        //
        //   WPF приложения всегда запускается именно в STA, и поэтому ты не сможешь обратится к его объектам (объекту окон, как у нас,
        //     например) через потоки извне (даже созданные этим главным по подразделению потоком). Когда ты стартуешь WPF приложение, в
        //     нём автоматически создаётся объект System.Windows.Threading.Dispatcher и вызывается статический метод Run() этого же
        //     класса, что и инициализирует очередь (скорее всего, эти действия производит статический конструктор)
        //   Ещё стоит сказать, что запуск WPF приложения проходит после создания средой CLR двух потоков для него:
        //  
        //     > Render thread (этот поток просто рисует графику)
        //     > UI thread (а это уже поток, что выполняет прописанную тобой логику)
        //  
        //     UI поток как раз отвечает за чтение ввода, обработку событий и вид элементов окна. WPF Dispatcher связывается именно с ним
        //   Как все объекты в WPF приложении хранят ссылку к одной очереди? Так вот - класс System.Windows.Threading.DispatcherObject
        //     всем своим предкам предоставляет поле для хранения этой очереди (он абстрактный) в виде объекта класса
        //     System.Windows.Threading.Dispatcher (а этот - запечатанный), а каждый класс WPF с уровнем экземпляра (будь то окно, кнопка
        //     или textbox) имеет его в вершине своего древа. Когда создаётся новая кнопка, её конструктором вызывается защищённый
        //     конструктор из DispatcherObject, что и инициализирует свойство Dispatcher общим для всего приложения объектом Dispatcher
        //   На самом деле напрямую работать с очередью тебе не придётся. От этого объекта Dispatcher нам нужны только два метода -
        //     Invoke() и BeginInvoke() (и оба будут описаны в книге. Invoke() уже описан)
        //  


        // System.Threading.Tasks.Parallel.Invoke()
        //
        //   Кроме возможности распараллелить обработку данных наш статический класс Parallel умеет и просто создавать кучу рабочих потоков
        //     для обработки кучи методов в асинхронной манере (каждому делегату будут выдано по потоку, если это возможно). Это делает метод
        //     System.Threading.Tasks.Parallel.Invoke()
        //   Такой подход немного проще, чем использование делегатов или пространства System.Threading (т.к. не придётся создавать циклы для
        //     запуска кучи потоков). Минус этого метода в том, что ты теряешь львиную долю возможностей контроля над создаваемыми потоками
        //     (задание ParallelOptions - предел здесь)
        //   Допустим, нам нужно загрузить публично доступную книгу из сайта проекта Гутенберга (www.gutenberg.com) и выполноть над ней
        //     некоторые действия (имей ввиду, что если ты не заходил раньше на этот ресурс, то с первого раза загрузить данные не получится,
        //     т.к. на этой странице выйдет ненужное нам окно с сообщением)
        //
        //
          System.Net.WebClient myWC = new System.Net.WebClient();  //****WebClient - этот довольно большой класс предоставляет набор методов
          string theEBook = string.Empty;                          //   для отправки и получения данных по заданному URI ресурсу (uniform
          bool isComplete = false;                                 //   resource identifier) (URI вмещает в себя всем известный URL и ещё
        //   isComplete - чтобы наш (главный) поток мог дождаться  //   URN). Определение этого типа находится в System.dll. На самом деле
        //     второстепенного, был создан этот маркер. Как        //   класс имеет не очень много основных методов, но каждый из них имеет
        //     оказалось, ..Monitor и ..Mutex не могут             //   ещё несколько специальных версий и события ..Completed). Например,
        //     заблокировать свой поток (если поставишь два        //   myWC.DownloadString() имеет версию myWC.DownloadStringAsync(),
        //         ..Monitor.WaitOne(...);    друг за другом, они  //   задействующую пул потоков (и мы её будем использовать). По завершению
        //     не остановят поток                                  //   этот асинхронный метод запустит события myWC.DownloadStringCompleted
                                                                   // На самом деле сейчас мы не станем разбирать инет-составляющую часть
                                                                   //   .NET, просто автор решил этим заглянуть наперёд
        //
          myWC.DownloadStringCompleted += (sender, exArgs) =>      // myWC.DownloadStringCompleted - как понятно из названия, этот event
              {                                                    //   произойдёт, когда операция асинхронной загрузки завершится. Имя этого
                  theEBook = exArgs.Result;                        //   событие - DownloadStringCompletedEventHandler, а прототип -
                  Console.WriteLine("Download complete");          //   void ..(object sender, DownloadStringCompletedEventArgs e)
                  GetStats();                                      // exArgs.Result - сам по себе класс DownloadStringCompletedEventArgs
              };                                                   //   определяет одно свойство -    public string Result { get; }    (что
                                                                   //   возвращает прочтенную страницу в виде (обычно) гигантской строки.
                                                                   //   Остальные несколько свойств достаются от предков
                                                                   // myWC.DownloadStringAsync() - это один из основных методов объектов
                                                                   //   System.Net.WebClient. Он загружает данные по определённому URI в
                                                                   //   отдельном потоке (и поэтому возвращает void). Как раз для того, чтобы
                                                                   //   обработать результат, мы и подготовили event чуть выше
        //
          myWC.DownloadStringAsync(new System.Uri("http://www.gutenberg.org/files/98/98-8.txt"));
          Console.WriteLine("Downloading the book...");            // myWC.DownloadStringAsync() - основная логика этого метода будет
                                                                   //   запущена во второстепенном потоке, который, в свою очередь,
                                                                   //   задействует множество других потоков для загрузки
          void GetStats()
          {
              string[] words = theEBook.Split(new char[] { ' ', '\u000A', ',', '.', ';', ':', '-', '?', '/' },
                  System.StringSplitOptions.RemoveEmptyEntries);   // theEBook.Split() - как понятно из названия, этот метод разделяет строку
                                                                   //   на множество мелких. Эта перегрузка принимает массив символов, по
              string[] tenMostCommon = null;                       //   которым строка и будет резаться, и значение перечисления
              string theLongestWord = string.Empty;                //   System.StringSplitOptions (в нём всего 2-а поля - наше и None)
              System.Threading.Tasks.Parallel.Invoke(              // \u000A - юникодовский (UTF-16) символ новой строки
                  () => tenMostCommon = FindTenMostCommon(words),
                  () => theLongestWord = FindLongestWord(words));
        //
              System.Text.StringBuilder bookStats = new System.Text.StringBuilder("Ten Most Common Words are:\n");
              foreach (string curr in tenMostCommon)               // ..StringBuilder - ты не забыл про этот тип строк?
              {                                                    //   StringBuilder'ы способны меняться (и это небольшой класс)
                  bookStats.AppendLine(curr);                      // bookStats.AppendLine() - как Console.WriteLine(), но выход добавляется
              }                                                    //   в объект StringBuilder
              bookStats.AppendFormat("Longest word is: {0}", theLongestWord);
              bookStats.AppendLine();                              // bookStats.AppendFormat() - работает как String.Format() (и этим также
                                                                   //   похож на одну из перегрузкок Console.WriteLine())
        //
              Console.Write("{0}\n", bookStats.ToString());        // Console.Write() - на самом деле автор имел в строке кода ещё и это:
                                                                   //       .., "Book info");    , что никак ни на что не влияет
        //
              isComplete = true;
          }
          string[] FindTenMostCommon(string[] words)
          {
              var frequencyOrder = from word in words
                                   where word.Length > 6           // where word.Length > 6 - сразу отсеиваем некрупные слова
                                   group word by word into g
                                   orderby g.Count() descending    // g.Count() - этот расширяющий метод выдаст нам число символов в строке g
                                   select g.Key;                   //   . Исходит он из статического класса System.Linq.Enumerable. Как мы
              return frequencyOrder.Take(10).ToArray();            //   помним, такие классы могут иметь расширяющие методы
                                                                   // descending - как мы помним, этим ключевым словом LINQ мы
                                                                   //   добиваемся сортировки контейнера от большего к меньшему
                                                                   // g.Key - выдаст элемент из контейнера, т.е. строку
                                                                   // frequencyOrder.Take() - этот расширяющий метод оставит нам столько
                                                                   //   элементов из всейго контейнера, сколько мы скажем (а сказали мы 10)
          }
          string FindLongestWord(string[] words)
          {
              return (from w in words orderby w.Length descending select w).FirstOrDefault();
          }                                                        // (from..).FirstOfDefault() - выдаст или первый элемент в контейнере, или
                                                                   //   значение по умолчанию того те типа (default(int), например.
                                                                   //   default(string) выдаст null. Да, мы раньше ты не видел этого)
        //
        //
          while (!isComplete)  // while (!isComplete) - пока что это всё, что мы можем
          {
              Thread.Sleep(50);
          }


        // Afterwords
        //
        //   Завершение исследования TPL мы отметим баловством с ещё одним способом встраивания параллельности в приложения .NET
        //         /////////after reading: PLINQ////////////////////////////////////////////////////////////////
        //         // Речь идёт о PLINQ
        //         /////////////////////////////////////////////////////////////////////////////////////////////
        //


        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   TPL_Silent()");
    }
}