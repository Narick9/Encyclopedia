/*
 * creation date  26 oct 2021
 * last change    26 oct 2021
 * author         artur
 */
using System;
//using System.Runtime.Remoting.Contexts;  //****такого namespace'а нету в .NET Core (и .NET 5)

class _ObjectContextsANDItsStuff
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        ObjectContextsANDItsStuff_Silent();

        Console.ReadLine();
    }
    static void ObjectContextsANDItsStuff_Silent()  //after Domains,; before [Synchronization]
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   ObjectContextsANDItsStuff_Silent()\n");


        // WhatIsIt
        //
        //   Каждый домен внутри может быть дополнительно разделён на контекстные границы. По существу, с помощью контекстных границ .NET
        //     одиночный домен может установить "контейнер для специфичных объектов" внутри себя. Такое разделение
        //     объектов создано для того, чтобы CLR могла обеспечить надлежащую и согласованную обработку сильно отличающихся объектов (да, для
        //     работы с некоторыми типами CLR должна выполнять некоторые требования). В runtime CLR будет просто перехватывать обращения
        //     одного контекста к другому (к его начинке) и перестравивать эти обращения для работы в новых условиях. Например, если у тебя
        //     есть класс с пометкой атрибута [Synchronization] (для тебя это пока что просто рандомный атрибут), то при создании его
        //     экземпляра CLR спроектирует синхронизированный контекст, поместя в последствии новоиспечённый экземпляр туда
        //   Структуры контекстов не нова. Ещё при создании компонентов COM+ в железном веке использовались контексты COM+. Контексты в .NET
        //     делали по их образу, и они очень похожи
        //   Каждый процесс имеет стандартный домен, а каждый домен имеет свой "стандартный контекст". Такой стандартный контекст (иногда
        //     называемый "контекстом 0") группирует в себе объекты, что не имеют каких-то особых требований на этапе runtime (т.е.
        //     подавляющее большинство объектов попадают в контекст 0)
        //   Вот как выглядит полная схема работы процесса .NET (точнее - как может выглядить):
        //  
        //         ┌─────────────────────────────────────────────────────────────────────┐
        //         │  Одиночный процесс .NET                                             │
        //         │                                                                     │
        //         │   ┌───────────────────┐┌───────────────────┐┌───────────────────┐   │
        //         │   │    Стандартный    ││       Домен       ││       Домен       │   │      
        //         │   │       домен       ││    приложения 1   ││    приложения 2   │   │
        //         │   │     приложения    ││                   ││                   │   │
        //         │   │                   ││                   ││                   │   │
        //         │   │ ┌───────────────┐ ││ ┌───────────────┐ ││ ┌───────────────┐ │   │
        //         │   │ │  Стандартный  │ ││ │  Стандартный  │ ││ │  Стандартный  │ │   │
        //         │   │ │    контекст   │ ││ │    контекст   │ ││ │    контекст   │ │   │
        //         │   │ └───────────────┘ ││ └───────────────┘ ││ └───────────────┘ │   │
        //         │   │ ┌───────────────┐ ││ ┌───────────────┐ ││                   │   │
        //         │   │ │  Контекст 1   │ ││ │  Контекст 1   │ ││                   │   │
        //         │   │ └───────────────┘ ││ └───────────────┘ ││                   │   │
        //         │   │ ┌───────────────┐ ││ ┌───────────────┐ ││                   │   │
        //         │   │ │  Контекст 2   │ ││ │  Контекст 2   │ ││                   │   │
        //         │   │ └───────────────┘ ││ └───────────────┘ ││                   │   │
        //         │   └───────────────────┘└───────────────────┘└───────────────────┘   │
        //         │                                                                     │
        //         └─────────────────────────────────────────────────────────────────────┘
        //  
        //   В то время, как понимание процессов и доменов может хоть как-то помочь в реальных условниях, работать с контекстами объектов
        //     почти никогда не приходится. Как говорит автор, обзор материала по объектным доменам здесь приводится лишь для полной картины


        // Для справки. Атрибут [Synchronization] - полное имя System.Runtime.Remoting.Context.SynchronizationAttribute


        // ContextFree and ContextBound Types
        //
        //   Объекты, что не нуждаются в какой-то контекстной трактовке, называются контекстно-свободными (и попадают в контекст 0). Такие
        //     объекты доступны из любой точки домена и не требуют какой-то работы со стороны CLR. Только такие объекты ты пока что и видел
        //   Если тебе нужен тип, экземплярки которого действительно требует выделения контекста (такой тип будет называться
        //     "контекстно-связанным"), то ты
        //     должен декорировать его нужным тебе контекстным атрибутом (в библиотеках .NET их всего 2). Эти атрибуты - это пометки для CLR
        //     того, что экземпляры этого типа сбособны работать только в своём контексте. Контекстные атрибуты следует применять только к
        //     типам, что являются System.ContextBoundObject (т.к. CLR не будет переносить экземпляры  из контекста в контекст только этого
        //     типа)
        //
        //   Сами атрибуты для пометки контекста расширяют класс System.Runtime.Remoting.Context.ContextAttribute
        //   Классы-контексты делаются реализацией интерфейса System.Runtime.Remoting.Context.IContextAttribute, а для описания требований к
        //     CLR этого контекста, нужно поддерживать ещё и System.Runtime.Remoting.Context.IContextProperty (эти интерфейсы находятся на
        //     особом счету у CLR). System.Runtime.Remoting.Context.ContextAttribute реализует их обоих
        //
        //   Если по каким-то причинам какой-то контекстно-связанный объект попадёт в контекст, в котором не будут удовлетворятся его
        //     требования, то тогда обязательно произойдёт что-то неприемлемое (причём, ЧСХ, в самый неподходящий момент)


        // ContextBoundType Using
        //
        //   Допустим, нам нужен класс SportsCarTS, и при этом он должен быть безопасен к потокам (но мы не хотим вручную закодировать в нём
        //     логику этой синхронизации, ведь нам лень возится с потоками). Благодаря декорированию его атрибутом [Synchronization] и
        //     причислению класса
        //     ..ContextBoundObject к его предкам, мы можем быть увереными, что с его экземплярами не случится непредвиденностей (а
        //     представь, что бы могло произойти с подобными производственными объектами в небезопасном к потокам контексте!)
        //   Для наглядности был создан ещё один класс - SportsCar, но он контексто-свободен
        //
        //new SportsCarTS();  // new SportsCarTS() - конструктор этого класса выведет некоторую полезную информацию для нас
        //new SportsCar();    // new SportsCar() - конструктор этого котнекстно-безопасного класса сделает то же самое (тем же кодом). Здесь
        //new SportsCar();    //   было создано два объекта типа SportsCar, из конструкторов обоих мы узнали, что оба этих объекта находятся
        //                    //   в контексте 0
        //                    // При выполнении можно увидеть, что в обоих контекстах имеется свойство LeaseLifeTimeServiceProperty. Это
        //                    //   свойство представляет собой низкоуровневый аспект уровня удалённой обработки .NET и может быть
        //                    //   проигнорированно
        //                    //****всё закомменчено, т.к. класс System.Runtime.Remoting.Contexts.SynchronizationAttribute
        //                    //    не входит в .NET Core (.NET 5)


        // Afterword
        //
        //   Да, в этой главе материал был довольно низкоуровневым, но не забывай, что по большей части среда CLR сама заботится о всех
        //     деталях процессов, доменов приложений и контекстов. Однако знание того, как они работают, формирует хороший фундамент для
        //     понимания многопоточного программирования на платформе .NET


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   ObjectContextsANDItsStuff_Silent()");
    }
    //[MySynchronization]                     // [..] - этим атрибутом мы сделаем наш класс контекстно-связанным, и его экземпляры попадут
    //                                        //   в контекст для объектов, требующих безопасности при работе с потоками (этот контекст
    //                                        //   будет создан при первом появлении экземпляра SportCarTS). Т.к. класс SportsCar будет
    //                                        //   унаследован от SportCarTS, а атрибут [Synchonization] действует и на дочерние классы, я
    //                                        //   сделал свой собственный атрибут-пустышку, наследующий ..SynchronizationAttribute, но не
    //                                        //   действующий на классы, что находятся ниже в древе наследования
    //                                        // Просто создать конструктор в SportsCar, а
    //                                        //   затем унаследовать его в тип ниже было нельзя, т.к. тип ниже не может наследовать два
    //                                        //   нужных ему класса
    //class SportsCarTS : ContextBoundObject  // SportsCarTS - наш потокобезопасный класс (TS - Thead Safe)
    //{                                       // : ContextBoundObject - благодаря унаследованию этого типа CLR не будет двигать объект в
    //                                        //   другие контексты, и объект останется в благоприятном для себя контексте
    //    public SportsCarTS()
    //    {
    //        Context currContext = System.Threading.Thread.CurrentContext;                               // ctor() - для наглядности мы
    //        Console.WriteLine("{0} object is in context {1}", this.ToString(), currContext.ContextID);  //   здесь выведем свойства
    //        Console.WriteLine("Here are all properties of this context");                               //   контекста, в котором будет
    //        foreach (IContextProperty curr in currContext.ContextProperties)                            //   находиться новый объект
    //        {                                            // ..CurrentContext - это статическое свойство // ..Context - объекты этого класса
    //            Console.WriteLine("-> {0}", curr.Name);  //   класса ..Thread выдаст тебе контекст, в   //   могут хранить инфо о неком
    //        }                                            //   котором работает текущий поток            //   контектсе. Это крохотный класс
    //        Console.WriteLine();                         // ..ContextProperties - этим {get;} свойством // ..ContextID - здесь будет
    //    }                                                //   мы получим все свойства (требования)      //   выведено, что мы находится в
    //}                                                    //   полученного контекста (автор называет их  //   контексте 1
    //                                                     //   дескрипторами)                            // curr - мы получим массив
    //                                                     // curr.Name - просто название свойства (метод //   крохотных типов (в них всего
    //                                                     //   ToString() не переопределён и выводит     //   3 новых члена)
    //                                                     //   просто полное имя типа объекта)           //
    //class SportsCar : SportsCarTS        // SportsCar - этот класс не будет потокобезопасным
    //{
    //    public SportsCar() : base() { }  // : base() - а его конструктор также выведет полезную инфу о текущем для объекта контексте
    //}
    //[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]  // [System.AttributeUsage] - ты же помнишь этот
    //                                                                                    //   атрубут для атрибутов, верно?
    //class MySynchronizationAttribute : SynchronizationAttribute  // ...SynchronizationAttribute --- имеется лишь в составе .NET Classic и
    //{                                                            //   Xamarin-версиях
    //}
}  