/*
 * creation date  26 jun 2021
 * last change    26 jun 2021
 * author         artur
 */
using System;

class _GC_Finalize_SystemIOStream
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");


        Console.ReadLine();
    }
    static void GC()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   GC()\n");


        // Как мы знаем, исполняющая среда .NET (также известная как CLR) заботится о управляемой куче (куда попадают все экземпляры классов)
        //   без твоего вмешательства. Говоря точнее, этой частью занимается часть CLR, что называется Garbage Collector (GC, т.е. сборщик
        //   мусора). Вообще, золотое правило по управлению памятью в .NET выглядит просто: "Используй new, чтобы разместить объект класса в
        //   управляемой куче, и забудь о нём". После создания объект будет автоматически удалён сборщиком мусора, когда в нём отпадёт
        //   необходимость. Как именно он узнаёт нужный момент? Если говорить кратко, то это он следит за досягаемостью этого объекта. Если на
        //   него не будет указывать ни одна ссылка в коде - значит он недосягаем, и его следует удалить
        // Если хочешь подробностей - добро пожаловать в блоки моего текста ниже


        Car myCar = new Car();  // myCar - это локальная переменная с ссылкой на объект в куче. Т.к. эта ссылка за пределы текущего метода не
                                //   выходит (а переменная ожидаемо сдохнет в стёке), объект оказывается навсегда потерянным для твоего кода, и
                                //   он станет кандидатом на удаление (т.е. мусором)
                                // new - это ключевое слово транслируется в CIL-код как инструкция newobj
                                // GC управляется кучей довольно тщательно, при необходимости даже сжимая пустые блоки памяти для
                                //   оптимизации. На самом деле при инструкции newobj среда уже знает где будет размещён этот новый объект,
                                //   т.к. назначила себе указатель ещё при прошлом использовании (да, GC здесь занимается ещё и выделением
                                //   памяти). Сам процесс newobj выглядит так:
                                //   1. среда (точнее, GC) подщитывает нужный объём памяти для этого нового объекта
                                //   2. после этого она выясняет, действительно ли в управляемой куче по указанному адресу (что она получила
                                //      в конце прошлого использования) есть такой длинный и свободный участок памяти. Если да, то вызывается
                                //      конструктор этого объекта
                                //   3. прежде, чем передать ссылку вызывающему коду, переместить указатель на следующую доступную область
                                //      памяти в управляемой куче (как я понял, этот указатель будет нацелен байт, что после объекта)
                                // "Если при обработке инструкции newobj среда CLR поймёт, что для нового объекта уже нет места, то она
                                //   проведёт очистку мусора, пытаясь освободить достаточно памяти". Это было второе правило. Однако то,
                                //   как именно будет происходить сборка мусора, зависит от версии платформы .NET, что используется в данный
                                //   и момент. О работе сборщика мусора (или, вернее, Garbage Collector'а) - ниже


        Car myCar1 = null;  // = null - это действие переведётся в CIL-код немного по-другому (не как обычное присваивание). Вместо вызова
                            //   конструктора вызовется ldnull, что заталкивает значение null в стёк, а затем stloc.X запишет этот null в
                            //   переменную


        // Во время процесса сборки среда CLR (точнее, её часть - сборщик мусора) строит граф объектов, содержащий
        //   каждый досягаемый объект (сборщик мусора не будет строить по несколько связей на один объект). Те объекты,
        //   чьи "корневые элементы" не попали в граф (корневой элемент - это место в памяти, что хранит ссылку, вернее,
        //   указатель на объект в управляемой куче), считаются мусором
        // После удаления мусора, оставшееся пространство в куче сжимается (все данные объектов переносят в начало кучи,
        //   чтобы полсле них получилось что-то вроде длиннющего массива свободной памяти), и это, в свою очередь, вынуждает
        //   CLR модифицировать набор активных корневых элементов программы (т.е. указателей), чтобы они стали ссылаться
        //   на новое правильное место. Ну и последнее - указатель на следующий новый объект тоже обновляется, чтобы
        //   указывать на новое свободное место


        // Строго говоря, среда использует две отдельные кучи, одна из которых предназначена специально для хранения
        //   крупных объектов (это зовётся LOH, Large Object Heap, и принимает она объекты, что больше 85000 байт).
        //   LOH после очистки мусора не сжимается, и в этом её суть (передвижение таких больших данных, когда таких
        //   объектов много, снижает производительность). Тем не менее, можно безопасно считать, что управляемая куча
        //   - это цельная область памяти


        // Когда среда CLR пытается найти недостежимые объекты, она не проверяет буквально каждый объект в управляемой куче. Это
        //   потребовало бы значительного времени. Для содействия в этом каждому объекту в куче назначается пометка поколения. Идея
        //   проста: чем дольше объект в куче (точнее, чем больше сборок мусора он пережил), тем выше вероятность того, что он там будет
        //   оставаться. Например, объект рабочего стола будет в памяти вплоть до завершения приложения. С другой стороны, те объекты, что
        //   создавались в методах, скорее всего не будет досягаем за его пределами. Каждый объект в куче причисляется к одному из
        //   перечисленных ниже поколений:
        //   > Поколение 0  - это те объекты, что появились после последней сборки мусора (т.е. сборщик мусора их ещё не видел)
        //   > Поколение 1  - к этому поколению причесляются те, что уже пережили одну сборку мусора (поколения 0 и 1 ещё называеются
        //                    эфемерными (с фр. недолговечными)
        //   > Поколение 2  - это объекты, что пережили больше одной сборки мусора (т.е. как минимум 2-е на их счету имеется)
        //
        // Сначала сборщик мусора исследует объекты 0-го поколения. Если после завершения удалось освободить требуемый объём, то все
        //   уцелевшие объекты повышаются до поколения 1. Если все объекты поколения 0 проверены, но всё-ещё нужна дополнительная память,
        //   то тогда проверку на досягаемость проходят объекты поколения 1. Уцелевшие объекты этого поколения повышаются до поколения 2.
        //   Если всё-ещё требуется дополнительная память, то обрабатываться начинает поколение 2. Объекты этого поколения, что уцелели,
        //   уже не переходят на следующие, а также относятся к поколению 2. Таким механизмом и достигается нужный эффект
        // Т.к. объекты в поколении 0-ль часто находятся друг за другом, их очистка происходит наиболее быстро
     

        // До .NET 4.0 испольняющая среда производила очистку, используя приём параллельной сборкой мусора. Согласно ей для эфемерных
        //   поколений (т.е. поколения 0 и 1) при сборке мусора временно приостанавливались все потоки приложения, что гарантировало
        //   невозможность их доступа к управляемой куче во время уборки (но параллельность не в этом). К счастью, тот сборщик мусора был
        //   хорошо оптимизирован, поэтому такие короткие перерывы были заметны редко (если вообще когда-либо). В качестве оптимизации такая
        //   параллельная сборка мусора позволяля очищать объекты поколения 2 в отдельном потоке, не останавливая при этом ход приложения. Это
        //   сокращало (хоть и не устраняло) необходимость в полномасштабном цикле отсеивания
        //
        // Начиная с .NET 4.0 машина сборки мусора ведёт себя иначе и зовётся теперь фоновой сборкой мусора. Начинает она работать сразу
        //   с поколением 2 (****здесь другой смысл?), при этом (несмотря на название) также останавливая ход программы. Фоновость здесь в том,
        //   что эфемерные поколения здесь обрабатываются в одном или нескольких отдельных потоках (если у тебя сервер - в нескольких), когда
        //   это понадобится. Если в поколении 0 достаточно много объектов, то среда CLR выполняет так называемую высокоприорететную сборку
        //   мусора для поколения 0 или 1. Это выглядит так: выделенный для фоновой сборки поток постоянно следит в частых и
        //   безопасных для сборки мусора точках за тем, не появился ли запрос на проведение высокоприоретеной чистки, и, если это так, то
        //   фоновые и вместе с ними пользовательские потоки приостанавливаются на время, пока она не завершится. Стоит понимать, что этот
        //   механизм также постоянно оптимизируют, и стоит радоваться тому, что эту работу делаешь не ты


        // И всё-таки, в .NET возможны утечки памяти


        // Управляемые объекты при своё создании получают уже затёртую к 0-лям память, поэтому их конструкторам не нужно 


        // Поумолчанию, 32-битные системы выдают каждому процессу по 2GB управляемой кучи. Хотя, эти 2GB - это всего-лишь часть общей
        //   компьютерной управляемой кучи (получается, процессы делят между собой общую доступную кучу)


        // В сборке mscorelib.dll есть статический класс System.GC, через который можно управлять сборкой мусора вручную. Да, скорее всего
        //   этим в реальных проектах никто не занимается (разве что если нужно работать с кодом на неупровляемых языках). Вот
        //   некоторые полезные статичные методы оттуда:
        //   > AddMemoryPressure(),        - позволяют указывать для нового объекта количество использования им неуправляемой памяти (т.е.
        //     RemoveMemoryPressure()        давления на память). Это говорит сборщику мусора о том, что этот объект следует удалять срочнее.
        //                                   Эти методы используются в тандеме (друг за другом): первый вызывается после создания объекта,
        //                                   использующего неупровляемую память, а второй во время его уничтожения (после освобождения
        //                                   этой неуправляемой памяти). Это нужно, чтобы CLR вела более точный учёт использования памяти пк
        //   > Collect()                   - этот метод запускает сборку мусора прямо сейчас. Этот метод перегружен для стандартной уборки,
        //                                   уборки в конкретном поколении, уборки в конкретном поколении в специальном режиме, та же
        //                                   уборка, что и предудущая, но с установкой полной фоновости, где это возможно, и то же, что
        //                                   последнее, но с заданием сборки только кучи для малых объектов. Всего 5-ть версий
        //   > CollectionCount()           - выдаёт число уже проводившихся сборок мусора в заданном поколении
        //   > GetGeneration()             - выдаёт номер поколения, к которому отностися заданный объект
        //   > GetTotalMemory()            - выдаёт оценочный объём занятой кучи в данный момент. Принимает bool, что указывает на то,
        //                                   нужно ли сначала провести полную (!) сборку мусора, чтобы дать точный результат
        //   > MaxGeneration               - это свойство выдаёт максимальное число поколений в текущей сборке (с .NET 4.0 это 2)
        //   > SuppressFinalize()          - просит CLR не вызывать метод Finalize() заданного объекта
        //   > WaitForPendingFinalizers()  - /////////after reading///////////////////////////////////////////////////////////////////////
        //                                   // приостанавливает текущий поток до тех пор, пока не финализируются все уже начавшие (в
        //                                   // потоке уборки) финализацию объекты. Обычно вызывается сразу после метода Collect()
        //                                   /////////////////////////////////////////////////////////////////////////////////////////////
        Console.WriteLine("Estimated bytes on heap: {0}", System.GC.GetTotalMemory(false));    // ..GetTotalMemory(false) - выводим
        Console.WriteLine("And accurate: {0}", System.GC.GetTotalMemory(true));                //   примерный объём занятой кучи
        Console.WriteLine("This OS has {0} object generations", System.GC.MaxGeneration + 1);  // ..GetTotalMemory(true) - а здесь точный
        Car myCar3 = new Car("Zippy", 80, 120);                                                // ..MaxGeneration + 1 - т.к. нам выйдёт
        Console.WriteLine("myCar is {0}", myCar3);                                             //   номер наибольшего поколения, а
        Console.WriteLine("The generation of myCar: {0}\n", System.GC.GetGeneration(myCar3));  //   отсчёт идёт с нуля
                                                                                               // ..GetGeneration(myCar3) - вывод
                                                                                               //   поколения myCar (это должно быть 0.
                                                                                               //   System.GC.GetTotalMemory(true) вызывался
                                                                                               //   раньше, чем появился этот объект, поэтому
                                                                                               //   myCar3 сборки мусора ещё не видел)


        System.GC.Collect();                   // Collect() - если ты входишь в блок кода, что не должен прерываться, ты можешь
        System.GC.WaitForPendingFinalizers();  //   запустить сборку мусора заранее, чтобы среде CLR не взбрендило это сделать там
        // Collect(..) - здесь мы не вызвали   // WaitForPending() - сразу после сборки дожидаемся её полного завершения. Лучше делать
        //   ту версию метода, что запускаяет  //   это всегда после принудительной сборки, т.к. это гаранитрует недоступность к
        //   сборщик мусора на стандартных     //   методам объекта, который в данный момент уничтожается (к методам, видимо, можно
        //   настройках (что запускаяется сам) //   обращатся без ссылки на сам объект)
        //
        // Во всех других версиях этот System.GC.Collect() принимает 1-ым параметром int значение поколение. Вторым же параметром ты можешь
        //   задать значение перечисления System.GCCollectionMode для выбора нужного тебе режима сборки. Всего режима три:
        //       public enum GCCollectionMode
        //       {
        //           Default;    // Default - настрйки по умолчанию. Текущим по умолчанию считается Forced (т.е. Default - это 2-ое имя Forced)
        //           Forced;     // Forced - при этом режиме сборка начинается немедленно
        //           Optimized;  // Optimized - при этом режиме среде позволяется сначала проверить, подходящий ли сейчас момент для
        //       }               //   начала сборки мусора
        //   GCCollectionMode - также находится в mscorlib.dll в пространстве System
        object[] tonsOfObjects = new object[50000];     // tonsOfObjects - здесь мы просто занимает большой кусок управляемой кучи (пока что
        for (int i = 0; i < 50000; i++)                 //   простыми ссылками)
            tonsOfObjects[i] = new object();            // new object() - память под каждый выделятеся здесь
        //
        System.GC.Collect(0, GCCollectionMode.Forced);
        System.GC.WaitForPendingFinalizers();
        //
        Console.WriteLine("The generation of myCar: {0}\n", System.GC.GetGeneration(myCar3));  // ..GetGeneration(myCar) - т.к. ссылка на этот
        if (tonsOfObjects[9000] != null)                                                       //   объект ещё действует, этот объект
        {                                                                                      //   переживает уборку и переходит в поколение 1
            Console.WriteLine("The generation of tonsOfObjects[9000] is {0}",                  // tons[ofObjects[9000] - то же самое происходит
                                System.GC.GetGeneration(tonsOfObjects[9000]));                 //   и с каждым объектом в этом массиве
        }

        Console.WriteLine("Gen 0 has been swept {0} times", System.GC.CollectionCount(0));  // ..CollectionCount() - при этом показатели
        Console.WriteLine("Gen 1 has been swept {0} times", System.GC.CollectionCount(1));  //   показывают обратное. Метод
        Console.WriteLine("Gen 2 has been swept {0} times", System.GC.CollectionCount(2));  //   GetTotalMemory(true) выполняет аж две сборки
        Console.WriteLine();                                                                //   мусора по каждому поколению, а метод Collect()
                                                                                            //   по умолчанию выполняет сборку мусора по всем
                                                                                            //   поколениям


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   GC()");
    }
    static void Finalize()  /////////after reading///////////////////////////////////////////////////////////////////////
    {                       // Finalize() - не называй так методы, это может перебить вызов одноимённого метода
                            //   Finalize()
                            /////////////////////////////////////////////////////////////////////////////////////////////
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Finalize()\n");


        // Как мы узнали, в System.Object определён виртуальный метод Finalize(), правда, он там ничего не делает:
        //       public class Object
        //       {
        //           ...
        //           protected virtual void Finalize() {}
        //       }
        // Стоит понимать, что этот метод ты тоже, скорее всего, не будешь переопределять в своих классах, т.к. создан он для уборки именно
        //   неуправляемых ресурсов (вроде низкоуровневых файловых дескрипторов, низкоуровеного управляемых подключений к базе данных, просто
        //   фрагментов неуправляемой памяти и т.д.). В рамках .NET неуправляемые ресурсы тоже можно получить - путём прямого обращения к
        //   API-интерфейсу текущей ОС с применением служб вызова платформы (или Platform Invocation Services, P/Invoke) или в сложных
        //   сценариях взаимодействия с COM
        // Сделан этот метод так, что его будет использовать сборщик мусора перед уничтожением объекта из памяти (а не пользователь. Он для
        //   этого и был помечен как protected, и ты это изменить не сможешь)
        // Ещё этот метод будет вызываться в случае выгрузки домена приложения из памяти


        SomeUnmanagedResourceWrapper my = new SomeUnmanagedResourceWrapper();  // my - финализатор (выглядит как деструктора) запустится
                                                                               //   при его вызове сборкой мусора, что будет при завершения
                                                                               //   приложения


        // Метод, где мы сейчас находимся, имеет имя Finalize(). VS, видя это, предупреждает, что он будет вмешиваться в вызов деструктора


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Finalize()");
    }
    class SomeUnmanagedResourceWrapper                         // SomeUnmanagedResourceWrapper - сделаем вид, что этот класс
    {                                                          //   испольует какие-то неуправляемые ресурсы
        ~SomeUnmanagedResourceWrapper()                        // ~SomeUngovern..() - как ни странно, использовать ключевое слово
        {                                                      //   override для переопределения метода Finalize() нельзя. Для этого
            Console.Beep();                                    //   в C# существует синтаксис деструктора (такой же в C++). Причина
        }                                                      //   этого в том, что при использовании финализатора компилятор
    }   // Финализатор (т.е. деструктор) в каждом классе (о    //   добавляет внутрь неявно переопределённого метода Finalize() много
        //   структурах позже) всегда неявно защищённый        //   обязательных элементов инфраструктуры (т.е. он всё-таки override'ится)
        //   (protected), что отличает его от конструкторов    // Если посмотреть CIL-код этого деструктора, то можно увидеть, что наш   
        //   (где модификатор доступа задаётся явно). Также он //   код попал в метод Finalize() вместе с дополнительныйми инструкциями,
        //    не получают параметров и не перегружаются        //   и всё это в try-блоке. После него идёт блок finally с некоторыми
        // При размещении объекта в управляемой куче CLR       //   дополнительными инструкциями и вызовом метода Finalize() базового
        //   автоматически определяет, поддерживает ли он      //   класса. finally-блок гарантирует, что вне зависимости от возникшых
        //   специальный метод Finalize(), и, если да, то      //   исключений будет вызван деструктор базового класса
        //   помечает его как финализируемый, а ссылку на него // Переорпеделить метод Finalize() (т.е. поставить деструктор) в структурах
        //   сохраняет во внутренней очереди, называемой       //   нельзя, т.к. вызвать их некому. Отношения к куче они не имеют и, от этого,
        //   очередью финализации (она создана для хранения    //   никогда не подвергаются сборке мусора (а метод Finalize() больше никто
        //   объектов с этим методом)                          //   не будет трогать)
        // Когда сборщик мусора решает, что объекты пора       /////////after reading//////////////////////////////////////////////////////////
        //   уничтожить, он просматривает каждую запись в      //   Тем не менее, неуправляемые ресурсы можно освободить методом Dispose()
        //   очереди финализации и копирует их из кучи в ещё   ////////////////////////////////////////////////////////////////////////////////
        //   одну управляемую структуру под названием "таблица // Как ты уже понял, финализация добавляет довольно нехилой работы 
        //   объектов, доступных для финализации". На этой     //   среде CLR, да и ты сам будешь не очень рад делать дополнительную
        //   стадии создаётся отдельный поток для вызова       //   работу, возясь с деструктором и освобождением памяти внутри него.
        //   методов Finalize() из этой таблицы при следующией //   В общем, ещё раз скажем о том, что неуправляемые ресурсы
        //   сборки мусора (да, финализация объектов требует   //   лучше применять тогда, когды ты точно знаешь, что они - это лучший
        //   по меньшей мере 2-е сборки мусора)                //   выбор (хотя, иногда других путей всё-таки)
        // ..Beep() - это только для демонстрации. Конечно, в  //
        //   реальных проектах финализаторы должны освобождать //
        //   любые местные неуправляемые ресурсы и не          //
        //   взаимодействовать с другими объектами (и внешними //
        //   , и внутритиповыми), т.к. нет гарантии того, что  //
        //   они ещё существуют                                //
    static void SystemIOStream()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   SystemIOStream()\n");


        // Класс System.IO.Stream (не sealed) - среднинький абстрактный класс, представляющий общий интерфейс для работы с последовательностью
        //   байтов. Ты можешь удивиться, но данные с таких вещей, как звук, файл и даже ввод с клавиатуры - это всего-то поток байтов (в
        //   unix'ах роль потоков берут на себя файлы. Так что поток звука хранится так же, как и поток клавиатурного ввода). Правда,
        //   каждый приёмник такого потока должен знать как именно считывать и работать с этими байтами


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   SystemIOStream()");
    }
}