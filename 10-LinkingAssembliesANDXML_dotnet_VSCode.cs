/*
 * creation date  01 jan 2020
 * last change    28 aug 2021
 * author         artur
 */
using System;
using System.Numerics;
using System.Reflection;

class LinkingAssembliesANDXML_dotnet_VSCode
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        LinkingAssembliesANDXML_Silent();
        dotnet_Silent();
        VSCode_Silent();

        Console.ReadLine();
    }
    static void LinkingAssembliesANDXML_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   LinkingAssembliesANDXML_Silent()\n");


        // Чтоб использовать начинку уже имеющейся сборки (а годятся как .dll, так и .exe),   
        //   нужно сначала подключить её
        // Как именно? В Solution Explorer в Solution '..'.. -> .. есть узел References, хранящий список ссылок на сторонние библиотеки кода
        //   (т.е. на сборки)(если узла References у тебя нет, но остальное всё впорядке, то можно точно сказать, что твой проектик кто-то
        //   сляпал вручную через кое какую штуку
        //   /////////after reading:dotnet////////////////////////////////////////////////////////////////
        //   // через dotnet cli. Такие проектики работают только с
        //   // .NET Core. VS'ка знакома с такими обрубками, и предоставляет узел Dependencies ->
        //   // Packages, чтоб ты возился с NuGet'ами, а не сборками из GAC. Если очень нужен именно
        //   // полноценный framework, то смени целевой framework своего проекта, можно через .csproj.
        //   // Так у тебя появиться узел Dependencies -> Assemblies, что работает как References
        //   // ****но ты позже вернул значение целевого проекта обратно на net5.0, а узел Dependencies -> Assemblies остался
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   ). Сборки показаны без своего расширения (без .dll). Чтобы добавить новую ссылку на внешнюю сборку оттуда,
        //   достаточно
        //   нажать ПКМ по узлу -> Add Reference... . Так откроется Reference Manager, в списке Assemblies которого представленны несколько
        //   категорий сборок. Но, как ты, возможно, мог заметить (если эксперементировал), твоих самопальных сборок там не появляется. Это
        //   потому что в Reference Manager список доступных GAC'овских BCL библиотек как-бы уже зашит (****точно ли зашит? развёрнутые туда
        //   сборки не появляются в списке?). (как ты помнишь) Все сборки из GAC разделяемые, и поэтому подключаются они без копирования в
        //   папку твоего приложения
        // Для подключения своей кастомной сборки нажми на Browse... и найди нужный её .dll/.exe файл. Как ты понял, эта сборка будет
        //   подключена как закрытая (и тебе придётся таскать её за своим .exe/.dll)
        //   /////////after reading:dotnet////////////////////////////////////////////////////////////////
        //   // . Про то, как это делается через dotnet cli, рассказано в методе про dotnet cli (если
        //   // конкретно, в блоке про подраздел dotnet add).
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   . Знай, что подключаемый проект должен быть нацелен на совместимый с текущим фреймворком фреймовок! Как правило, достаточно, чтоб
        //   этот второй фрейморк был такой же и более высокой версии (но иногда Microsoft'цы таки сбрасывают legacy)
        // Помнишь про фундаментальную библиотеку mscorlib.dll? Ну так вот, она настолько фундаментальная, что даже не отображается в списке
        //   References, а если попытаться её подключить через Reference Manager, то он выдаст окно с ошибкой, говорящей, что эта сборка итак
        //   всегда автоматически подключена
        // Разные шаблоны для проектов имеют свой список ссылок на внешние сборки (т.е. у проектов по этим шаблонам узел '..".. -> .. ->
        //   References уже будет наполнен этими ссылками). Самый чистокровный проект ты получишь из шаблона Empty Project
        //*****(у Solution Explorer'а в узле будет лишь некий Analyzers


        Phones.Phone freeMassage = new Phones.Phone();
        freeMassage.number = "+74953740752";  // Всё выглядит как и раньше, но теперь мы применяем типы из отдельной сборки,
                                              //   а не просто файла (сборку OtherProject.dll, которую я подключил, обслуживает
                                              //   проект ./OtherProject/OtherProject.csproj. Это закрытая сборка). Хоть директория этого
                                              //   проекта и находится в директории нашей энциклопедии, для компа это обычные
                                              //   разные несвязанные друг с другом проекты. Подключать их надо всё также
                                              //   вручную (директория ./OtherProject/ с проектом OtherProject.csproj - это что-то
                                              //   вроде гаража для сборки OtherProject.dll)
        // Что именно происходит при добавлении таких кастомных сборок? Посмотрев в папку,
        //   где появляется итоговая программа (по умолчанию в VS это ..\bin\Debug\
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // . Если проект dotnet cli'овский, то ./bin/Debug/.net5.0(или другая версия)/
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   )(это можно посмотреть, если в Solution Explorer с помощью Switch Views,
        //   чья иконка справа от картинки домика, переключить его в режим папки)
        //   можно увидеть, что VS копирует туда эту .dll сборку (как ты понял,
        //   получается, что OtherProject.dll - это закрытая сборка, и это стандартное
        //   поведение VS делать подключаемую не из GAC сборку закрытой)
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // . При связывании проектов через dotnet add reference происходит ровно то же
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // Про то, почему сборки должны быть или рядом, или в определённом месте в системе ты уже знаешь (в методе про Assembly и GAC
        //   об этом писалось)
        // Собственно, благодаря тому, что основная сборка  //
        //   сейчас лежит вместе с дополнительными, CLR     // От этого получаем, что если копировать dotnetCoreVersion.exe без его .dll'шек в
        //   очень легко запускает их вместе (они же все    //   какой-нибудь другой каталог и запустить, прямо в консоли выйдет небольшая
        //   рядом). Основной .exe с необходимыми для него  //   трассировка об ошибке, говорящяя о том, какие .dll файлы не найдены
        //   .dll'ками можно копировать в любую другую      // Библиотека кода OtherProject.dll, базирующаяся в проекте
        //   папку, и это всё будет работать                //   ./OtherProject/OtherProject.csproj, не использует ничего, что бы запрещалось
        //   /////////after reading///////////////////////////   CLS. Так что эту сборку вполне можно использовать из какого-нибудь
        //   // (на Linux'ах там нужно копировать ещё       //   Visaul Basic (я гарантирую это)
        //   // автоматически создаваемую директорию        //
        //   // runtimes, ..deps.json и                     //
        //   // ..runtimeconfig.json ****что это за файлы?  //
        //   //                                             //
        //   //                                             //
        //   /////////////////////////////////////////////////
        // Полное удостоверение закрытой сборки в манифесте //
        //   клиента (например, какой-нибудь сборки 14.3)   //
        //   выглядит так:                                  //
        //       .assembly extern '14.2'                    //
        //       {                                          //
        //         .ver 1:0:0:1                             //
        //       }                                          //
        //   '14.2' здесь - это "дружественное имя", или    //
        //   просто название модуля (используемого файла),  //
        //   содержащего свой манифест, без файлового       //
        //   расширения .dll ('' используются, т.к. имя     //
        //   начинается с цифры, наверное). Среда CLR не    //
        //   смотрит на версию закрытых сборок (так         //
        //   как вряд ли в папке приложения окажется        //
        //   несколько версий). Чуть более подробные        //
        //   примеры ты найдёшь в основном файле про        //
        //   манифест                                       //


        // Исполняющая среда (aka CLR) для поиска закрытых сборок использует приём под названием "зондирование". Зондирование здесь в том, что
        //   твоё приложение как-бы посылает запрос файловой системе на поиск нужного файла (а ищем мы сборки). Строго говоря, зондирование
        //   может быть "явным" и "неявным"
        // Что за неявное зондирование? Это когда CLR сама (вообще без тебя) при запуске твоей програмули
        //   заглядывает в манифест, чтоб выяснить местонахождения используемых сборкок по маркерам .assembly extern ****местонахождения там
        //   также прописываются?
        // Явный запрос загрузки производится прямо в коде, используя кое-какой класс
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // (класс System.Reflection.Assembly. Подключить сборку прямо в runtime можно его методами
        //   // Load() или LoadForm() 
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //
        // Что именно происходит при зондировании? Например, в манифесте прописана сборка '14.2'
        //   (в этом имени чисто циферки, поэтому в манифесте это имя обёрнуто в ''). Среда CLR
        //   извлекает это дружественное имя сборки из манифеста и начинает зондирование каталога в поисках
        //   14.2.dll. Если найти 14.2.dll не удасться CLR попытается найти 14.2.exe. Если
        //   файл сборки всё ещё не найден, CLR будет искать подкаталог
        //   клиентской папки с тем же дружественным именем (например, .\14.2\)
        //   и попытается найти нужную сборку там. Если зондирование прошло неуспешно, CLR прогу не
        //   запустит, а вместо этого расплачется тебе в cmd о фейле


        // Да, развёртывание приложения можно сделать и простым копированием всех нужных сборок в одну папку, но часто хочется сделать
        //   несколько подкаталогов. Например, хотелось бы создать подкаталог MyLibs для хранения
        //   SomeLib.dll (да, для одной разделяемой сборки выйгрыша в файл-менеджменте не будет, но это пригодится когда их будет за 20).
        //   Но CLR не станет зондировать эту папку, если только не предоставить ей "конфигурационный файл"
        // Что это? Сейчас поясню. Для сборок (и закрытых, и разделяемых) могут быть созданы эти самые "конфигурационные файлы",
        //   содержащие XML. Этими XML-файламы ты указываешь среде CLR машины, где это приложение будет запускаться, какие именно папки нужно
        //   "зондировать" для нахождения требуемых закрытых библиотек кода (можно как просто указать среде полный путь к папке для их поиска,
        //   так и даже задать сетевой ресурс или URL-адрес, откуда всё это следует скачать. На самом деле ещё есть возможность добыть их и с
        //   просто другой машины, не сервера), какие их
        //   версии нужно использовать и много чего другого (всё это можно указать даже для нескольких устанавлиающихся программ, если их
        //   больше одной). Такие файлы должны иметь то же имя <имяЭтойСборки>.exe.config (например, SomeApp.exe.config). Чтоб CLR нашла
        //   такой файл, он должен быть в той же директории, что и запускаемый .exe
        //
        // Файл 14.3.exe.config - пример config-файла, что я написал для работы .exe файла проекта 14.3 (в этом файле много поясняющих
        //   комментариев, что также являются частью энциклопедии). Если конкретно, то в нём описывается <privatePath>
        //
        // Файл 14.6.exe.config - а это копия config-файла, что был использован в проекте 14.6 (и комменты с инфо там тоже есть). Если
        //   конкретно, то там применяется элемент "<codeBase>". Этим
        //   элементом задаются так называемые "кодовые базы" (так это обозвали надмозги, но лучше было перевести как "базы для кода")
        // Если в <codeBase> указано местоположение на другой машине, то нужная сборка в ней будет загружена by CLR в специальный каталог
        //   внутри GAC твоей машины, который называется "хешем загрузки" ("download cache")(понятно, что такая сборка должна иметь строгое
        //   имя, т.к. в GAC только такие и можно устанавливать). Просмотреть содержимое хеша загрузки можно с помощью gacutil.exe с
        //   параметром /ldl (видимо, list of downloaded libraries, или что-то в этом духе):
        //       gacutil /ldl
        // В msdn я видел упоминание о хэше загрузки только на одной странице
        // <codeBase> может применяться для зондирования сборок, не обладающих строгими именами. Правда, в силу этого придётся ограничится
        //   папкой клиента (и её подкаталогами) (так элемент <codeBase> станет просто заменой <privatePath>)
        //
        // На самом деле при создании проекта VS по мимо прочего создаётся и файл App.config
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // (dotnet cli такое не проивзодит)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   . Эта возможность сильно упращает тебе жизнь, ведь при компилировании проекта App.config будет автоматически скопирован в
        //   .\bin.\Debug\ под
        //   именем проекта + .exe.config (т.е. тебе лучше работать именно с ним, а не вручную тоскать за собой свой ..exe.config). Этот файл
        //   необязателен и его можно удалить из проекта (а также можно и создать заново через меню Add New Item или Add File). В нём сразу по
        //   умолчанию записан набор стартовых элементов (если создавать этот файл вручную, то будет только <configuration> и заголовок перед
        //   ним)
        //
        // Если сборка развёрнута в GAC, то в .config-файле можно не использовать для неё элемент <privatePath> (****и <codeBase>?)(ведь CLR в
        //   поисках сборки сначала идёт в GAC, и только затем читает ..exe.config)
        //
        // Конфигурационный файл пригождается для разделяемых сборок. Ты можешь задать в .exe.config нужную тебе версию каждой GAC-сборки
        //   , и CLR последует за этим файлом. Это очень поможет, когда ты захочешь заставить приложение работать с более новыми библиотеками,
        //   а всё перекомпилировать возможности нет (напомню, что инфо с версиями и хеш-кодом открытого ключа для каждой подключаемой сборки
        //   находится в манифесте текущей сборки. Может, ты таки найдёшь способ изменить эти строчки в нём?)
        // Файл App14.5.config - пример такого config-файла, что был использован в проекте 14.5. Вот что я писал в проекте 14.5:
        //   //SharedAssembly_.SharedAssembly.Main();  // Main() - изначально сборка привязана к 14.4.dll старого образца (т.е. версии
        //   //                                        //   1.0.7567.41025, что не выводит .._v2), но, т.к. мы подставили конфигурационный файл
        //   //                                        //   с определёнными настройками, будет использоваться 14.4.dll версии 2.0.0.0 (здесь
        //   //                                        //   использовался файл App.config проекта. Там также есть мои комментарии)
        //   //                                        // Если убрать этот конфигурационный файл из папки с получившимся 14.5.exe (можно просто
        //   //                                        //   переименовать), то приложение будет вызывать старую версию библиотеки из манифеста
        //   //                                        // Следует иметь ввиду, что при каждой компиляции VS сбрасывает ссылки. У автора это
        //   //                                        //   привело к тому, что его новоскомпилированное приложение связалось с CarLibrary.dll
        //   //                                        //   версии 2.0.0.0 (****но какже жёсткая привязка по строгому имени?)
        //
        // Вот что я писал в проекте 14.6:
        //   // var myBottle = new Assembly14_5_1.Bottle("antiperspirant", 0.5f);  // Assembly14_5_1 - на этот раз будет использоваться
        //   // Console.WriteLine();                                               //   специально сделанная не строгоименованная сборка
        //   //                                                                    //   Bottle.dll версии 3.0.0.0, конструктор которой теперь
        //   //                                                                    //   выводит "version 3.0.0.0". Сама сборка находится в
        //   //                                                                    //   подпапке .\BinLibs\ клиента, но, т.к. в config-файле
        //   //                                                                    //   прописан путь к ней, CLR находит эту сборку, и всё
        //   //                                                                    //   проходит как и задумывалось


        // С одной программой всё понятно - достаточно подставить ей .config файл для перенаправления на более новые сборки. Но что если
        //   тебе нужно, чтобы вообще все программы подключались к новой версии библиотеки? Подстановка одинаковых конфигурационных файлов
        //   к каждой станет кошмаром сопровождения. Для этой проблемы есть решение - "сборки политик издателя". Политика издателя (по
        //   Microsoft Docs это просто Publisher Policy) - это, по
        //   сути, та же разделяемая сборка, что находится в GAC, но хранящая конфигурационный файл формата .xml, что содержит те же настройки
        //   перенаправления, что и в обычных конфигурационных файлах (т.е. мы также просто обходим некоторые настройки манифеста). При этом
        //   CLR обрабатывает сборки политик по особому, не считая их библиотеками кода. При запуске какого-то приложения, связанного с
        //   одной из версий сборки, для которой есть политика издателя, CLR увидит эту политику в GUC и последует xml-настройкам в ней
        //
        // Сборки политик издателя создаются в командной строке с использованием утилиты .NET al.exe (assembly linker). Она поддерживает
        //   множество параметров, но построение сборки политик затрагивают только несколько из них:
        //   > /link  - этим параметром указывается файл *.config или *.xml, содержащего инструкции перенаправления
        //   > /out   - этим указываем имя результирующей сборки политики издателия. Выходной файл должен следовать чёткому шаблону:
        //              policy.<старший номер заменяемой сборки>.<её младший номер>.<дружественное имя этой сборки>.dll. Начинать с Policy..
        //              тоже можно (автор и msdn топят за policy, при этом в GAC все официальные сборки начинаются с Policy)
        //   > /keyf  - здесь задаётся файл *.snk для подписания её издателя. Издатель решает, как всем следует пользоваться его сборками
        //   > /v     - этим указываем версию политики
        //
        // Вот что я писал при создании проекта 14.5:
        //   // Специально для тестирования я создал проект BottleLib (он находится в подпапке этого проекта)(в энциклопедию я его копировал в
        //   //   папку ./BottleLib14.5.1/), сборка которого будет содержать
        //   //   простой класс бутылки. Сначала в GAC была развёрнута её версия 1.0.0.0, в которой конструктор класса Bottle выводит
        //   //   "version 1.0.0.0". Сразу же после этого была развёрнута и BottleLib.dll версии 2.0.0.0 (в проекте также есть комментарии).
        //   //   Проект 14.5 связан с её первой версией, но чтобы все приложения использовали её последнюю версию, будет развёрнута и сборка
        //   //   политики издателя для неё. Вот как её можно создать (если ты находишься в папке подпроекта BottleLib):
        //   //
        //   //       al.exe /link:Policy14.5.1.xml /out:policy.1.0.BottleLib.dll /keyf:..\..\14.4_SharedAssemlby\myVSKeyPair.snk /v:1.0.0.0
        //   //
        //   //  Да, файл myVSKeyPair.snk - это моя официальная подпись издателя (точнее его ключи)
        //   // Получившийся файл policy.1.0.BottleLib.dll теперь можно развернуть в GAC как и другие строгоименованные сборки (т.е. через
        //   //   gacutil.exe)
        //   //
        //   // var myRexona = new Assembly14_5_1.Bottle("antiperspirant", 0.25f);  // new ..Bottle() - выведет version 2.0.0.0 (т.к. моя
        //   // Console.WriteLine("myRexona is {0}\n", myRexona);                   //   сборка политик перенаправляет все запросы на
        //   //                                                                     //   Bottle.dll версии 1.0.0.0 на Bottle.dll версии
        //   //                                                                     //   2.0.0.0)
        //   // Допустим, ты решил развернуть одну такую сборку политик издателя вместе с новой версией библиотеки на какой-то из клиентских
        //   //   машин.
        //   //   Как это обычно бывает, 9 из 10 приложений, что используют одну из старых версий твоей библиотеки, привязались к новой версии
        //   //   без ошибок, но 1 (по ряду причин) при попытке её использовать терпит неудачу (как говорит автор, почти невозможно создать
        //   //   по с полной обратной совместимостью, которое бы функционировало в любых ситуациях). В таком случае для проблемного клиента
        //   //   ты можешь создать конфигурационный файл, что содержит настройки для игнорирования любых файлов политик издателя (т.е. CLR при
        //   //   запуске этой проги будет брать именно те сборки, что прописаны в манифесте). Вот что должно быть внутри:
        //   //
        //   //       <configuration>
        //   //           <runtime>
        //   //               <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
        //   //                   <publisherPolicy apply="no" />  // <publisherPolicy> - этот элемент должен иметь атрибут apply, которому
        //   //               </assemblyBinding>                  //   назначена "no"
        //   //           </runtime>
        //   //       </configuration>
        //   //
        //   //   После этого CLR будет загружать только те версии разделяемых сборок, что жёстко указаны в манифесте


        //****конфиг-файл и XML
        //   контейнерный тег - отличается от обычного тем, что заканчивается символом >, а не />
        //   конечный тег - например, </Ellisple>
        //   XML чувствителен к регистру символов
        //   Свойства. Каждое из них имеет имя, за которым после знака равенства следует значение
        //   < - называется мега
        //****копировано из App14.5.config: <!-- Здесь стоит пробел потому, что xml нe допускает вклинивание   -->
        //                                  <!--   чего-то неподходящего (т.е. комментарий) в тег              -->
        //****украдено С 14.3.exe.config: <!-- XML чувствителен к регистру символов                            -->


        // Do it manually, Nuget
        //
        //   Вообще, добавлять ссылки можно и вручную, правя файл файл проекта ..csproj (на самом деле Reference Manager
        //     /////////after reading: dotnet///////////////////////////////////////////////////////////////
        //     // и dotnet add
        //     /////////////////////////////////////////////////////////////////////////////////////////////
        //     делает ровно то же самое ****но это не точно). Например, вот как выглядит часть .csproj файла этой энциклопедии в данный момент:
        //         <Project Sdk="Microsoft.NET.Sdk">
        //           ..
        //           <ItemGroup>
        //             <PackageReference Include="System.Windows.Extensions" Version="5.0.0" />  // Version=".." - здесь ты можешь поиграться
        //             <PackageReference Include="Newtonsoft.Json"/>                             //   Например, задав "6.*", после каждого
        //           </ItemGroup>                                                                //   resolving (разрешения зависимостий) ты
        //                                                                                       //   будешь получать последнюю 6.x.x версию
        //           <ItemGroup>                                                                 //   /////////after reading: dotnet///////////
        //             <ProjectReference Include="OtherProject\OtherProject.csproj" />           //   // (о том, когда происходит resolving
        //           </ItemGroup>                                                                //   // написано в методе о dotnet
        //                                                                                       //   /////////////////////////////////////////
        //         </Project>                                                                    //   . Ещё можно задать range'и. Например,
        //                                                                                       //   "[1.3.2,1.5)" - братю последнюю доступную
        //                                                                                       //   версию от 1.3.2 (включая) до 1.5.* (не
        //                                                                                       //   включая)
        //                                                                                       
        //   Что именно мы подключаем к нашему проекту? - другой проект или "NuGet пакет". Что за NuGet? Тут нужно немного истории.
        //     Microsoft'цы, не желая чтобы их новое и ещё неиспорченное поделие (.NET) использовалось легко не только в разработке, но также и
        //     в распространении, решили создать к нему простенький distribution механизм (т.е. чтоб сборки одного чувака легко могли
        //     использоваться другим чуваком вообще на другой машине). NuGet пакет - это просто zip файл со сборкой. Эти NuGet пакеты
        //     создаются/удаляются/постятся/подключаются/обновляются/.. через набор утилит, что и доступны через утилиту dotnet
        //     /////////after reading: dotnet///////////////////////////////////////////////////////////////
        //     // (все специфичные для NuGet команды вынесены в подраздел dotnet nuget)
        //     /////////////////////////////////////////////////////////////////////////////////////////////
        //     . Постятся пакеты в специальные интернетные сервера, что вместе составляют репозиторий
        //   Как видишь, мелкомягкие не долго думая просто скоммуниздили схему распространения пакетов с gnu/Linux'овский пакетный менеджеров.
        //     Но, стоит сказать, подошли они к этому основательно. У Microsoft есть кошерная онлайн морда для репозитория с пакетами
        //     (https://www.nuget.org), где у каждого пакета есть страница со всякой инфой (это статистика, лицензия, автор, инструкции,
        //     пояснения, github страница...)
        //  Все NuGet пакеты подключаются из GAC'а. Если пакета там нет, dotnet add попытается найти его в репозитории и скачать туда
        //     ****но это не точно. сборки этих пакетов в linux копировались прямо в папку ./bin/../
        //   BCL сборки, кстати, также подключаются к проектам как NuGet пакеты****это вроде только в gnu/linux'ах. у .csproj, что управляется
        //     reference manager'ом элементов <PackageReference../> и <ProjectReference../> нет. там что-то другое
        //
        //
        //   Как оказалось, репозиторий Microsoft'а даже имеет место для частных пакетов (а как же иначе, это Micro$oft). Если твоя компания не
        //     хочет делится своими наработками, она будет хранить свои NuGet пакеты в своей непубличной части https://www.nuget.org'а
        //
        //   В .NET Docs пишет не репозиторий NuGet, а "реестр" (register) NuGet
        //
        //   NuGet пакет можно держать и локально, в виде (..) пакета (т.е. файла). Ты можешь затем установить этот пакет ****также через
        //     dotnet cli?. Обычно разработчики играются именно с локальным пакетом, и только затем, когда будут уверены в его надёжности,
        //     публикуют его в общий реестр NuGet
        //
        //  


        // Понятно, что такие самопальные сборки из GAC'а будут подключатся также, как и другие разделяемые сборки (вроде System.Data.Linq)
        //   . Всё также делается через окно Reference Manager (Solution Explorer -> References (пкм) -> Add Reference...), разве что нужно
        //   явно тыкнуть в file-менеджере на нужный файл в GAC (****через Browse?). Тем не менее, ты можешь тыкнуть на тот же файл в любой
        //   директории. Да, мы так подключаем закрытые сборки, но, нажав на Solution Explorer -> References -> [нужная сборка] (пкм) ->
        //   Properties и в этом окне изменить свойство Copy Local с True на False, можно отключить автокопирование сборки в проект (это не
        //   приведёт к тому, что CLR будет обращатся к этому файлу. Мы просто говорим VS не копировать сборку в проект, а найдёт ли её CLR -
        //   это твоя забота. CLR может подключать сборки только из GAC или где-то из каталога приложения)
        // Как оказалось, подключать можно только .dll библиотеки


        //SharedAssembly_.SharedAssemlby.Main();  // SharedAssembly_ - да, в качестве подопытного здесь используется проект 14.4. Если
                                                  //   перейти в каталог ..\bin\Debug, то 14.4.dll ты там не увидишь
        // На самом деле, т.к. энциклопедия       // При добавлении ссылки на сборку с манифестом, что имеет .publickey, VS считает, что
        //   переносная, у себя ты сборку         //   она вскоре развёрнута в GAC, поэтому не заботится о копировании её двоичного
        //   14.4.dll не найдёшь. Поэтому код,    //   файла (правда, у меня сборка 14.4.dll по умолчанию таки копируется)
        //   что выше, закоментированн


        // Логично, что строго именованная сборка должна пользоваться только другими строго именованными библиотеками (ведь сборка,
        //   имеющая владельца не должна содержать ничейные части, верно?)


        //****в методе про manifest что-то поднобное уже было вначале
        // Как мы видели, при задании строгого имени сборке в её манифест записывается полное значение открытого ключа. Добавить здесь
        //   можно то, что при подключении такой строго именованной сборки клиентом, в его менифесте в блоке .assembly extern появляется
        //   маркер .publickeytoken, обозначающий хеш-код от полного открытого ключа. Здесь у нас ровно такой случай, вот что получилось:
        //       .assembly extern '14.4'
        //       {
        //         .publickeytoken = (C6 0D 3B 45 98 54 73 36 )                         // ..;E.Ts6
        //         .ver 1:0:7567:41025
        //       }
        //   Ничего не напоминает? Этот же номер записан и в подкаталоге сборки в GAC! Насколько я понял, CLR при поиске сборки в GAC
        //   ищет каталог с подходящим именем (т.е. на котором написана подходящая версия и правильный хеш-код от открытого ключа)
        //   /////////after reading:Exceptions////////////////////////////////////////////////////////////
        //   // . Если среде не удалось найти подходящую сборку в GAC (и закрытую сборку у себя в
        //   // каталоге), то она сгенерирует FileNotFoundException
        //   /////////////////////////////////////////////////////////////////////////////////////////////


        // Если добавить ссылку на библиотеку классов в меню Solution Explorer, при этом не задействовать типы из пространства этой сборки
        //   , то она будет проигнорирована, и её не будет в списке требуемых в этом манифесте (using, здесь тоже не поможет)


        // Странно, но Reference Manager однажды (во время работы над проектом 14.5) перестал запоминать мои недавние применения сборок


        // Есть интересная особенность, связанная с VS. При добавлении сборки в проект с помощью Reference Manager, VS запоминает этот путь
        //   . Если твоя сборка находится, например, в подпапке выходного приложения (это может быть
        //   ..\bin\Debug\MyOwnLibs\), то VS будет нацелена только на неё. Если ты переместишь (или переименуешь) эту сборку, VS (возможно
        //   сразу) почует это (а может только во время компиляции или при нажатии на кнопку Refresh в Solution Explorer) и попытается
        //   сделать так, чтобы приложение связывалось с какой-нибудь версией этой сборки из GAC (у меня в манифесте записан запрос сразу
        //   на BottleLib.dll версии 2.0.0.0, что странно. Видимо, VS полностью проверяет GAC, даже читая политики издателя). CLR здесь не
        //   причём, ведь версию сборки видно из окна Properties (****это предложение было добавлено просто по догадкам, без проверки).
        //   Даже если ты поместишь нужную сборку прямо в папку приложения, VS не обратит на это внимание, т.к. она ждёт эту сборку только
        //   по тому пути,
        //   где лажала сборка при использовании Reference Manager
        // Если VS не найдёт что-то подходящее и в GAC, то выйдет ошибка компиляции
        // Помни, что имя файла сборки и идентефикатор (т.е. имя) сборки - разные вещи! Если ты через Reference Manager добавишь в проект
        //   BottleLib_.dll, то в манифест попадёт запрос именно на BottleLib (и CLR будет искать файл с именем BotteLib + .dll или
        //   .exe). Настоящее дружественное имя файла сборки можно увидеть в окне Properties (справа от Identity)



       /////////after reading:PIA///////////////////////////////////////////////////////////////////
       // Про Свойство Embed Interop Types в окне Properties (что открывается через
       //   Solution Explorer -> Solution .. -> .. -> References -> .. (ПКМ)) можешь почитать в
       //   методе про PIA
       /////////////////////////////////////////////////////////////////////////////////////////////


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   LinkingAssembliesANDXML_Silent()");
    }
    static void dotnet_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   dotnet_Silent()\n");


        // dotnet - это *nix'овская cli (console line interface) утилита, что создала сама Microsoft. Собственно, это и есть пульт управления
        //    .NET Core'ом. Именно им запускаются все местные .NET Core проекты, и именно им здесь предлагается их строить
        //    /////////after reading///////////////////////////////////////////////////////////////////////
        //    // (на этом пакете и основаны расширения VS Code (Code - OSS) для IDE'ализации)
        //    /////////////////////////////////////////////////////////////////////////////////////////////
        // На винде, кстати, также есть утилитка dotnet
        // Microsoft Docs называет эту утилиту dotnet cli в своих мануалах


        // Гигантский минус Linux'ов и macOS - это то, что на них доступен лишь .NET Core (теперь уже .NET 5) и Mono. Т.е. вся графика
        //    и подобная windows'специфичная брехня тебе недоступна. Второй главный минус - недостаток документации и средств для
        //    программирования. VS, ildasm, dumpbin - этого здесь нет,
        //    имеются лишь их аналоги. Есть несколько IDE, но все они по сравнению с VS - щит (есть JetBrains Rider, но он стоит денег)(копии
        //    ildasm и dumpbin можно использовать из мира Mono)
        // Я пробовал работать из консоли, применяя лишь tmux и vim с его плагинами
        //   /////////without continuation////////////////////////////////////////////////////////////////
        //   // (а использовал я Vundle как менеджер плагинов, omnisharp-vim для ide-like штучук и
        //   // omnisharp-roslyn компилирования, ale для индикации ошибок прямо при редактировании файла
        //   // )
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   и управляя проектом через dotnet. Но чтоб действительно полностью пересесть на это, нужен целый свободный сезон, т.к. нужно как
        //   следует прокурить мануалы (ведь там всё просто по кнопочке F5 не работает. и даже не думай о методе тыка - им ты только всё
        //   запутаешь)


        // Поставляется 2-е версии этого пакета - dotnet-sdk (sdk - standard developer kit) и dotnet-runtime (чисто для запуска уже написанных
        //   .NET Core программ). Как ты таки собираешься что-то писать под Linux'ом или macOS'ью, ставь именно dotnet-sdk
        // Установить этот пакет можешь или из репозиториев твоего любимого дистрибутива (если Microsoft позаботилась о его поддержке), или
        //   вручную, следуя оффициальным инструкциям (https://docs.microsoft.com/en-us/dotnet/core/install/linux)


        // Т.к. Microsoft'цы незнакомы с Unix'овыми устоями, man page'а для этого пакета составить они не решились. Вместо этого предлагается
        //   просто вводить    dotnet --help


        // В общем и целом, dotnet создаёт ровно те же файлы и папки, что и VS (если ты используешь .NET Core). Поэтому и dotnet, и VS могут
        //   читать проекты друг друга


        // dotnet --info - выведет общую инфу об этом dotnet'е и твоей системе (версия .NET SDK, какая ось, версия оси, путь к dotnet, что-то
        //   о хосте, ...)


        // Для создания нового проекта (и не только) у утилиты dotnet есть подраздел new (подразделы в документациях зовутся как command,
        //   команды). Работает он так:
        //
        //       dotnet new [options]
        //
        //   Просто ввести    dotnet new    и создать пустой проект не получится, обязательно нужно использовать какой-то шаблон. Список
        //   шаблонов проектов можно увидеть, введя
        //
        //       dotnet new --list
        //
        //   Ты увидишь полные имена шаблонов для проектов, их короткие имена, языки, которые эти шаблоны поддерживают, и таги. Также в этом
        //   списке есть и не проекты
        //   /////////after reading:dotnet sln////////////////////////////////////////////////////////////
        //   //   Например,    dotnet new sln    создаст solution файл (этот .sln изначально не будет
        //   //   привязан ни к какому проекту)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //
        // Самый простой проект, что ты можешь создать - это Console Application. Создаётся он так:
        //
        //       dotnet new console
        //
        //   (после new можно ввести как полное, так и короткое имя шаблона. Пробелы в полных именах, кстати, надо прикрывать или ""-ками -
        //   "Console Application", или \'шкой - Console\ Application). Так новоиспечённый проект создастся в текущей директории (это,
        //   правда, может занять какое-то время). Проект, кстати, получи имя этой текущей директории
        // Было замечено, что classlib создаётся много быстрее, чем console
        //
        // Новоиспечённый проект будет состоять из:
        //       > <имя проекта>.csproj  - файл с настройками проекта
        //       > Program.cs            - собственно, код. Код по умолчанию выводит строку "Hello World!" в stdout).
        //       > ./obj/                - поддиректория
        //                                 /////////after reading///////////////////////////////////////////////////////////////////////
        //                                 // , что будет хранить набор стандартных nuget'ов
        //                                 /////////////////////////////////////////////////////////////////////////////////////////////
        //
        // Вот остальные аргументы аргументы этого раздела:
        //
        //       -h, --help           ****
        //       -l, --list           ****
        //       -n, --name           ****
        //       -o, --ouput          директория, куда и будут созданы файлы. Если такой dir'ки нет, dotnet new сам создаст её
        //       -i, --install        этим задаётся директория, по которой dotnet new будет создавать новый template. Годится не любая
        //                            директория с уже готовым проектом. dotnet new сможет создать шаблон, только если в директории проекта
        //                            будешь ещё находиться поддиректория с ****нужной для шаблона инфой
        //       -u, --uninstall      ****
        //       --interactive        ****
        //       --nuget-source       ****
        //       --type               ****
        //       --dry-run            ****
        //       --force              ****
        //       -lang, --language    ****
        //       --update-check       ****
        //       --update-apply       ****
        //
        // Некоторые шаблоны имеют свои аргументы. Вот они:
        //
        //       dotnet new webapi <args>  - Аргументы:
        //                                   -- no-https  - создать webapi проект, что будет запускаться без HTTPS сертификата. Эта штука тебе
        //                                                  не нужна, если ты делаешь простенький проект
        //                                                  /////////after reading: ASP.NET////////////////////////////////////////////////////
        //                                                  // о том, что такое https, ты можешь почитать в методе о ASP.NET
        //                                                  ///////////////////////////////////////////////////////////////////////////////////
        //                                                  
        //                            


        //****dotnet build. После build'а появится папка ./bin/
        //****-c, --configuration <CONFIGURATION>  - Debug или Realese. При использовании Realese компилятор сильно оптимизирует приложение
        //                                           (меняя ход его работы. Включая multithread часть)


        // Для запуска (вместе с компиляцией) уже имеющихся .NET Core проектов у dotnet выделен подраздел run. Вот синопсис этого подраздела
        //   (т.е. что может принять этот подраздел):
        //
        //       dotnet run [options] [[--] <additional arguments>...]]
        //
        // Если ты хочешь просто скомпилировать и запустить проект, введи это в его директории:
        //
        //       dotnet run
        //
        // Почитать о других параметрах ты можешь, использовав --help (это, кстати, тоже параметр):
        //
        //       -h, --help
        //       -c --configuration <configuration>    это может быть "Debug" или "Release". По умолчанию "Debug"
        //       -f, --framework <framework>           ****
        //       -r, --runtime <****runtime>           ****
        //       -p, --project <..csproj>              запустить именно этот <..csproj>
        //       --launch-profile                      ****
        //       --no-launch-profile                   ****
        //       --no-build                            ****
        //       --interactive                         ****
        //       --no-restore                          ****
        //       -v, --verbosity <level>               ****
        //       --no-dependecies                      ****
        //       --force                               ****
        //

        // По умолчанию dotnet проекты привязаны только к тем BCL сборкам, которые полагались по шаблону (или не BCL сборкам, если шаблон
        //   самодельный). Конечно, чуть позже тебе покажется этого недостаточно, и ты захочешь подключить что-нибудь ещё. Делается это
        //   подразделам dotnet add. Синопсис таков:
        //
        //       dotnet add [options] <..csproj> [command]
        //
        //   <..csproj> здесь - это проект к торому добавлется подключется что-то другое
        //
        // У dotnet add всего 1-на единственная --опция:
        //
        //       -h, --help    выводит мини-инструкцию
        //
        // Но есть пара своих подразделиков:
        //
        //       dotnet add <..csproj> package [options] <package_name>    этим ты, собственно, и подключаешь к проекту <..csproj> NuGet пакет
        //                                                                 <package_name> (вводить без .dll)(вводить только один пакет, иначе
        //                                                                 компилер ругнётся красным). Если <..csproj> не задан,
        //                                                                 dotnet add попытается работать с проектом, что находится в текущей
        //                                                                 директории. Команда сначала поищет <package_name> в GAC
        //                                                                 ****неуверен. сборки пакетов скачиваются или копируются почему-то
        //                                                                 сразу в папку ./bin/../. Если же этого пакета в GAC не
        //                                                                 имеется, dotnet add попробует найти его в репозитории и скачать в
        //                                                                 GAC
        //
        //                                                                 У скачиваемых тобой пакетов могут быть зависимости в виде других
        //                                                                 NuGet пакетов. В этом случае ты скачаешь и их как полезный груз
        //                                                                 (такие зависимости в .NET Docs зовутся "transitive packages")
        //
        //                                                                 Как на деле выглядит ссылка на сборку в <..csproj>? Примерно так:
        //                                                                     <Project Sdk="Microsoft.NET.Sdk">
        //                                                                       ...
        //                                                                       <ItemGroup>
        //                                                                         ...
        //                                                                         <PackageReference Include="System.Windows.Extensions"
        //                                                                                           Version="5.0.0" />
        //                                                                       </ItemGroup>
        //                                                                       ...
        //                                                                     </Project>
        //                                                                 Это получилось после ввода команды
        //                                                                     dotnet add package System.Windows.Extensions    в корневой
        //                                                                 директории этого проекта. ****На самом деле об этом уже рассказывалось
        //                                                                 в методе LinkingAssemblies
        //                                                                 
        //                                                                 Если ты повторно сделаешь dotnet add к уже имеющемуся пакету, то
        //                                                                 dotnet проведёт resolving этого пакета (т.е. перейдёт на новую его
        //                                                                 версию)
        //                                                                 
        //                                                                 Какие имеются [options]? Эти:
        //                                                                     -h, --help
        //                                                                     -v, --version <version>        подключить именно эту версию
        //                                                                     -f, --framework <framework>    подключить, только если фреймворк
        //                                                                                                    совпадает с этим фреймворком
        //                                                                     -n, --no-restore               подключить без пересборки
        //                                                                     -s, --source <source>          /////////after reading///////////
        //                                                                                                    // этот ****<source> будет
        //                                                                                                    //   использован во время
        //                                                                                                    //   restore'а
        //                                                                                                    /////////////////////////////////
        //                                                                     --package-direcotry <dir>      /////////after reading///////////
        //                                                                                                    // <dir>, куда пакет будет
        //                                                                                                    //   от'restore'н
        //                                                                                                    //   ****что за restore?
        //                                                                                                    /////////////////////////////////
        //                                                                     --interactive                  разрешает команде остановиться и
        //                                                                                                    ждать user'кого ввода или
        //                                                                                                    действия ****хз зачем это,
        //                                                                                                    эффекта нет
        //                                                                     --prerelease                   разрешить использовать
        //                                                                                                    пререлизную версию этого пакета
        //       dotnet add <..csproj> reference [options] <..csproj>      добавить в текущий <..csproj> ссылку к другому <..csproj>. Первый
        //                                                                 <..csproj> (тот, к которому ты ссылку и привязываешь) можно опустить
        //                                                                 , тогда dotnet add попытается найти .csproj в текущей директории.
        //
        //                                                                 Что именно делает эта комманда? Правит первый <..csproj> файл
        //                                                                 примерно так:
        //                                                                     <Project Sdk="Microsoft.NET.Sdk">
        //                                                                       //...
        //                                                                       <ItemGroup>
        //                                                                         //...
        //                                                                         <ProjectReference Include="..\OtherProj\OtherProj.csproj" />
        //                                                                       </ItemGroup>
        //                                                                       //...
        //                                                                     </Project>
        //                                                                 Конкретно здесь добавилась строка <ProjectRefere...>.
        //
        //                                                                 [options] здесь представлены эти:
        //                                                                     -h, --help
        //                                                                     -f, --framework <framework>    добавить ссылку только, если
        //                                                                                                    ссылаемый <..csproj> работает
        //                                                                                                    именно с этим framework'ом
        //                                                                     --interactive                  ****
        //                                                                  
        //                                                                 Напомню, что ты не сможешь добавить ссылку на проект, что нацелен
        //                                                                 на несовместимый фреймворк (т.е. на фреймворк более старой версии.
        //                                                                 или совсем переделанной новой)
        // 
        // Однажды у меня вышла такая ошибка:
        //     [root@fedora Codewars]# dotnet add package System.Numberics
        //       Determining projects to restore...
        //       Writing /tmp/tmp8If8PF.tmp
        //     info : Adding PackageReference for package 'System.Numberics' into project '/media/te
        //     rrobyte/dev 10 feb 2020/c#_2021-4apr_16/Codewars/Codewars.csproj'.
        //     error: Error while adding package 'System.Numberics' to project '/media/terrobyte/dev
        //      10 feb 2020/c#_2021-4apr_16/Codewars/Codewars.csproj'. The project does not support 
        //     adding package references through the add package command.
        //   Эта штука возникает, например, когда твой проект имеет устаревшую (или по-другому неподходящую****но это не точно) структуру
        //   (например, построенную по legacy MSBuild project, а не SDK-like project)


        // На случай, если тебе больше не нужен какой-то из пакетов, индусы сделали подраздел dotnet remove. Синопсис выглядит так:
        //       
        //       dotnet remove [options] <..csproj> [command]
        //
        //   Опция здесь только одна:
        //
        //       -h, --help  - показывает краткую инфу
        //
        //   Команды здесь всего 2'е:
        //
        //       dotnet remove <..csproj> package <packake_name>  -
        //       dotnet remove <..csproj> reference <..csproj>    -
        //       


        // Если ты хочешь посмотреть на имеющиеся у твоего проекта зависимости (т.е. подключённые NuGet пакеты), воспользуйся подразделом
        //     dotnet list. Вот синопсис:
        //
        //       dotnet list [options] <..csproj or ..sln> [command]
        //
        // [options] здесь одна:
        //
        //       --help
        // 
        // Дальше, в [command] тебе следует указать то, какие именно зависимости ты хочешь увидеть - NuGet пакеты или ссылки на другие проекты:
        //
        //       dotnet list <..csproj or ..sln> package [options]    - выведет package зависимости этого проекта/решения. В [options] можно
        //                                                              тонко настроить что ты именно хочешь увидеть:
        //                                                                  --include-transitive        - получить не только
        //                                                                                                top-level зависимости (список
        //                                                                                                зависимостей мгновенно вырастит
        //                                                                                                многократно)
        //                                                                  --outdated                  - вывести устаревшие NuGet пакеты
        //                                                                                                твоего проекта/решения (заодно скажет
        //                                                                                                , какие версии этих пакетов сейчас
        //                                                                                                актуальны)
        //                                                                  --include-prerelease        - учитывать ещё и пререлизные версии.
        //                                                                                                Ставится это в паре с --outdated
        //                                                                                                
        //
        //       dotnet list <..csproj or ..sln> reference [options]  - выведет reference зависимости. [options] здесь всего одна:
        //                                                                  -h, --help  - выведет очень небольшое описание с этим же синопсисом
        //                                                                  
        //                                                                  
        //


        // Специфичные команды пакетного менеджера NuGet решили вынести в отдельный подраздел dotnet nuget. Синопсис таков:
        //
        //       dotnet nuget [options] [command]
        //
        // Из [options] здесь небольшой выбор:
        //
        //       -h, --help    показать инфо об этом подразделе
        //       --version     показать версию NuGet Command Line'а (это утилитка, которой ты можешь управлять из подразделов dotnet)
        //
        //
        // Подразделиков у dotnet nuget целый зоопарк:
        //
        //       dotnet nuget add [options] [command]         ****
        //       dotnet nuget delete [arguments] [options]    ****
        //       dotnet nuget disable [options] [command]     ****
        //       dotnet nuget enable [options] [command]      ****
        //       dotnet nuget list [options] [command]        ****
        //       dotnet nuget locals [arguments] [options]    ****
        //       dotnet nuget push [arguments] [options]      ****
        //       dotnet nuget remove [options] [command]      ****
        //       dotnet nuget update [options] [command]      ****
        //       dotnet nuget verify [arguments] [options]    ****
        //


        //****dotnet publish


        // Если ты почему-то хочешь вручную проверить/скачать зависимости твоего проекта, используй подраздел dotnet restore
        //   (restoring/resolving - синонимы, но раздел зовётся именно dotnet restore). В большинстве
        //   случаев тебе не нужно будет делать это самим, т.к. dotnet cli сделает это за тебя во время юзания dotnet new/build/run. Это
        //   действие пригодится, если ты скопировал проекта на другой компьютер, где этих зависимостей нет, и тебе не хочется долго компилить
        //   всё для их скачивания. Синопсис у этого подраздела таков:
        //   
        //       dotnet restore [options] <..csproj or ..sln>
        //   
        // Набор опций у него достаточно большой:
        //
        //       -h, --help                           - вывод краткой инфы
        //       -s, --source <source>                - ****
        //       -r, --runtime <runtime>              - ****
        //       --packages <dir>                     - ****
        //       --disable-parallel                   - ****
        //       --configfile <file>                  - ****
        //       --no-cache                           - ****
        //       --ignore-failed-sources              - ****
        //       --no-dependencies                    - ****
        //       -f, --force                          - ****
        //       -v, --verbosity <level>              - ****
        //       --interactive                        - ****
        //       --use-lock-file                      - ****
        //       --locked-mode                        - ****
        //       --lock-file-path <****./..lockfile>  - ****
        //       --force-evaluate                     - ****
        //       


        // Как ты уже видел, файлы решений (aka .sln файлы) создаются через dotnet new. Для модификации .sln файла у dotnet имеется
        //   подраздел sln. Ты можешь спросить - а зачем мне связывать целый проект, если
        //   ****тебе нужна только сборка. Помни, что sln файл по умолчанию ничего полезного из себя не представляет (ведь к проектам он не
        //   по default привязан). Вот синопсис этого подраздела:
        //
        //       dotnet sln [options] <..sln> [command]
        //
        // Из [options] дано только это:
        //
        //       -h, --help
        //
        // Если ты туда заглянул, то знаешь, что у этого подраздела есть свои небольшие подразделики (commands'ы)(со своими --опциями). Вот они
        //   все:
        //
        //       dotnet sln <..sln> add [options] <..csproj>       этим ты добавлишь к решению проект (можно сразу много проектов). Здесь
        //                                                         <..sln> можно опустить, и dotnet sln будет искать .sln в текущей директории
        //                                                         (с опусщением <..csproj> такой фокус не работает ****но это не точно). Какие
        //                                                         здесь --опции? Вот эти:
        //                                                             --in-root                создать файлы проекта прямо в корневой
        //                                                                                      директории решения ****что значит создать?
        //                                                                                                             что должно создаться?
        //                                                             -s, --solution-folder    директория с решением (.sln файлом), к которому
        //                                                                                      проект и нужное прикрепить
        //                                                             -h, --help               
        //       dotnet sln list     ****не пояснино
        //       dotnet sln <..sln> remove [options] <..csproj>    удалает заданные <..csproj> проекты из <..sln>. Здесь также можно опустить
        //                                                         <..sln> , и будет задействован .sln из текущей dir'ки. В [options] доступна
        //                                                         только эта:
        //                                                             -h, --help              
        //
        // Знай, что даже если твои проекты и входят в одно решение, они по умолчанию не видят код друг друга. Решения созданы не для этого
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // (чтоб увидели, нужно воспользоваться подразделом dotnet add)
        //   /////////////////////////////////////////////////////////////////////////////////////////////

        // У dotnet cli есть параметр --help (также этот параметр есть у всех подразделов). Но это не единственный способ получить инфу. Если
        //   тебе неугоден консольный интерфейс ты можешь получить инфу о каждом из подразделов, используя подраздел dotnet help, открывающий
        //   в твоём default браузере страничку из .NET Docs
        //
        // Синопсис очень прост:
        //   
        //       dotnet help [options] <command_name>
        //   
        // Из [options] один неизменный для всех параметр:
        //   
        //       --h, --help  - показывает краткую инфу
        //
        // Вместо <command_name> в синопсисе может подставлять любой подраздел, и ты увидишь инфо о нём в браузере

        // dotnet cli вполне может расширятся доплонительными подразделами. Есть такой подраздел dotnet tool, через него ты и можешь навешивать
        //   и удалять такие расширения. По факту эти расширения - всё те же NuGet пакеты
        //****сказано недостаточно


        // Bundled tools
        //     
        //   При установки дополнительных runtime'ов утилита dotnet может обзавестись новыми подкатегориями со своими приколами. Благо, что
        //     вывод --help также обновляется (т.е. с ним выводится инфа о аргументах этих дополнительных runtime'ов)
        //
        //   /////////after reading: ASP.NET//////////////////////////////////////////////////////////////
        //   // Про то, какие подкатегории появляются при установке Microsoft.ASPNetCore.App, читай в
        //   //   методе про ASP.NET
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //     
        //     


        // Как минимум 1-н раз эта штука меня подвела. Однажды где-то в середине апреля 2021-го (с 15-го по 19-ое числы, если быть точным) при
        //   запуске/создании нового проекта эта утилиты блевала в косноль ошибками, связанными с nuget пакетами. Обновлений у dotnet по
        //   pacman'у не было (pacman - Arch'овский стандартный пакетный менеджер), было ясно, что проблема на стороне мелкомягких. Минимум
        //   один чувак ещё год назад столкнулся с той же проблемой, и мудрецы со stackoverflow посаветовали сменить дистр на нормальный (один,
        //   из тех, что Microsoft оффициально приводит в своей документации). И действительно, на Alpine Linux dotnet заработал сразу (этот
        //   дистр я поставил к следующему дню). Тем не менее, ещё через день я снова вернулся на Arch, и dotnet также хорошо заработал и там.
        //   Что это было, я таки не понял


        // В методе LinkingAssemblies..() в блоке, где пример использования внешней сборки,
        //   рассказано о том, какие файлы приложения из dir'ки ./bin/Debug/net5.0/ нужно захватить
        //   с собой, чтоб программуля могла запускаться на новом месте


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   dotnet_Silent()");
    }
    static void VSCode_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   VSCode_Silent()\n");


        // VS Code весьма популярен, ведь он быстр, маловесен, относительно хорошо нафарширован, работает одинаково хорошо на Windows, Linux и
        //   macOS'ях при этом сильно походя на своего старшего (но целиком шиндовского) брата (VS)

        // Microsoft'цы хотели получить cross-platform редактор, но, т.к. на другие платформы они раньше не лезли (.NET Core тогда ещё не
        //   появился), им пришлось взять за основу нечто несвоё. Так Microsoft оказался в зависимости от Framework'а Electron, которым владеет
        //   GitHub (сам по себе Electron - это кросс-платформенный фреймворк для создания GUI-поделок на JavaScript, HTML и CSS)

        // Мелкомягкие сделали редактор в ноябре 2015-го. И всё. Остальное они отдали в руки сообщества, что уже и сделало
        //   богатую библиотеку расширений (мелкомягкие в этот период они вообще стали обращать внимание на сообщество и его повадки. скорее
        //   всего увидели в этом дикий профит). А расширения в VS Code'а - это всё. Расширения держатся на плечах свободного сообщества,
        //   поэтому на любой твой каприз (почти) найдётся уже что-то готовое. Если не найдётся - пиши сам (сделай же хоть что-то полезное).
        //   Microsoft'цы тебе точно не помешают
        //   /////////after reading:VSCode////////////////////////////////////////////////////////////////
        //   // (я знаю только 1-но расширение, что, как минимум, прошло через них - C#)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   В итоге получается то, что Microsoft пилит редактор, а community - всё остальное
        // Вроде как всё хорошо, но на деле не совсем. Самое главное - платформа .NET Framework осталась за бортом. Community, конечно, не
        //   может его трогать, ведь это полностью Microsoft'ская штука****почему-то таки не может. В итоге из доступного - полностью свободный
        //   и открытый .NET Core


        // На gnu/linux'е тебе нужно сначала установить пакет dotnet-sdk, ведь там эта экосистема .NET поумолчанию чужеродна


        // На GNU/Linux'ах есть 2-е версии VS Code - обычная Visual Studio Code (та самая VS Code) и Code OSS (то же, но полностью с открытым
        //   исходным кодом)(OSS - Open-Source Software). Первая (VS Code) содержит кусок проприетарного (proprietary - частный,
        //   собственничный) кода. Code OSS же полностью открыт и имеет снисходительную MIT License. Разницы между этими версиями на практике
        //   таки есть, и все они (что были замечены) будут описаны дальше
        //
        // У Code OSS другая иконка (т.к. стандартная иконка - это владение Microsoft, и она не свободна)
        // В VS Code доступно немного больше расширений
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // И ключевой для нас debugger C#, что поставляет Microsoft, как раз не имеется на Code OSS. Но там есть аналог
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //****https://github.com/microsoft/vscode/wiki/Differences-between-the-repository-and-Visual-Studio-Code лист со всеми отличиями и
        //  причинами отличий
        //
        // Если ты сидишь на Ubuntu, то можешь смело качать пакет code из оффициальных репозиториев и получить VS Code. На некоторых других
        //   дистрибутивах стандартные репозитории предоставляют Code OSS (на Arch'е, например)
        // Как минимум на Arch Linux вместе с Code OSS поставиться ещё и пакет Electon11 как зависимоость
        
        
        // Открыв VS Code (Code - OSS) ты первым делом увидишь окошко Getting Started. Можешь пройти этот 2-минутный туториал
        // Если говорить про интерфейс, то слева ты можешь увидеть полоску с 5-тью меню (это зовётся Activity Bar). Полоска в самом низу - это
        //   Status Bar, там слева написано количество ошибок и warning'ов. Если смотреть справа, то там идёт иконка про уведомления, кнопка
        //   Tweet Feedback для связи с разрабами, иконка с выбором текущего языка программирования (для текущего файла), иконка с выбором
        //   encoding'а, менюшка для выбора размера отсупа, иконка с текущими координатами курсора в файле. Большой пустырь по середине этого
        //   Status Bar'а может использоватья какими-то расширениями (например, Vim активно им пользуется)


        // Если ты хочешь использовать VS Code (Code - OSS) чисто для правки кода (без всяких там IDE примочек, вроде компиляции по F5), то на
        //   этом всё. Ты уже сейчас можешь открывать .cs (и вообще все) файлы и клацать там клавиатурой. Даже предлагаемого расширения для C#
        //   ставить не надо, подстветка его синтаксиса есть искаропки. Как же компилить проект? Просто открой встроенный или внешний терминал
        //   (втроенный можно открыть, тыкнув вверху по Terminal -> New Terminal или нажав Ctrl-Shift-`) и вперёд с dotnet и песней
        // Если же кочется хоть как-то писать не вслепую, видя ошибки, то читай дальше
        //
        // Как познакомить VS Code (Code - OSS) с C# поближе? Достаточно установить расширение C#, что VS Code (Code - OSS) сам предложет тебе
        //   сделать при открывании .cs файла (VS Code предложит поставить расширение C# от самого Microsoft. Code - OSS предложит реализацию
        //   от некого muhammad-sammy (т.к. debugger Microsoft'а - целиком принадлежит Microsoft'у). Разницы между этими 2-мя debugger'ами не
        //   замечено
        // Расширение от Microsoft поставит тебе сразу 2-е штуки (и аналог скорее всего тоже):
        //   > Roslyn            - open-source реализация C# и Visual Basic компилятора. Этот компилер ещё предоставляет API, и от этого через
        //                         Roslyn можно строить утилиты для анализа кода
        //   > OmniSharp-vscode  - а это как раз одна из таких штук. OmniSharp поставляет подстветку синтаксиса, IntelliSense, GoTo Definitions
        //                         , Find All References штуку и т.д.. В общем, это набор IDE штук. Также OmniSharp даёт возможность нормально
        //                         Debug'ить (т.е. ошибки ты будешь видеть прямо в файле, что пишешь, а не ожидая вывод компилятора)(но
        //                         дебагить ты этим можешь только .NET Core приложение, не Mono).
        //****OUTPUT меню палила ещё и установку .NET Core debugger'а (возможно, это зависимость OmniSharp-vscode)
        // Эти расширения VS Code'а умеют работать только с проектами .NET Core. Если ты создал проект с полноценным .NET, ты не сможешь
        //   компилировать его через VS Code, и IntelliSense не будет ловить ошибки (разве что в синтаксисе)
        //
        // Если ты открыл VS Code'ом (****Code - OSS?) директорию с .NET Core проектом (созданный, например, через dotnet), то расширение C#
        //   сразу скажет, что требуемый набор asset'ов для build'а и debug'а пропущен. Он спросит, нужно ли его создать?. Здесь достаточно
        //   нажать на Yes. Так в директории проекта появится поддиректория .vscode (из-за .-чки впереди она скрыта для file manager'ов)
        // После этого шага ты наконец в состоянии запустить свой первый проект, нажав F5 (или тыкнув Run And Debug (одно из меню слева) ->
        //   Start Debugging (зелёная стролочка))!


        // Каждый месяц выпускается новая версия VS Code (про Code - OSS не знаю. Не думаю, что независимые opensource'еры также следуют этой
        //   малонужной спешке) с фиксом багов, а иногда и новыми фичами
        // Проверить обновление на Windows и gnu/линуксе можно прямо из VS Code, тыкнув по Help -> Check for Updates... . На mac'аках это
        //   Code -> Check for Updates...


        // Всё настройки VS Code'а (Code OSS'а)****лучше инфо про это собрать из блоков ниже и выделить сюда


        // Как и VS, VS Code по умолчанию строит проги в Debug конфигурации


        // В VS Code (как и в VS) есть панель, в которой можно открыть что-то одно из набора Terminal/Problems/Output/[Debug Console]
        // Не нравится, что эта панель по умолчанию открывается снизу? Это легко исправить, ****не успел доделать. в settings.json есть
        //   настройка workbench..
        

        // Также VS Code по дефолту настроен на то, чтобы запускать Debug проект в панели в Debug Console. Загвоздка в том, что эта консоль
        //   принимает
        //   ввод в себя, не передавая его дальше, т.е. в твою программу (т.е. любое вхождение Console.ReadLine() просто застопит программу).
        //   Если вводить что-то в консоль таки нужно, тебе придётся заменить используемую консоль с Debug Console на Terminal правкой конфига
        //   запуска. Если смотреть с корневой директории проекта, то конфиг ты найдёшь, открыв ./.vscode/launch.json. Замени
        //       "console": "internalConsole"    на    "console": "integratedTerminal",    . Должно получится так:
        //
        //       {
        //          //...
        //          "configurations": [
        //              {
        //                  //...
        //                  "console": "integratedTerminal",  // "integratedTerminal" - должно стоять это
        //                  //...
        //              }
        //              //...
        //          ]
        //      }
        //
        //   Это решит проблему. Debug Console всё-ещё будет активна, выдавая всякую полезную Debug инфу (например, о том, какая именно сборка
        //   только что была загружена)
        //
        //
        /////////after reading:Breakpoints///////////////////////////////////////////////////////////
        // Debug Console, вообще весьма полезная штука. У неё есть свой prompt, который, как уже
        //   говорилось, использует чисто для себя. Во время breakpoint'а введя в этот prompt имя
        //   переменной, консоль выдаст тебе её значение (вывод её ToString() метода). Также ты
        //   можешь задать ей новое значение и пронаблюдать за изменением хода работы кода (серьёзно,
        //   ты можешь присвоить переменной значение посредством конструктора или возвратом имеющейся
        //   в твоём коде метода. Debug Console как-бы вклинивает новые команды в твой код. Если
        //   ты попытаешься присвоить что-то, что не может быть приведино к твоей переменной, Debug
        //   вежливо вообщит об этом)
        /////////////////////////////////////////////////////////////////////////////////////////////


        // Также, как и в VS, краткая документация выводится прямо рядом с объявлениями типов
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // в окошках IntelliSense
        //   /////////////////////////////////////////////////////////////////////////////////////////////


        // Как и любой нормальный редактор, VS Code скидывает обязательство сохранять файл на юзера (потому что KISS)(VS только делает вид, что
        //   это так)


        // Легчайший способ найти то, что можешь делать VS Code, - это воспользоваться его "коммандной палитрой" (Command Palette)(правда,
        //   ею я таки не пользуюсь). Открывается она нажатием Ctrl-Shift-P (или F1 при активном F lock'е)


        // Ты можешь добавить линию для пометки столбца на 80, 120 символов и т.д., если используешь VS Code. Делатеся это редактированием
        //   файла настроек VS Code'а. В *nix'ах это ~/.config/Code/User/settings.json. Если тебе нужна линия одновременно и на 80, и на 120
        //   символов, добавь туда это:
        //
        //       "editor.rulers": [80,120]
        //
        //   И не забудь проверить запую в элементе, что стоит перед этой новой настройкой! Она должна быть там!
        /////////after reading///////////////////////////////////////////////////////////////////////
        // Заметь, что IntelliSense работает и в ~/.config/Code/User/settings.json. Даже в строках ""
        //   ты можешь нажать Ctrl+Space, увидя все доступные варианты (а объектам, вроде
        //   "editor.rulers", даже приписано пояснение
        /////////////////////////////////////////////////////////////////////////////////////////////
        // VS Code почти сразу заметит изменение, и ты получишь 2-е тонкие линии на конце символов тех самых столбцов
        // Жаль, но Code OSS не понимает этого правила. Папка с его конфигом, кстати, зовётся немного продругому - "~/.config/Code - OSS"
        //
        // Жирность шрифта настраивается объектом "editor.fontWeight" в ~/.config/Code/User/settings.json VS Code'да.
        //   Ставится так:
        //       "editor.fontWeight": 500    // 500 - тут должно быть число в диапазоне [1, 1000]
        // Размер font'а там же можно выставить так:
        //       "editor.fontSize": 13,      // 13 - собственно, размер в пикселях


        // Ты можешь менять масштаб окон и текста, нажимая Ctrl+ (Ctrl=) и Ctrl-
        //
        // Тему VS Code'а (Code - OSS) ты можешь настроить или в настройках, или нажав Ctrl-K Ctrl-T (с Vim'ом shortcut не работает)
        //
        // Ты можешь перекулючиться в полноэкранный режим, нажав F11

        
        // Ты можешь переключиться на Explorer и обратно, нажав Ctrl-Shift-E
        //
        // Ты можешь переключиться в окно Search (поиск по файлам), нажав Ctrl-Shift-F
        // Также можно перейти в это окно с сразу раскрытым выбором Replace, нажав Ctrl-Shift-H
        //
        // Ты можешь переключиться в окно Source Control и обратно, нажав Ctrl-Shift-G
        //
        // Ты можешь переключиться в окно Run and Debug и обратно, нажав Ctrl-Shift-D
        //
        // Ты можешь переключиться в окно Extensions и обратно, нажав Ctrl-Shift-X


        // shortcut'ы от VS Code не будут работать, если их будет перехватывать какое-то расширение (Vim, например, как минимум перехватит все,
        //   в которых задействовано сочетание Ctrl-R)
        //
        // Ты можешь найти и настроить shortcut'ы, пройдя по Help -> Keyboard Shortcuts Reference (или нажав Ctrl-K Ctrl-R)
        // Ты можешь найти и распечатать удобный cheat sheet с горячими клавишами для VS Code (Code - OSS). Вот pdf'ка для Linux'а:
        //   https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf
        //
        /////////after reading///////////////////////////////////////////////////////////////////////
        // Описание некоторых shortcut'ов для IntelliSense ты можешь найти в этой энциклопедии в
        //   методе про IntelliSense
        /////////////////////////////////////////////////////////////////////////////////////////////


        //****Ctrl+T - в гайде написано, что этим можно открыть поиск по символам. Но с расширением Vim не открывается


        // Ты можешь сдвинуть текущую строку (что под текстовым курсором) вверх/вниз, нажав Alt-Up/Alt-Down
        //
        // Ты можешь удалить текущую строку, нажав Ctrl-Shift-K
        //
        // Ты можешь добавить строку сверху/синзу, нажав Ctrl-Shift-Enter/Ctrl-Enter


        // Ты можешь пройти в начало/конец линии, нажав Home/End
        //
        // Ты можешь прокрутить страницу вверх/вниз на одну строку, нажав Ctrl-Up/Ctrl-Down
        //
        // Ты можешь пройти до ближайших скобок, нажав Ctrl-Shift-\. Если ты уже в пределах скобок, ты пройдёшь до их конца (если ты уже в
        //   их конце, попадёшь в их начало)


        // Ты можешь сложить/разложить (fold/unfold) регион (), нажав Ctrl-Shift-[/Ctrl-Shift-]


        // Ты можешь закоменчивать и раскоменчивать текущую строку, нажав Ctrl-/
        //
        // Ты можешь вставлять блочный комментарий под курсором, нажав Ctrl-Shift-A


        /////////after reading///////////////////////////////////////////////////////////////////////
        // Про Ctrl-Space, Ctrl-Shift-Space, F12, Ctrl-Shift-F10, Ctrl-. рассказано в методе про
        //   IntelliSense
        /////////////////////////////////////////////////////////////////////////////////////////////


        // Ты можешь повзолить VS Code'у отформатировать твой документ (переделать отступы, например), нажав Ctrl-Shift-I
        //
        // Ты можешь переименовать какой-то элемент (переименовать метод, класс,...), находищийся под курсором, нажав F2. Так откроется
        //   мини-окно под этим именем с предложением нового. Новое имя сразу применится и ко всем местам вызовов этого метода
        // Нажав Shift-Enter (там чуть ниже подсказка про это), ты откроешь Refactor Preview (в окне терминала), где у тебя нарисуется как-бы
        //   древо с файлами и местами, где произойдёт это переименование
        //
        // Ты можешь быстро посмотреть все использования такого-то класса/метода/структуры/.., нажав Shift-F12. Если это что-то использовалось
        //   лишь 1-н раз, ты просто перейдёшь к этому месту. Если же много раз, откротое окошко между строк с кодом, где был вызов. Нажимая
        //   Shift-F12 дальше, ты будель переходить от 1-го такого кода с вызовом к следующему
        //****возможно это, и всё, что связано с вызовами (ссылками), относится к IntelliSense


        // В VS Code встроена такая фича, как multi cursor. Т.е. у тебя может быть сразу 2-а и более текстовых курсоров. Чтоб сделать
        //   дополнительный курсор, зажми LAlt и тыкни мышкой в желаемое место в тексте
        // На некоторых gnu/linux дистрибутивах с LAlt может не работать. Для решение этой проблемы в моём cheat sheet'е предлагается заменить
        //   эту кнопку на другую с помощью настройки "editor.multiCursorModifire" в ~/.config/Code/User/settings.json
        //
        // Мультикурсор можно делать и клавиатурой - линией подряд. Нажми Shift-Alt-Up/Shift-Alt-Down (с vim'ом не работает)
        //
        // Ты можешь выделить какую-то часть текста и нажать Ctrl-Shift-L (****Ctrl-F2 делает то же?), чтобы поставить по курсору на конце
        //   каждого такого входжения


        // Если ты выделяешь текст мышкой, то с помощью Shift-Alt-Left/Shift-Alt-Right ты можешь расширить/уменьшить выделенное
        //
        // Ты можешь выделить целый блок кода (скажем, прямоугольник с комментариями справа), протыкав Ctrl-Shift-<Up/Down/Left/Right>


        // Если в VS Code у тебя редактор разделён (splitted) на несколько панелей, и ты сейчас хочешь всё вернуть к одному большому окну,
        //   просто тыкни по View -> Editor Layout -> Single


        /////////after reading///////////////////////////////////////////////////////////////////////
        // IntelliSense в VS Code однажды повёл себя странно. При подключении сборки
        //   System.Runtime.Numerics.dll для использования System.Numerics.BigInteger этой самой
        //   структуры BigInteger не было в предложеном списке. Хотя таки создав переменную и
        //   скомпилировав проект ошибки не возникло ****может виноваты ассеты в папках .vs или
        //   .vscode?
        /////////////////////////////////////////////////////////////////////////////////////////////


        /////////after reading:IntelliSenseANDCodeLens_..()/////////////////////////////////////////////////////
        // Средство InelliSense в VS Code работает откровенно странно. Оно может работать и не
        //   работать полностью в соседних файлах одного проекта, может действовать частитчно
        //   (выделяя ошибки в синтаксисе, но не зная какие у типов члены). Чуть позже было замечено
        //   , что IntelliSense начинает работать в .cs файле только после какого-то изменения в нём
        //   (просто изменения, даже без сохранения)
        /////////////////////////////////////////////////////////////////////////////////////////////


        // Стоит знать, что VS Code'вский C# extension не станет запускать свою часть для поиска ошибок и warning'ов, если кусок твоего .sln'а
        //   , что отвечает за главный запускаемый проект, поломан
        //   /////////after reading:TrueOfReflectionLateBindingAttributes/////////////////////////////////
        //   // (во всяком случае здесь, в энциклопедии, если в файле ./dotnetCoreVersion.sln добавить
        //   // что-то перед    Project.."dotnetCoreVersion"..    , проект не запустится. Я так ломал
        //   // ломал эту часть. Но, при добавлении чего-то переж Project.."CommonShareableTypes"..
        //   // C# extension таки работал как надо. Эти Project.. я там менял местами, всё проверил, это
        //   // работает действительно так. VS Code, кстати, приходится перезапускать, чтоб C# extension
        //   // по новой прочитал ./dotnetCoreVersion.sln)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // Ещё он непошивелится, пока ты не откроешь какой-нибудь .cs файл проекта (****или, может, любой другой файл)
        // Стоит сказать, что запускается эта фиговина не сразу. Стоит подождать секунд 5-ть


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   VSCode_Silent()");
    }
}