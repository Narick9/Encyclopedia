/*
 * creation date  18 dec 2020
 * last change    11 sep 2021
 * author  artur
 */
using System;


class ManifestANDGACANDAttributesForAssembly
{
    static void Main()
    {
        Console.WriteLine("***** SystemConsole_ *****");

        ManifestANDGACANDAttributesForAssembly_Silent();

        Console.ReadLine();
    }
    static void ManifestANDGACANDAttributesForAssembly_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   ManifestANDGACANDAttributesForAssembly_Silent()");


        // Каждая сборка хранит в себе также и подробное описания себя. Эти метаданные сборки официально зовутся "манифестом". Ты уже это читал
        //   , но повторюсь, манифест содержит такие вещи, как версия этой сборки, сведения о культуре (для того, чтобы CLR использовала нужные
        //   шрифты локализации) и список всех внешних сборок (чей код используется в текущей сборке), и даже информацию об авторских правах (и
        //   часто ещё несколько малозначительных вещей)
        //
        // Метаданные сборки (aka манифест)(как и методанные типов) создаются компилятором
        //
        // Как уже несколько говорилось, каждой сборке назначается номер версии. Стостоит он из четырёх частей в форме
        //   <старшийНомер>.<младшийНомер>.<номерCборки>.<номерРедакции> (по умолчанию VS выставляет сборке 1.0.0.0, если твой проект
        //   не создан как Empty Project). Этот номер версии 


        /////////after reading///////////////////////////////////////////////////////////////////////
        // В первом блоке манифестов сборок описываются все внешние сборки, требуемые текущей для
        //   работы (они помечены как .assembly extern). Например, у нас используются mscorlib и
        //   System.Windows.Forms (для тебя это пока рандомная либа), и вот что оказалось манифесте:
        //       // Metadata version: v4.0.30319
        //       .assembly extern mscorlib
        //       {
        //         .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
        //         .ver 4:0:0:0
        //       }
        //       .assembly extern System.Windows.Forms
        //       {
        //         .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
        //         .ver 4:0:0:0
        //       }
        // Каждый блок .assembly extern уточняется директивами .ver
        //   /////////after reading//////////////////////////////////////////////////////////////////
        //   // и .publickeytoken. Инструкция .publickeytoken присутсвует только если это сборка со
        //   // своим строгим именем (символы, что идут после - это хеш-код от её открытого ключа).
        //   // Подробнее в методе про линковку (Linking)
        //   ////////////////////////////////////////////////////////////////////////////////////////
        //   . Маркер .ver определяет числовой идентефикатор версии сборки, на которую ссылаются
        //   (именно эти версии и будут подключаться к твоей сборке средой CLR)
        //
        /////////////////////////////////////////////////////////////////////////////////////////////
        // После первого блока идёт .assembly с самой сборкой
        //       .assembly 14.2
        //       {
        //         .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = (01 0..
        //         .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = (01 00 01 00..
        //                                                                                                                    63 65 70 7..
        //       
        //         // --- The following custom attribute is added automatically, do not uncomment -------
        //         //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnost..
        //       
        //         .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = (01 00 1A 2E 4E 4..
        //                                                                                                               2C 56 65 72 73 ..
        //                                                                                                               0E 14 46 72 61 ..
        //                                                                                                               61 79 4E 61 6D ..
        //                                                                                                               65 77 6F 72 6B ..
        //         .hash algorithm 0x00008004
        //         .ver 0:0:0:0
        //       }
        //   Набор маркеров .custom здесь - это атрибуты сборки (информация об авторском праве, названии компании и т.д.)
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // (атрибуты в .NET, вообще, это просто пометки с доп инфой, т.е. следует воспринимать их
        //   // как пометки)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   . Обычно такие
        //   настройки устанавливаются визуально с применением окна .. Properties -> Application -> Assembly Information. После
        //   внесения и сохранения изменений в этом меню, будет обновлён файл Solution Explorer -> .. -> Properties -> AssemblyInfo.cs (все
        //   говорят, что он появляется сам в подпапке .\Properties\ при создании любого проекта, но у моего Empty Project его и этой подпапки
        //   не было.
        //   Позже он, вроде, появился после применения изменений в окне Assembly Information. Если он нужен, то просто создай папку в каталоге
        //   проекта с именем Properties, и включи его в проект (Solution Explorer -> Show All Files (включить)(это флаг выше древа файлов) ->
        //   Properties (ПКМ) -> Include In Project)
        ///////////after reading///////////////////////////////////////////////////////////////////////
        // В файле AssemblyInfo.cs можно увидеть набор атрибутов .NET (они в квадратных скобках []).
        //   Большиство атрибутов из этого файла в манифесте отражаются как маркеры .custom
        ///////////////////////////////////////////////////////////////////////////////////////////////
        // Заметь, что (видимо) из-за того, что этот проект изначально был пустым (Empty Project), его версией считается 0:0:0:0, и здесь
        //   гораздо меньше маркеров, чем написано в книге (где проект создавался из Class Library (.NET Standard)). В Empty Project, видимо,
        //   изначально вообще не создаётся этот файл AssemblyInfo.cs и папка Properties
        /////////after reading///////////////////////////////////////////////////////////////////////
        // Чтобы нахрен отключить производство AssemblyInfo.cs со всеми его атрибутами, добавь
        //   <GenerateAssemblyInfo>.. в ..csproj файл нужного проекта. Должно получится так:
        //       ..
        //       <PropertyGroup>
        //         ..
        //         <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
        //       </PropertyGroup>
        //       ..
        /////////////////////////////////////////////////////////////////////////////////////////////
        /////////after reading///////////////////////////////////////////////////////////////////////
        // Чтоб нахрен отключить производтво атрибутов для фреймоврка ****что это?, добавь в ..csproj
        //   нужного проекта одну штуку, чтобы вышло так:
        //       ..
        //       <PropertyGroup>
        //         ..
        //         <GenerateTargetFrameworkAttribute>false</GenerateTargetFrameworkAttribute>
        //       </PropertyGroup>
        //       ..
        /////////////////////////////////////////////////////////////////////////////////////////////


        // Все BCL сборки (в том числе и mscorlib.dll) по умолчанию находятся в одном специальном месте - C:\Windows\Assembly\GAC\ (точнее там
        //   находятся папки с этими сборками)(это как раз одна из тех папок Windows, где много всяких .dll). Это место прозвали
        //  "глобальным кешем сборок" (global assembly cache - GAC)
        // Почему сборки должны быть или в папке с использующем её приложением, или
        //   находится в определённой папке в системе? Дело в том, что в программе
        //   изначально должен быть прописан путь к этой сборке, включающий её имя
        //   (как минимум, так было с программами на Си), и, чтобы не возникало лишних
        //   труднойстей при развёртке приложения на новом компьютере, разработчики
        //   делают так, чтобы программа ждала эту сборку прямо у себя в папке (или её
        //   подпапках), или, если они уверены, пишут путь в определённую папку в
        //   системе, надеясь, что сборка окажется именно там. Например, вот этот путь
        //   бы работал у меня на компьютере:
        //   D:\dev 10 feb 2020\c#\chapter14\14.2_Assembly---\bin\Debug\14.2.dll
        //   /////////after reading://////////////////////////////////////////////////////////////////////
        //   // .NET'овский CLR слегка гибче. Если в сишные программы ты прям-таки зашивал пути к
        //   // используемым либам в .exe'шник, то CLR следует инструкциям внешнего .config-файла
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // На Linux'ах и macOS местоположение GAC зависит от дистрибутива .NET (sdk 5.0.104 размещается в /usr/share/dotnet/sdk/5.0.104/.
        //   Unix'овый вариант, кстати, представляет из себя не просто список, а нечто другое, в отличие от мастдайского)
        // А ещё .NET проектировался так, чтобы библиотеки кода, написанная на C# легко может применяться на Visual Basic, или F#, или любом
        //   другом языке с поддержкой CLI (Common Language Infrastructure)
        //
        // Сборки могут развёртываться (т.е. устанавливаться) или как "закрытые", или как "разделяемые". Закрытые размещаются в том же каталоге
        //   (или подкаталоге), что и клиентское приложения, что их использует. Разделяемые же расчитаны на использование их многими
        //   приложениями. Они то и должны быть в директории GAC (это такое стандартное место для них)
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Для сборок (и закрытых, и разделяемых) могут быть созданы конфигурационные файлы
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //
        // До .NET 4.0 GAC размещался в C:\Windows\assemlby (это, можно сказать, его историческое место, и этот каталог до сих пор
        //   существует и хранит сборки, скомпилированные на версиях .NET ниже 4.0). При разработке .NET 4.0 в Microsoft решили передвинуть
        //   GAC в специально выделенный для .NET каталог - C:\Windows\Microsoft.NET\assemlby\GAC_MSIL. Его структура также изменилась -
        //   теперь GAC это не просто куча .dll'шек, а набор папок, каждая из которых названа дружественным именем к содержащейся в
        //   ней сборке (как ...\System.Core). Внутри каждой папки всегда есть подкаталог, названный по такому соглашению:
        //   v4.0_старшийНомер.младшийНомер.номерСборки.номерРедакции__значениеМаркераОткрытогоКлюча (хотя были и ..Редакции_ru_зна.., как
        //   и с en)(впрочем, ты, наверное, уже сам залез туда и увидел всё это). Префикс v4.0 говорит о том, что сборка скомпилирована в
        //   .NET 4.0 (или более поздних версиях). Маркер ключа - это часть "строго имени" сборки (об этом чуть позже). Наконец, внутри этого
        //   подкаталога и находится сама сборка
        // Если ты будешь использовать .NET ниже версии 4.0, твои библиотеки будут развёрнуты в C:\Windows\assembly, если более новые
        //   версии - в C:\Windows\Microsoft.NET\assembly\GAC_MSIL
        // В GAC нельзя развернуть исполняемые (т.е. .exe) файлы, только .dll (так говорит автор, но я позже опроверг это)(позже выяснилось,
        //   что эти .exe сборки подключить не удасться)


        // Перед развёртыванием сборки в GAC ей должно быть выдано "строгое имя", которое применяется для идентифицирования его издателя
        //   (им может быть отдельный программист, подразделение компании или целая компания). Строгое имя основано на двух связанных ключах
        //   ("открытом" и "секретном")
        // Как говорит автор, это что-то вроде
        //   современного .NET-эквивалента AppID (схемы распознавания приложений COM, что использовало GUID). В отличие от значения GUID
        //   в COM (которое фактически было всего лишь 128-битным числом) строгие имена из 2-ух ключей гораздо более уникальны и устойчивы к
        //   подделке, чем простые GUID (при этом в MSDN белым по коричневому написано, что это не средство безопасности)
        // Формально строгое имя основано из набора связанных данных, большиство из которых указывается (вернее, автоматически ставится) с
        //   использованием этих атрибутов уровня сборки:
        //   > Дружественное имя сборки
        //   > Номер версии сборки
        //     /////////after reading///////////////////////////////////////////////////////////////////////
        //     // (может назначаться с помощью атрибута [AssemblyVersion])
        //     /////////////////////////////////////////////////////////////////////////////////////////////
        //   > Значение открытого ключа
        //     /////////after reading///////////////////////////////////////////////////////////////////////
        //     // (может назначаться с помощью атрибута [AssemlbyKeyFile])
        //     /////////////////////////////////////////////////////////////////////////////////////////////
        //   > Необязательный идентефикатор культуры для целей локализации
        //     /////////after reading///////////////////////////////////////////////////////////////////////
        //     // (может назначаться атрибутом [AssemblyCulture])
        //     /////////////////////////////////////////////////////////////////////////////////////////////
        //   > Встроенная цифровая подпись (это хеш-код от внутренностей сборки и значения секретного ключа)
        //   Чтобы получить строгое имя для сборки, нужно сначала с помощью утилиты sn.exe (на винде)(также из cmd VS) сгенерировать данные
        //   открытого и секретного ключей (обычно выходит файл с расширением .snk - Strong Name Key, содержащий значения двух разных, но
        //   математически связанных ключей). После этого надо указать этот файл компилятору
        //   (как? об этом чуть позже), и он (при своём запуске) запишет полное
        //   значение открытого ключа в манифест (применяя маркер .publickey) и создаст хеш-код на основе всей сборки
        //   (заголовка Windows, кода CIL, манифеста, что включает открытый ключ, и т.д.). Затем этот хеш-код будет скомбинирован им с
        //   закрытым ключом (содержащимся в том же файле .snk), чтобы, наконец, получить цифровую подпись, что будет встроена в загаловок
        //   CLR сборки. Этот процесс выглядит так:
        //
        //                 14.2.dll
        //       Манифест (с открытым ключом)          ─┐
        //       Метаданные типов                      ─┼── Хеш-код сборки + Данные секретного ключа = Цифровая подпись
        //       Код CIL                               ─┘                                                    │
        //       Загаловок CLR { .. Цифровая подпись }                                                       │
        //                                 ^─────────────────────────────────────────────────────────────────┘
        //   Сразу после получения этого строго имени (т.е. цифровой подписи), сборка может быть установлена в GAC
        // И всё это для того, чтобы не случилось совпадение удостоверений у разработчиков, отделов и компаний. Такой механизм также
        //   обеспечивает безопасность в случае попытки подделки сборки (и всё это привело к тому, что устоявшейся практикой .NET стало
        //   назначение строгих имён вообще всем сборкам, даже .exe. Так говорит автор, но MSDN диктует иначе)


        // Номер версии плюс строгое имя позволяют
        //   сборкам с одним и тем же именем считаться разными (что даёт возможность каждой программе-клиенту использовать ту версию такой
        //   сборки, что ей нужна)


        // В первую очередь создадим этот .snk-файл. Из всех --параметров утилиты sn.exe нас интересует
        //   только флаг -k, приводящий к генерированию файла с данными открытого и закрытого ключей. Для этого автор выделил отдельную
        //   папку MyTestPairKey. Зайдя в неё, следует прописать что-то подобное этой команде:
        //       sn.exe -k myNewKeys.snk
        // Теперь нам следует проинформировать компилятор о том, что у нас есть открытый и секретный ключ для текущей сборки. Это можно
        //   сделать через уже знакомый файл AssemblyInfo.cs (напоминаю, что он содержит атрибуты уровня сборки), используя в нём атрибут
        //   [AssemblyKeyFile]
        // Я специально оставил файлы AssemblyInfo14.4.cs и 14.4.csproj с кое-какой полезной инфой. Эти файлы с проекта 14.4
        // После этого шага у компилятора есть вся необходимая информация для прикручивания строгого имени в эту сборку. Вот интересная нам
        //   часть полученного после компиляции манифеста:
        //
        //       .custom ..
        //       .custom ..
        //       ..
        //       .publickey = (00 24 00 00 04 80 00 00 94 00 00 00 06 02 00 00   // .$..............
        //                     00 24 00 00 52 53 41 31 00 04 00 00 01 00 01 00   // .$..RSA1........
        //                     2D 1D 89 E9 0F C7 96 EB 44 A3 23 B6 93 53 CA 0D   // -.......D.#..S..
        //                     2A CF D1 E2 A9 CF 72 16 53 37 B4 E0 1E FD 4B 01   // *.....r.S7....K.
        //                     10 0A 67 F3 AF B0 2B 64 5E 71 2D 9D 49 AD 0F 1E   // ..g...+d^q-.I...
        //                     BA 4B 60 70 EB 00 5C D4 B1 A2 F6 84 BB 86 E2 2D   // .K`p..\........-
        //                     1B 26 1F 7A 2E BA 33 1F 8A 7F 73 7C 32 A4 69 80   // .&.z..3...s|2.i.
        //                     A0 0A CB 3C 0E CD F9 8B F7 46 BA A1 ED 3A 14 AB   // ...<.....F...:..
        //                     69 76 FB F0 C5 0D 15 23 F3 D7 53 85 95 D8 67 DA   // iv.....#..S...g.
        //                     9E 86 BD A5 23 EE 67 4E DC 3A AD 0F 29 42 2D BD ) // ....#.gN.:..)B-.
        //       .hash algorithm 0x00008004
        //       .ver 1:0:7566:39236         // 1:0:7566:..  да, VS, видимо, не постепенно повышает числа, а выставляет что-то своё
        //
        //   Как мы видим, открытый ключ, созданный нами через sn.exe, вшит в манифест, а маркер .ver хранит нестандартную версию
        // Файл myVSKeyPair14.4.snk - пример файла, что я использовал в проекте 14.4. Ключи в .snk файле, конечно, зашиврованы, так что просто
        //   открыть и посмотреть на них нельзя (да и оно не надо)
        // Сборка готова к развёртке в GAC (это был ручной путь)


        // В наше время необходимый файл .snk обычно генерируется через VS (с свойствах проекта можно поставить файл ключей. Об этом ниже),
        //   но раньше (примерно до 2003 года) это можно было сделать только в cmd.
        // Как именно? Для этого достаточно пройти по Project -> .. Properties -> Signing, тыкнуть по флагу
        //   Sign the assembly (sign - подписать) и в шторке ниже выбрать или уже имеющийся .snk файл, или создать его здесь и сейчас (это
        //   мы и сделаем). При нажатии на выбор <New...> появится отдельное окно с приглашением ввести имя .snk-файла. Здесь же можно
        //   даже защитить его паролем (делать не будем) и выбрать алгоритм создания ключей, если стандартный не угоден. Файл появится
        //   прямо в папке проекта, и будет использоваться компилятором каждый раз
        // Я заметил, что VS при применении изменений в окне Assembly Information (что можно открыть из свойств проекта) изменяет файл
        //   AssemblyInfo.cs. Ещё более интересно то, что сейчас у меня вручную (т.е. атрибутом в AssemblyInfo.cs) как файл с ключами задан
        //   .\MyTestKeyPair\myNewKeys.snk, а в свойствах проекта ту же роль занимает myVSKeyPair.snk. В итоге в манифест попадает именно
        //   myVSKeyPair.snk, хотя там же чуть выше прописан вот этот атрибут:
        //
        //       ..Reflection.AssemblyKeyFileAttribute::.ctor(string) = ( 01 .. 50 61   // ....\MyTestKeyPa
        //                                                                      .. 6B   // ir\myNewKeys.snk
        //   
        //   Да, манифест сборки может и соврать! Если не использовать атрибут [AssemblyKeyFile], оставив привязку к файлу myVSKeyPair.snk
        //   в свойствах, открытый ключ в манифесте останется, но записи атрибута не будет. По этой проблеме также светится warning


        // В файле AssemlbyInfo14.4.cs также есть инфо о том, как вообще задаются атрибуты уровня сборки. Также там есть некоторая общая
        //   полезная инфо и инфо о конкретных атрибутах
        //
        // Например, ты можешь почитать там про атрибут [AssemblyVersion]
        //
        // Про атрибут [AssemblyCulture] что-то также написано там


        // Наконец, можно приступать к установке нашей (уже строго именованной) сборки в GAC. Хотя в производственной среде все
        //   предпочитают создавать установачный пакет для этого (так говорит автор), мы воспользуемся инструментом cmd под именем
        //   gacutil.exe (что входит в .NET Framework SDK) (он удобен своей простотой). Вот его наиболее интересные параметры:
        //   > /i  - устанавливает сборку со строгим именем в GAC
        //   > /u  - удаляет сборку из GAC
        //   > /l  - отображает список сборок (или конкретную сборку) в GAC
        // Имей ввиду, что для изменения GAC нужно иметь права администратора (поэтому следует открыть developer.. cmd из стартового меню.
        //   Там для этого есть возможность)
        // Перейдя в папку с проектом, мы можем ввести эту команду для добавления сборки в GAC:
        //       gacutil.exe -i .\bin\Debug\14.4.dll
        //   Получив положительный отклик, проверим нашу сборку:
        //       gacutil.exe -l 14.4
        //   Заметь, что .dll нам уже писать не следует. Если всё впорядке, ты увидишь это:
        //       The Global Assembly Cache contains the following assemblies:
        //         14.4, Version = 1.0.7567.29698, Culture = neutral, PublicKeyToken = c60d3b4598547336, processorArchitecture = MSIL
        //
        //       Number of items = 1
        //   Более того, если заглянуть снова в C:\Windows\Microsoft.NET\assembly\GAC_MSIL, то там можно увидеть каталог 14.4
        //
        // Ради эксперимента я в свойствах проекта изменил его тип с Class Library на Console Application (что переделывает выходной файл
        //   из .dll в .exe), и (что странно)    Assembly successfully added to the cache    . В папке 14.4 (что в GAC) просто был создан
        //   новый подкаталог (из-за того, что VS изменила версию сборки, и это отразилось на его имени), в котором был вполне запускаемый
        //   14.4.exe


        //****домены были придуманы для обслуживания своей исполняемой сборки и связанных с ней внешних библиотек кода


        // Как говорит автор, имя сборки также считается чем-то вроде разделителя. Если у тебя есть две сборки (MyCars.dll и YourCars.dll), и в
        //   каждой из них будет класс SportsCar, то мире .NET эти типы будут считаться разными
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // (ведь в .NET, т.е. в MSIL, возле полного имени класса нужно ставить ещё и имя сборки)
        //   /////////////////////////////////////////////////////////////////////////////////////////////


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   ManifestANDGACANDAttributesForAssembly_Silent()\n");
    }
}