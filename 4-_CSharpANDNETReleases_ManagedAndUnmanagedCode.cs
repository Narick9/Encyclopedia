/*
 * creation date  12 dec 2020
 * last change    07 nov 2021
 * author         artur
 */
using System;

class _CSharpANDNETReleases_ManagedAndUnmanagedCode
{
    static void Main()
    {
        Console.WriteLine("***** CSharp *****");

        CSharpANDNETReleases_Silent();
        ManagedAndUnmanagedCode_Silent();

        Console.ReadLine();
    }
    static void CSharpANDNETReleases_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   CSharpANDNETReleases_Silent()\n");


        // Джаббисты любят называть C# (и .NET) клоном Java, но шарфики не забывают напоминать, что те времена уже давно прошли, и что теперь
        //   уже Java уподобляется к детищу Microsoft (на момент выхода C# и вправду напоминал покоцанный Java с парой C++ штуковин). А все
        //   срачи из-за того, что оба этих похожих языка борятся за одну нишу - промышленный энтерпрайз. На самом деле синтаксис C# сильно
        //   напоминает Java из-за того, что оба языка относятся к семейству C-подобных языков (поэтому вернее сказать, все косплеят C)
        // Многие синтаксические конструкции C# смоделированы в соответствии с аспектами языков VB и C++.
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   //  Например, C# спёр из VB понятие свойств классов и необязательных параметров, а из C++
        //   //    позаимствованы идея перегрузки операций, структуры, перечисления и функции как
        //   //    параметр (здесь это вытекло в делегаты)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   Также во время чтения ты легко можешь заметить, что в C# не постеснялись добавить поддержку некоторых других средств, традиционно
        //   встречавшихся в других языках
        // Стоит признать, что Microsoft'цы изначально имели козырь в рукаве - они таки владельцы Wind'ы! Если пользователи Java-приложений
        //   обязаны ставить JVM на свою машину, чтоб хоть что-то запустить, то пользователи .NET-программ освобождены от этого (ведь инъекция
        //   .NET'а имеется на всех версиях Windows! начиная с xp'юшки)(весомый + для быдлоюзверов)
        // И ещё - концепт прослойки между high-level языком и машиной существовал ещё задолго даже до Джавы. Эту идею исследовали ещё в
        //   эру IBM мейнфреймов


        // Первая версия .NET'а была выпущена в 2002-ом. На момент своего рождения в он был медленен (ещё не успели всё зализать и
        //   оптимизировть), и в него входили всего несколько языков (Visual Basic и C#).
        //   Что интересно, именно VB дал сильный толчок к продвижению всего .NET, ведь учителя пересаживали школоту именно на него (из-за его
        //   простоты)(да, Melkosoft на тот момент уже освоил некоторые методы для управления биомассами). Началась война между .NET'ом и
        //   Java'ой
        // С выходом .NET 2.0 (2005-й год) C# научился обобщать (в C++, кстати, это называли шаблонами), и этого сильно бустануло его (в яве,
        //   правда, это произошло почти 1.5'а годами ранее)
        //   /////////after reading: AnonymousTypes,Lambda,Class//////////////////////////////////////////
        //   //  Лямбда-выражения и анонимные типы были украдены из LISP и Haskell и перенесены в C#
        //   //    также в версии .NET 2.0 (C# разрабатывается параллельно с .NET, поэтому он схватывает
        //   //    почти все его новинки сразу)
        //   //  Ключевое слово partial (с которым ты можешь определять класс сразу из нескольких файлов)
        //   //    также появилось в .NET 2.0
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // .NET 3.5 (2008-й год) превнёс такие полнезные вещи, как лямбда-выражения (=>) и новый синтаксис инициализации объектов (с ним можно
        //   задавать значения его полям прямо при создании. В Си был похожий процесс, что звался назначением инициализаторов)
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Ещё завезли LINQ (в сам язык - конкретно LINQ to Objects). Это, кстати, сделало C#
        //   //   довольно-таки уникальным в мире программирования. Шарфики в экстазе
        //   // Поддержка анонимных типов также появилась здесь
        //   // И расширяемые методы также были введены в этой версии .NET (и сразу вошли в C# 3.0)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   . Также примерно в это время .NET начал open-source'иваться (но далеко не весь. лицензия тоже всё ещё сильно связывала тебя, так
        //   что Microsoft'ский open source того времени был на деле semi-open source'ом)
        // Релиз .NET 4.0 (2010-й год, 12 апреля) является довольно знаменательным событием. Он дополнил C# рядом
        //   очень интересных средств. В C# 4.0 стал поддерживать необязательные, а также именованные аргументы в методах (C# 4.0 вышел
        //   11 апреля 2010, за день до .NET 4.0. прост .NET 4.0 до этого был в rc стадии)
        //   /////////after reading: Dyanmic,DLR//////////////////////////////////////////////////////////
        //   // . Введение ключевого слова dynamic (и целой инфраструктуры для него - DLR,
        //   // Dynamic Language Runtime, что стала частью новой версии CLR) открыло двери к .NET языкам
        //   // с динамической типизацией (вроде IronRuby и IronPython) и само по себе упростило
        //   // некоторые вещи, что раньше считались сложнейшими в реализации
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // В выпуске .NET 4.5 (это 15 aug 2012) C# обрёл пару новых ключевых слов (async и await), что, на этот раз, значительно упростили
        //   многопоточное и асинхронное программирование (раньше в C# как и в C++ приходилось задействовать определённые пространства имён и
        //   использовать всякого рода типы оттуда)
        //   //////// after reading //////////////////////////////////////////////////////////////////////
        //   // Правда, await нельзя было использовать в catch и finally блоках (возможно, на тот момент
        //   //   выходящие из await коды конфликтовали кодами от catch и finally)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // Версия C# 6 появилась в составе .NET 4.6 (это 20 jul 2015) и получила несколько мелких средств, что ещё раз упростили кодовую базу
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Появились автоматические свойства (напомню, что обычные свойства требуют кроме своего
        //   //   определения ещё и подконтрольное поле), а также встраиваемая инициализация для них
        //   //   (т.е. возможность задавать им значения по умолчанию)
        //   // Также здесь ввели возможность объявлять однострочные методы через =>
        //   // И возможность импортирования статических членов (using static ..) также ввели здесь
        //   // В C# 6 впервые появились null-условные операции
        //   // А ещё интерполяция строк ($"..{..}..")
        //   // try-catch блок также пробустили! Теперь можно отфильтровывать исключения через ключевое
        //   //   слово when, а await 
        //   // Ввели ключевое слово nameof(), что выдаёт строку из имён в твоём исходном коде
        //   // Упростилось использование всякого рода контейнеров типа словарь, т.к. появилась
        //   //   способность инициализации индексов
        //   //       (new ..() {..["foo"] = 1, ["bar"] = 2,..})
        //   // Пробустили распознование перегруженные версий
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // Прмерно здесь (это 27 jun 2016) Micro$oft'цы решили начать завоёвывать серверный сектор по крупному (поняв свою лажу с
        //   Windows Server). Они пошли в cross-платформу, и выпустили версию .NET для macOS'и и Linux'ов. Прозвали этого зародыша .NET Core
        //   (перед этим купив с потрохами проект Mono)(впервые .NET Core был затизерен в 2014-ом). .NET Framework (который уже прозвали
        //   "Classic" .NET) в этот момент имел версию 4.6.2.
        //   Вообще Microsoft в это время сильно сменила свою политику, и .NET с этого времени развивался именно в сторону open source'ости.
        //   Теперь Корпорация зла даже принимала помощь извне (но контроль всё также держала за собой)(очень похоже на то, что индусы
        //   разработали действтительно хитрый план)
        // И теперь мы пришли C# версии 7.0, что был выпущен вместе с .NET 4.7 (марте 2017).
        //   Новая версия, как и предыдущие, немного упращает кодовую базу и добавляет несколько (более значительных) средств
        //   (которые просили включить достаточно долго). Из незначительных изменений - появились маркеры L, F, U, M для чисел-литералов
        //   (обозначающие long, float, unsigned и decimal)
        //   //////// after reading //////////////////////////////////////////////////////////////////////
        //   // Теперь можно создавать переменную прямо в вызове метода, если ты оправляешь её к out
        //   //   параметру
        //   // Появились (так любимые мной) локальные фукнции (это действительно очень удобная вещь)
        //   // Ещё больше членов, сжадых до выражения (теперь это можно делать с конструкторами)!
        //   // Наибольшим новвоведением стали легковестные неименованные типы - кортежи (украдено из
        //   //   Python ****а может чего-то более древнего)
        //   // Операторы if теперь умеют сопостовлять generic тип (T, например) с нужным тебе типом в
        //   //   более простой форме (ключевое слово as)
        //   // Оффициально появилось отбрасывание (посредством имени _)
        //   // Посредством того же _ можно разделять группы в числах:    143_469    . Читабельность кода
        //   //   заметно улучшилась
        //   // Появилось возоможность вводить двоичные литералы посредством префикса 0b:    0b0101011
        //   // Теперь throw можно размещать в ещё некоторых местах, что раньше запрещалось (в
        //   //   лямбда-выражения, например)
        //   // Появилась возможность возвращать объекты по ссылке (через ключевое слово ref)(да, это
        //   //   заметно только для value type)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // Через некоторые время (сентябрь 2017) был выпущен C# 7.1
        //   //////// after reading //////////////////////////////////////////////////////////////////////
        //   // Теперь разрешили делать метод Main() асинхронным
        //   // Ввели ключевое слово (точнее, литерал) default, которое можно использовать вместо
        //   //   default(..) (default(int), например)
        //   // Наконец починили некоторые проблемы при сопоставлении с шаблоном в выражениях switch. В
        //   //       (switch { case 5: ..}    , например, неявно что такое 5. int, uint, long или ulong?
        //   //   ). Как это исправили? Теперь можно явно писать желаемый тип там, где встречается эта
        //   //   проблема. Например,    switch { case Circle c: ..}    ****сделал по догадкам из
        //   //   недописанного блока. скорее всего блок хотел сказать что-то другое
        //   // Теперь имена кортежей могут выводиться из проекций, что создаёт их (раньше так делали
        //   //   анонимные методы)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // ****(в определении интерфейсов у методов не должно стоять модификаторов доступа, по крайней мере до C# 8.0)
        // ...
        // 30 may 2018 - именно тогда был релизнут .NET Core 2.1. Из примечательного можно сказать, что Microsoft подхвотила принятую в
        //   GNU/Linux сообществе систему LTS (Long-Term Support). Теперь некоторые .NET версии (имеющие в примичании LTS) поддерживаются аж
        //   по 3'и года (обычные версии поддерживают лишь год). Каждые 2-а года выходит новая версия .NET'а с LTS
        // 20 nov 2020 - в .NET мире произошла cross-platform революция. .NET Core оффициально стал будущим всего .NET'а., и новая его версия
        //   получила название .NET 5. .NET Framework всё ещё юзабелен, и его поддерживают (а как же, ведь .NET Framework всё ещё имеет много
        //   того, чего не успели перевести в состав cross-platform'енного .NET 5). Индусы уверяют, что cross-platform'енный .NET имеет даже
        //   большую производительность. Microsoft заявляет, что 87% всех поддерживателей .NET'а - это независимое от них community (т.е.
        //   эти люди делают работу этой корпарации, не получая от неё ни гроша). Также Microsoft, посчитав, выдала инфу, что в мире аж
        //   > 5 миллионов .NET'чиков

        // Ты можешь строить C# приложения на Linux (необязательно через Xamarin Studio), можешь строить хоть на macOS (там, кстати, есть
        //   своя версия Visual Studio), и все они будут способны работать везде, где есть инфраструктура .NET (идея украдена у Java)

        // Для C# предусмотрен международный стандарт ECMA-334 (изначально расшифровывалась как European Computer Manufacturers Associations,
        //   но затем распространилась за пределы Европы. Организация появилась в 1960 году)


        // Структуры в C#
        void MyLocalFunction()  // void ..() {} - C# поддерживает такую штуку, как локальная функция. Введено в C# 7. На самом деле локальные
        {                       //   функции могут вкладываться в другие локальные функции. Локальные функции видят всё, что находятся в общих
        }                       //   с ней блоках (например, наша MyLocalFucntion() видит все объявления из CSharpANDNETReleases_Silent()). Саму её за
                                //   пределами блока с её объявлением не видно
                                // Локальные функции не могут использовать имена, что уже заняты в их области видимости (но имена полей они
                                //   брать могут)
        //int MyLocalFunction;  // int MyLocalFunction - на самом деле порядок чтения компилятора таков: сначала он читает локальные переменные
        //MyLocalFunction = 5;  //  , и только затем локальные функции. И тут я заметил у его логики одну особенность - если объявить
                                //  локальную переменную с именем, что уже имеет какая-нибудь локальная функция, то, во-первых, VS будет
                                //  выдавать сообщение об ошибке (пока всё логично). Но если дальше ниже попытаться использовать это имя
                                //  (думая, что ты используешь ту локальную переменную), то компилятор будет брать во внимание именно фукнцию
                                //  (т.к. он прочитал её имя последней)(да, этот нюанс вообще никак не может отразиться на конечное приложение,
                                //  т.к. существует только во время отладки)
                                /////////after reading///////////////////////////////////////////////////////////////////////
                                // Локальным функциям не доступны ref и out параметры методов, в которых они определены, они 
                                /////////////////////////////////////////////////////////////////////////////////////////////



        string myStr = new string('r', 5);  // new - этим ключевым словом в C# вызывается конструктор. Здесь мы использовали перегрузку
                                            //   конструктора String(char c, int count), что повторяет символ c count раз


        int i;
        //Console.WriteLine("i: {0}", i);  // = - в C# нельзя использовать незаданные локальные переменные


        int myInt1 = default(int);               // default(..) - задаёт значение для данного типа по умолчанию. Для System.Int32 это 0-ль.
                                                 //   Ссылочным типам назначает null
        int myInt2 = default;                    // default - нововведение C# 7.1 - упращённая запись default(..)


        Console.WriteLine("{0}\n", 252_853.000_04);  // _ - в C# 7 добавили полезную возможность разделять число с помощью символа _ для
                                                     //   улучшения читаемости. Необязательно выделять по три группы цифр


        Console.WriteLine("{0}\n", 0b0010_0110);  // 0b - также в C# 7 ввели двоичные литералы. Если они будут содержать что-то кроме 1 или 0,
                                                  //   выйдет ошибка компиляции


        Console.WriteLine(@"C:\Users\Public");  // @ - в C# есть так называемые дословные строки. Эти строки применяются как они есть, у них
        Console.WriteLine();                    //   отключено распознование управляющих последовательностей. В дословную строку также можно
                                                //   вставить символ ковычки, написав ""


        int age = 4;
        string name = "Soren";
        Console.WriteLine($"Hello {name}, you are {age} years old");  // $ - это называется интерполяцией строк. Несколько легче читать.
                                                                      //   Введено в C# 6
                                                                      //   /////////after reading:SystemString/////////////////////////////////
                                                                      //   // . У объектов этих метод ToString() вызывается, и строка
                                                                      //   // полученная уже вставляется
                                                                      //   ////////////////////////////////////////////////////////////////////
        Console.WriteLine($"{{hello}}");                              // {{..}} - так мы можем добавить {} в строку с $ (т.е. выведится
                                                                      //   "{hello}")


        Console.WriteLine($@"{Environment.CurrentDirectory}\Inventory.xlsx");   // $@".." - да, их можно комбинировать, но только в этом порядке
                                                                                //   (второй порядок разрешили только в C# 8.0)
                                                                                // Environment.CurrentDir.. - не обращай внимание, это пока что
                                                                                //   незнакомая для тебя вещь


        var ImInt = 5;                         // var - так выглядит неявная типизация в C#. Использовать var можно только для
        var ImBool = true;                     //   объявления локальных переменных, т.к. оно заменяется на нужный тип во время
        var ImString = "She's got the look.";  //   компиляции. Сам тип берётся у присваимого при объявлении значения
        int var = 725;                         // int - ещё интересно то, что формально var - это не ключевое слово языка.
                                               //   Его можно использовать как простое имя
                                               // Как оказалось, использование var там, где ты и сам легко можешь написать
                                               //   имя типа (т.е. просто потому, что он есть) некоторые считают плохим стилем
                                               //   (тип нелегко писать явно только при работе с LINQ)


        int Add(int x, int y) => x + y;  // => - это сокращённая форма записей, вроде   int Add(int x, int y) { return x + y; }   .
                                         //   Дополнительный синтаксис для старых операций обычно называют синтаксическим сахаром.
                                         //   Введено в C# 6


        void ChangeIt(out int ans)                    // out - это один из 3-х модификаторов параметра (не считая модификатора по умолчанию).
        {                                             //   Этот модификатор говорит о том, что переданная ему переменная обязательно должна
            ans = 5;                                  //   присвоить новое значение (если это не так, то компилятор выдаст ошибку)
        }                                             //   /////////after reading//////////////////////////////////////////////////////////////
                                                      //   // . Боксируются ли объекты структур и других value type? Нет, просто создаётся
                                                      //   //   ссылка, указывающая прямо на кусочек стёка
                                                      //   ////////////////////////////////////////////////////////////////////////////////////


        int sum = 90;
        Console.WriteLine("sum before:  {0}", sum);
        ChangeIt(out sum);                            // out sum - компилятор параметру с out позваляет передавать неинициализированную
        Console.WriteLine("sum after:  {0}\n", sum);  //   переменную, т.к. ей в конечном итоге обязательно присвоится значение. Из-за
                                                      //   этого, кстати, функция не может считывать значение из такого параметра
                                                      //   (даже если туда отправляется уже инициализированное значение). Начиная с
                                                      //   версии C# 7 больше нет нужды заранее объявлять переменную для параметра с
                                                      //   out - её можно объявить прямо в вызове:    Add(1, 52, out int sum);
                                                      //   Такие параметры обычно называют выходными
                                                      //
        ChangeIt(out _);                              // _ - ещё имя _ в .NET - это особая .. способность, что зовётся "отбрасывание" (или
                                                      //   discard на english'е). Если здесь ты вместо _ попробуешь написать какую-нибудь
                                                      //   другую неопределённую переменную, то получишь ошибку. Если здесь ты наведёшь курсор
                                                      //   на это _, то увидишь надпись от VS, что это    (discard) int _
                                                      // Ещё _ имеет одну особенность, связанную с местной конструкцией switch


        void SwapStrings(ref string s1, ref string s2)  // ref - принимает аргумент по ссылке, как C++. На этот раз свобода полная, разве что в
        {                                               //   такие параметры нельзя отправлять неинициализированные переменные
            string tempStr = s1;                        // ref string - здесь получается, что мы принимаем ссылку на ссылку. Теперь нам
            s1 = s2;                                    //   подвласен участок памяти с ссылкой, и мы можем подменить эту ссылку (заметь, что в
            s2 = tempStr;                               //   память самих объекто string мы не трогаем)
        }

        string str1 = "Flip";
        string str2 = "Flop";
        Console.WriteLine("Before:  {0}, {1}", str1, str2);
        SwapStrings(ref str1, ref str2);                // ref str1 - здесь также, как и с out, следует явно указывать модификатор
        Console.WriteLine("After:  {0}, {1}\n", str1, str2);

        ref string RefReturn(string[] strArray, int position)
        {                                               // ref () - так можно возвращать ссылки на объекты. Т.к. появилось эта возмножность в
            return ref strArray[position];              //    C# 7, что не так давно, то (наверное) это стало причиной видимого впиливания
        }                                               //    напильником поддержку ссылок вне функций (приходится ставить ref на каждом ходу)f

        string[] strCountries = { "Russia", "Canada", "Norway" };
        Console.WriteLine("Before:  {0}, {1}, {2}", strCountries[0], strCountries[1], strCountries[2]);
        ref string refOutput = ref RefReturn(strCountries, 2);
        refOutput = "Sweden";
        Console.WriteLine("After:  {0}, {1}, {2}\n", strCountries[0], strCountries[1], strCountries[2]);
        //                                              // ref ..() - да, ты должен везде (абсолютно) явно писать о том, что готов работать с
        //                                              //   таким-то модификатором параметра. На самом деле это выглядит довольно не плохо,
        //                                              //   т.к. такие особенности отражены прямо в коде, и ничего не скрывается
        //                                              // ref string .. - ещё стоит сказать, что переменная для хранения явной ref ссылки
        //                                              //   также должна быть явно объявлена как ref переменная и инициализирована другим ref
        //                                              //   чем-то (даже если у тебя итак имеется ссылочная переменная). ref нельзя
        //                                              //   приписывать к значениям, вроде "hello" (т.к. это rvalue, говоря языком Си). Это
        //                                              //   значит, что ты должен использовать другие ref переменные или ref методы:
        //                                              //       ref string leftStr = ref rightStr;    
        //                                              //   Ещё функция не может возвращать ref ссылку на локальную переменную
        //                                              /////////after reading/////////////////////////////////////////////////////////////////
        //                                              //   . И ещё - асинхронные методы не могут быть ref
        //                                              ///////////////////////////////////////////////////////////////////////////////////////


        //****модификатор in. О нём у меня ничего нет, т.к. появился он позже. Он создан, чтобы принимать параметры по ссылке без
        //   возможности их изменения. Для чего? Просто излишняя оптимизация, ведь так мы передаём легковестную ссылку, а не целую структуру


        // Здесь также работают суффиксы уточнения. Например,
        //
        //       float _ = 5.500F;    // ..F - (или f)
        //       decimal _ = 5.501M;  // Для decimal есть суффикс M (или m). Для long работает L (но не l. VS сообщает, что l легко спутать с
        //                            //   1)
        //
        // Эти суффиксы на уровне литералов сообщают компилятору, что это за тип. Иначе же при записи    double = 5;    компилятор бы переводил
        //   5 из int в double. Ещё есть маркеры L, F, U, M для long, float, unsigned и decimal


        double Average(params double[] values)   // params - так выглядит приём переменного числа параметров. Чтобы не было
        {                                        //   неоднозначности, требуется, чтобы модификатор params был только один, и он был
            double sum1 = 0;                     //   последним
            for (i = 0; i < values.Length; i++)
            {
                sum1 += values[i];
            }
            if (values.Length == 0)
            {
                return sum1;
            }
            return sum1 / values.Length;
        }

        Console.WriteLine("Average: {0}", Average(25.25, 59.52, 95.12));  // Average(..) - на самом деле CLR "за кулисами"
        double[] data = { 9.2, 9.5, 2.1, 3.6, 4.1 };                      //   автоматически упакуют эти значения в массив double[]
        Console.WriteLine("Average: {0}", Average(data));                 // data - конечено, массив можно передать сразу
        Console.WriteLine("Average: {0}\n", Average());


        void PrintLog(string message, string owner = "Programmer")   // = - поддержка необязательных параметров также есть (с C# 4)
        {                                                            /////////after reading////////////////////////////////////////////////////
            Console.Beep();                                          //   . Стоит сказать, что главной причиной добавления этого стало желание
            Console.WriteLine("ERROR of {0}: {0}", owner, message);  //   упростить работу с COM объектами (например, MS Office)
        }                                                            //////////////////////////////////////////////////////////////////////////
                                                                     // "" - также нужно помнить, что значение по умолчанию должно
        PrintLog("Oh no! Grid cannot find data");                    //   быть известно компилятору (это должнен быть литерал)
        PrintLog("Oh no! I can't find the payroll data", "CFO");     // , - а также они должны стоять после обычных параметров (чтобы
        Console.WriteLine();                                         //   избежать неоднозначности)



        Console.WriteLine(arg0: "musya", format: "hello, {0}\n");
        //      // : - так можно задавать параметры по именам. Необязательно следовать порядку в объявлении функции (введено в C# 4).
        //      //   До C# 7.2 именованные параметры должны стоять после обычных аргументов
        //      /////////after reading///////////////////////////////////////////////////////////////////////
        //      //   Причиной добавления опять же стало желание облегчить работу с COM (с этой возможность работа с COM методами, имеющими
        //      //   параметры по умолчанию, упростилась)
        //      /////////////////////////////////////////////////////////////////////////////////////////////


        /////////after reading:Attributes////////////////////////////////////////////////////////////
        // У атрибутов ещё есть синтаксис именованных свойств, что выглядит так:
        //
        //       [VehicleDescription(Description = "Roxy for everyone")]
        //              // Description - это string свойство в классе VehicleDescriptionAttribute.
        //              //   Этим синтаксисом мы можем присваивать что-то свойствам, если этого
        //              //   не позволяет конструктор
        //              // Синтаксис именованных свойств работает и с полями
        //
        /////////////////////////////////////////////////////////////////////////////////////////////


        // C# (а, точнее, .NET) поддерживают перегрузку методов (но не локальных функций. Как оказалось, функции прирвавниваются к
        //   переменным, и в одном блоке кода не может быть определено несколько одноимённых локальных функций). Посмотри на метод Add()


        string GetString()
        {
            return null;
        }
        string moreData = GetString() ?? "u lost it";                   // ?? - это называют операцией объединения с null. Его
        Console.WriteLine("Value of moreData is \"{0}\"\n", moreData);  //   суть в том, чтобы присвоить какое-то другое значение, если
                                                                        //   основное хранит null. Здесь, т.к. GetString() выдаст null, будет
                                                                        //   присвоено "u lost it". На самом деле это служит для сокращения
                                                                        //   объёмов кода


        void TesterMethod(string[] args)
        {
            Console.WriteLine($"TesterMethod:  you give {args?.Length} array");  // ? - это называется null-условная операция. Если
        }                                                                        //   args здесь окажется null, ошибки не будет (здесь
                                                                                 //   в выводе будет просто пустое место, а не число).
                                                                                 //   Если что-то вывести надо, то лучше сделать так:
        TesterMethod(null);                                                      //       {args?.Length ?? 0}
        Console.WriteLine();                                                     // null - в масштабных проектах часто в качестве параметров
                                                                                 //   поступают выводы других функций, которые могут возвращать
                                                                                 //   null


        int someInt = 59;              // someInt - константые переменные здесь работают скорее как constexpr из C++, т.к. обрабатываются
        //const int n = 25 + someInt;  //   компилятором (****возможно тупо подставляются как это делалось с #define)
                                       // 25 + someInt - компилятор не может знать, что здесь получится
        const int n = 25 + 48;         // 25 + 48 - а здесь может

        //const int cnsInt;            // ; - компилятор также не даст создать константу без значения


        object printMe;
        Console.WriteLine("{0}\n", nameof(printMe));  // nameof(printMe) - этот оператор выдаст имя того, что ты туда вписал, в виде строки.
                                                      //   В нашем случае мы получим "printMe"


        //####А вот и приоритеты операций в C#:


        Console.WriteLine("0 +1 is {0}", 0 + 1);  // 0 +1 - язык здесь считает + за операцию, а не за знак 1-ёрки
        Console.WriteLine("+1 is {0}\n", +1);    // +1 - хотя не в операциях язык считает это за знак. Запомни это, это довольно тонкий аспект


        //static int last;  // Ты можешь удивится, но C# не поддерживает статические локальные переменные (в отличие от Си)


        void Display<T>(T obj)  // ..<T>() - при виде использовании типа в обобщённом методе/типе компилятор не создаёт новую реализацию этого
        {                       //   класса (как в C++), а просто при вызовах смотрит на тип объекта. Правда (как и в C++), ты всё-ещё можешь
        }                       //   задвать этот тип вручную:    Display<int>(..);
        //
        // Вот некоторая полезная информация:
        //
        //   > В библиотеках .NET очень часто можно встретить обобщения
        //   > Начинка угловых скобок обобщений формально называется "параметрами типа", но также её часто зовут заполнителями
        //   > Обобщения могут работать с классами, структурами
        //     /////////after reading///////////////////////////////////////////////////////////////////////
        //     // интерфейсами, делегатами, но не с перечислениями (там они просто не нужны)
        //     /////////////////////////////////////////////////////////////////////////////////////////////
        //   > В необобщённых классах или структурах можно определять обобщённые методы
        //     ///////////after reading/////////////////////////////////////////////////////////////////////
        //     // (например, в классе Array есть статический метод Sort() и его обобщённый аналог Sort<T>())
        //     /////////////////////////////////////////////////////////////////////////////////////////////
        //   > IEnumerable<T> - обобщён только для того, чтобы передать тип T в IEnumerator<T>
        //   > ISet<T> : ICollection<T> - этот интерфейс есть только в System.Collections.Generic, и он гарантирует базовый интерфейс у тех,
        //     кто его реализует
        Display<int>(44);       // <> - на самом деле не обязательно явно отправлять тип, т.к. компилятор
                                //   в состоянии вывести его из аргументов сам (и VS намекает на это, затемняя <int> здесь).
                                //   Как говорит автор, явное выставление параметров типа - это хорошая практика, т.к. затем не приёдтся лишний
                                //   раз напрягать мозг
                                //
        void Swap<T>(ref T a, ref T b)
        {                                         // Swap<..>(ref..) - с модификаторами параметров обобщения также прекрасно работают
            T temp = a;
            a = b;
            b = temp;
        }
        void CreateClassObject<T>() where T : class, new()
        {                                         // where - этим можно выдвать определённые требования к отдельному параметру типа. Вот их
        }                                         //   список:
        //                                        //   > where T : struct     - T должен быть структурой
        //                                        //   > where T : class      - T должен быть классом
        // Возможно тебе никогда не понадобится   //   > where T : new()      - тип должен иметь стандартный конструктор (полезно, т.к.
        //   where, если ты не захочешь полной    //                            угадать набор параметров у другого не получится). new()
        //   безопасности в типах                 //                            должно быть в конце списка требований
        // Проверку where выполняет компилятор    /////////after reading/////////////////////////////////////////////////////////////////////
        //   (т.е. если что-то будет не так, то   //   > where : [класс]      - T должен быть сомвестимым с этим [класс]'ом. [класс] не должен
        //   ты это поймёшь ещё на компиялции)    //                            быть запечатанным (ведь незачем ограничивать обобщение чем-то
        //                                        //                            конкретным, оно перестанет быть обобщением)
        //                                        //   > where : [интерфейс]  - некий [интерфейс] должен поддерживаться типом
        //                                        //   > where : unmanaged    - T должен быть неуправляемым
        //                                        //   > where : notnull      - T не должен быть null. Появилось это ограничение в C# 8.0
        //                                        //   > where : default      - появилось в новейшем C# 9.0
        //                                        ///////////////////////////////////////////////////////////////////////////////////////////
        //                                        //   Если надо задать ограничения для нескольких типов, то просто используй where ещё раз:
        //                                        //       class SomeClass<T,R> where T: ... where K: ...
        //
        //T Sum<T>(T left, T right)
        //{
        //    return left + right;                // T + T - это может показаться удивительным, но попытке применить какую-нибудь операцию
        //}                                       //   с обобщёнными типами (у нас это T) компилятор выдаст ошибку. Почему? А потому что этот T
        //                                        //   может и не иметь оператора +. Проблема решается добавлением требования в виде
        //                                        //   класса-предка, имеющим нужный оператор
        //                                        /////////after reading///////////////////////////////////////////////////////////////////////
        //                                        //   (или ты можешь потребовать от типа интерфейс с нужными операторами)
        //                                        /////////////////////////////////////////////////////////////////////////////////////////////


        //****?: - тернарный оператор


        int j = 125;
        long k = j;      // long = int - это неявное преобразование. Неявные преобразования в местных стандартных типах происходят
        int l = (int)k;  //   автоматически, когда ты помещаешь данные из меньшего типа в больший (т.к. больший может их принять в полной мере)
                         // int = (int)long - а это явное преобразование. Оно необходимо, т.к. мы пытаемся впихнуть значение из типа
                         //   большего размера в контейнер меньшего, неспособного принять его всего (тут уже можно потерять часть числа, и
                         //   поэтому компилятор требует от тебя явного подтверждения приведения, возлагая всю ответственность на тебя)
                         /////////after reading///////////////////////////////////////////////////////////////////////
                         // Неявные и явные преобразования в C# должны задаваться в объявлении, на ровне с методами, индексаторами и всякими
                         //   операторами
                         /////////////////////////////////////////////////////////////////////////////////////////////


        //for (; ; )
        //{
        //    object abcdf = new object;
        //}
        long abcdf = 5;  // abcdf - в C#-пе есть интересная особенность - всё, что находится за пределами текущего блока - читается первым.
                         //   Т.е., например, здесь я объявляю переменную abcdf вроде как выше, в блоке for {}, и пытаюсь объявить это имя ниже
                         //   . Выходит, что ошибка о уже занятом имени возникает именно в for {}, да и вообще так происходит со всеми блоками


        double rate;
        if (true)
        {
            rate = 2.5d;   // if (true) { rate = .. } - компилятор достаточно умён, чтобы понять, что rate таки получает какое-то значение в
        }                  //   таких if-блоках. Даже если бы ты поставил в условии    2 + 2 == 4    , компилятор посчитал бы и это, и он бы
                           //   знал о присвоении rate
        Console.WriteLine("rate: {0}", rate);
        //
        double rate1;
        if (false)
        {
            rate1 = 3.5d;  // if (false) { rate1 = .. } - а здесь компилятор видит недосягаемый код, и rate1 остаётся для него unsigned
        }                  //   переменной
        //Console.WriteLine("rate1: {0}", rate1);
        //
        /////////after reading///////////////////////////////////////////////////////////////////////
        // В try-catch блоков компилятор также не признаёт присваивания, т.к. перед перед ними могут возникнуть исключения
        /////////////////////////////////////////////////////////////////////////////////////////////


        /////////after reading///////////////////////////////////////////////////////////////////////
        //  // Интересный код с метанита. Как ты думаешь, что в итоге выведится?
        //  //
            System.Collections.Generic.List<Action> actions = new System.Collections.Generic.List<Action>();
            for (var count = 0; count < 10; count++)
            {
                actions.Add(() => Console.Write("{0}, ", count));
            }
            foreach (var action in actions)
            {
                action();
            }
            Console.WriteLine();
        //  //
        //  // Правильный ответ:    10, 10, 10, 10, 10, 10, 10, 10, 10, 10,     . Ведь в каждый делегат отправляется ссылка на count, при этом
        //  //   сам count меняется
        //  //
        //  //
        //  // При этом в коде, что чуть ниже, всё идёт немного иначе
        //  //
            System.Collections.Generic.List<Action> actions1 = new System.Collections.Generic.List<Action>();
            foreach (int curr in new int[] { 1, 2, 3, 4, 5, 6 })
            {
                actions.Add(() => Console.Write("{0}, ", curr));
            }
            foreach (var action in actions1)
            {
                action();
            }
            Console.WriteLine();
        //  //
        //  // Здесь в каждый делегат попадают уже разные ссылки, и выйдет ожидаемый ряд
        /////////////////////////////////////////////////////////////////////////////////////////////


        if (true)
        {
            //goto label1;
        }
        else if (false)
        {
            //label1:                    //label1: - ты можешь удивиться, но этот label1 не видет goto, что чуть выше, т.к. он находится в
            Console.WriteLine("Luck!");  //  другом блоке. Да, goto здесь не так эпичен (хотя, может он и в Си не может так делать)
        }


        // Что будет здесь? Как ты думаешь (также скоммунизденно с метанита)?
        //
        int someInt1 = 0;
        someInt1 += Increment(ref someInt1);
        //
        Console.WriteLine(someInt1);
        Console.ReadKey();
        //
        int Increment(ref int num)
        {
            return num++;
        }
        //
        // А выйдет 0. Если раскрыть +=, то получится это:
        //
        //       someInt1 = someInt1 + Increment(ref someInt1);
        //
        //   Да, CIL код выполняется слева направо (не как в Си), т.е. получится
        //
        //       someInt1 = 0 + Increment(ref someInt1);
        //
        //   И в итоге - 0-ль


        // Операторы в C# не требуют прям таки беспробельного использования (т.е. тебе не обязательно писать что-то вроде    a+b    )(они
        //   вообще ни в каком языке этого не требуют). Оператор .-ки - тоже оператор (.NET Docs зовёт эту точку "dot" или "period"). Так что
        //   ты вполне можешь писать так:
                 Console    .    Write("");     //
        //   и даже так:                        //
                 Console                        //
                 .                              //
                 Write                          //
                 (                              //
                 ""                             //
                 )                              //
                 ;                              //
        //   . Ты даже можешь писать комментарии в пространствах между операторами:
                 Console    . /* */ Write("");


        // Ну и ещё одна важная деталь - компилер пропускает неиспользуемый код (****или CLR'овский JIT его не выполняет). Т.е. если ты
        //   объявишь переменную
        //   /////////after reading:Delegates/////////////////////////////////////////////////////////////
        //   // (даже задействуя сложнейших код в части после ='но)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   , но не задействуешь её дальше, то при запуске она в твоей программе не появится, память под неё не выделится
        /////////after reading:Delegates/////////////////////////////////////////////////////////////
        // Я однажды (если точнее, то 8 jun 2021) потратил много времени, не понимая почему вот этот
        //   вод код не работает:
        //
        //       int zeroCount = 0;
        //       var _  = new int[] { 235, 253, 4, 4, 0, 4, 0, 4, 0 }.Where(delegate (int n)
        //           {
        //               System.Console.WriteLine(".");
        //               if (n != 0)
        //                   return true;
        //               else
        //               {
        //                   zeroCount++;
        //                   return false;
        //               }
        //           }).Select(delegate (int n)
        //           {
        //               Console.WriteLine("count: {0}", zeroCount);
        //               return n;
        //           });
        //
        //   Всё заработало только после того, как я добавил ниже этот код:
        //
        //       Console.WriteLine("_.Length: {0}", _.Count());
        //
        /////////////////////////////////////////////////////////////////////////////////////////////


        /////////after reading:WindowsForms,WPF,ASP.NET//////////////////////////////////////////////
        // Вырезка слов из середины энциклопедии:
        //   "Как говорит автор, вряд ли тебе действительно понадобится строить консольное
        //   приложение в производстве. Подавляющее большинство приложений, что написаны на C# - это
        //   либо действительно развитые клиенты (что применяет графику из Windows Forms ил WPF),
        //   либо веб-приложения (что используют ASP.NET Web Forms или ASP.NET MVC). Консольные
        //   приложения применяются, чтобы не отвлекать внимание на ненужную сейчас структуру.
        //   Консольные приложения применяются, чтобы не отвлекать внимание на ненужной сейчас
        //   структуре. Как строить реальные энтерпрайз приложения ты узнаешь позже в энциклопедии"
        /////////////////////////////////////////////////////////////////////////////////////////////


        /////////after_reading:Casting///////////////////////////////////////////////////////////////
        // Вырезка слов из середины энциклопедии:
        //   Стоит помнить, что всякие операторы это всего-лишь сокращения для вызовов нормальных
        //   функций, и того же результата всегда можно добится другими путями
        /////////////////////////////////////////////////////////////////////////////////////////////


        // Ты должен понимать, что C# - это просто синтаксис, набор слов, а не что-то работающее (это относится вообще ко всем нефизическим
        //   языкам)


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   CSharpANDNETReleases_Silent()");
    }
    int Add(int left, int right)  { return left + right; }
    double Add(double left, double right) { return left + right; }  // .. Add(..) - если есть обобщённые функции - значит есть обобщённые
                                                                    //   методы (на самом деле это одно и то же)!
    long Add(long left, long right) { return left + right; }
    static void ManagedAndUnmanagedCode_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   ManagedAndUnmanagedCode_Silent()\n");


        // CIL-код, получаемый из кода C# умеет работать только в своей среде - среде .NET. Только CLR умеет выполнять этот код, и это очень
        //   сильное отличие .NET  мира от приложений C/C++. Выражаясь официально, для обозначения кода, ориентированного на исполняющую среду
        //   .NET, используется термин "управляемый код" (управляемый by .NET). Всё остальное (классические бинарные приложения) - это
        //   "неуправляемый код".
        // Собственно, от идеи отделения кода от привязанности к конкретному типу машины и ОС и растут ноги у способности запускасть .NET
        //   приложения на широком круге устройств


        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   ManagedAndUnmanagedCode_Silent()");
    }
}
