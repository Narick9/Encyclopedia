/*
 * creation date  05 jun 2021
 * last change    12 jul 2021
 * author         artur
 */
using System;
using System.Reflection;


[assembly: CLSCompliant(true)]  // [assembly..] - находится перед всеми объявлениями, всё правильно. Вообще, автор говорит, что именно такого
                                //   оформления кода и стоит придерживаться (using/[assembly]/namespace)
                                // System.CLSCompliantAttribute - теперь, если что-то несоместимое будет доступно за пределами сборки
                                //   (т.е. открытое), то VS выдаст warning'и


class _LateBinding_AttributesForAssemblyExtra
{
    static void Main()
    {

        Console.WriteLine("***** _ *****");

        LateBinding_Silent();
        AttributesForAssemblyExtra_Silent();

        Console.ReadLine();
    }
    static void LateBinding_Silent()  //after CIL
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   LateBinding_Silent()\n");


        // "Late Binding" ("позднее связывание") - так прозвали процесс, когда приложение создаёт
        //   объект неизвестного ему типа (например, из динамически подключённой сборки) в runtime. Да, название странное, и из-за него
        //   я поначалу часто путал late binding и dynamic linking (напомню, что dynamic linking - это когда мы подключаем сборку в runtime)


        // Всё позднее связывание .NET крутится вокруг класса System.Activator (класса, что предназначен для создания
        //   экземпляров типов с внешних сборок или получения их ссылок)(что определён в mscorlib.dll)(на удивление - не статического)
        //   (наследует от System.Object). Пока что нам интересен только один его статический метод - System.Activator.CreateInstance()


        Assembly myAsm = null;
        try
        {
            myAsm = Assembly.Load("14.2");          // 14.2 - да, эта сборка уже подключена к энциклопедии как закрытая, поэтому нам незачем
        }                                           //   здесь подключать её ещё раз. Но демонстрации возможностей
        catch (System.IO.FileNotFoundException ex)  //   повторное подключение не мешает
        {
            Console.WriteLine(ex.Message);  // ex.Message - полная трассировка слишком громоздка
        }
        object myObj = null;
        if (myAsm != null)
        {
            try
            {
                myObj = System.Activator.CreateInstance(myAsm.GetType("CarLibrary.MiniVan"));
                System.Console.WriteLine("And it is ... {0}", myObj);  // myAsm.GetType(..) - этим методом мы можем получить представление
            }                                                          //   нужного нам типа из сборки
            catch (System.Exception ex)                                // System.Activator.CreateInstance(..) - метод создаёт экмземпляр
            {                                                          //   объекта в стиле позднего связывания (по понятным причинам
                Console.WriteLine(ex.Message);                         //   возвращает его как object). Самая простая его версия принимает
            }                                                          //   объект System.Type (такая здесь и задействована)
                                                                       // На самом деле вместо двух вызовов ..CreateInstance(..GetType(..))
                                                                       //   можно было сделать один:
                                                                       //       myAsm.CreateInstance(..)
                                                                       //   Да, у объектов System.Assembly есть такой удобный метод
        }                                                              // System.Console.WriteLine("..", myObj) - да, здесь выйдет просто
        Console.WriteLine();                                           //   CarLibrary.MiniVan (я не переопределил метод ToString() для
                                                                       //   него)


        System.Reflection.MethodInfo myMethod = myAsm.GetType("CarLibrary.MiniVan").GetMethod("TurboBoost");
        myMethod.Invoke(myObj, null);   // Ты можешь спросить: "А как пользоваться его начинкой, если мы понятия не имеем что там?". А
                                        //   ответ прост - конечно же с с помощью рефлексии! Да, и создание объекта, и использование его
                                        //   методов завязаны с ней
                                        // ..GetMethod(..) - для начала нужно узнать, что это за метод и как им пользоваться
        // Это отличный пример          // myMethod.Invoke(..) - когда мы получили нужный нам объект MethodInfo, мы можем вызвать его,
        //   взаимосвязи рефлексии,     //   используя этот довольно гибкий метод (первым параметром он принимает объект, из которого он
        //   динамической линковки и    //   как-бы должен вызываться, а дальше идёт массив параметров типа object[]. Есть и более
        //   позднего связывани         //   специфичная версия)
        //   прямо в runtime            // null - если вызываемый метод не имеет параметров, можно просто отправить null
        //                              // Я уверен, что метод принимает массив object[] (а не модификатор параметра params) для того,
        //                              //   чтоб в будущем было меньше хлопот при добавлении новых перегрузок (ведь, как ты помнишь, после
        //                              //   params параметра новые ставить нельзя)


        // Ты мог уже заметить, что работа с типами и их членами здесь напоминает то, как это происходит в CIL коде (ну т.е. здесь мы тоже
        //   орудуем методами, а не самими объектами)


        // Если есть позднее связывание - значит есть и ранее. А о раннем ты и так всё знаешь (это стандартный способ, когда подключаемая
        //   сборка полностью известна ещё при компиляции)


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   LateBinding_Silent()");
    }
    static void AttributesForAssemblyExtra_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   AttributesForAssemblyExtra_Silent()\n");


        // Как ты знаешь, атрибуты можно задавать типу, члену типа, сборке или модулю. Также напомню, что атрибуты - это всего лишь примечания,
        //   и сами по себе они не на что не влияют (влияет код, что интерисуется конкернтными атрибутами)
        // Чтобы отличать атрибуты
        //   сборки от обычных атрибутов, создатели решили добавить в синтаксис особный дескриптор - [assembly:]
        // Некоторые из атрибутов уровня сборки (так любит выражаться Троелсен) относятся только лишь к сборке, а некоторые - ко всему её
        //   содержимому


        // Например, пусть нам нужно обеспечить совместимость всех открытых типов в этой сборке с CLS. Нашей цели можно добиться, просто
        //   добавив в начало этого файла (хотя можно и любого другого причастного к проекту) атрибута
        //   [assembly: CLSCompliant(true)]. Имей ввиду, что атрибуты уровня сборки или модуля должны находится
        //   перед всеми объявлениями в файле (как с using, но теперь даже не в namespace)


        // Файл AssemblyInfo.cs является удобным местом для размещения атрибутов сборки (т.к. он создан для этого)
        //
        // И Вот с этого места ты на самом деле уже много знаешь, ведь уже видел в методе про GAC как эти атрибуты задаются сборке
        //
        // Повторю, что большая часть метаданных уровня сборки в манифесте берётся именно из атрибутов. Вот основные атрибуты сборки:
        //   > [AssemblyCompany]      - атрибут для задания строки инфо о компании
        //   > [AssemblyCopyright]    - этот атрибут создан для хранение инфо о авторских правах на продукт или сборку
        //   > [AssemblyCulture]      - атрибут для хранения инфо о том, какие культуры или языки поддерживает сборка
        //   > [AssemblyDescription]  - этот атрибут нацелен на хранение общее описание продукта или модулей, из которых состоит сборка
        //   > [AssemblyKeyFile]      - атрибут для хранения пути к файлу с парой ключей, что нужны для создания строгого имени (его ты уже
        //                              применял)
        //   > [AssemblyProduct]      - этот атрибут предназначен для хранения инфо о продукте
        //   > [AssemblyTrademark]    - атрибут для хранения инфо о твоей торговой марке
        //   > [AssemblyVersion]      - этот атрибут создан для хранения инфо о версии сборки в формате
        //                              <старшийНомер.младшийНомер.номерСборки.номерРедакции> (его ты уже видел, и даже более подробно)
        //   Все атрибуты выше находятся в пространстве System.Reflection и представляют из себя System.Attribute + свойство типа string и
        //   конструктор для его задания


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   AttributesForAssemblyExtra_Silent()");
    }
}