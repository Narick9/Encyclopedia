/*
 * creation date  19 jun 2021
 * last change    30 jul 2021
 * author         artur
 */
using System;
using System.Reflection;

class _BreakpointsANDDiagnoticTools_DynamicTypeANDMicrosoftCSharpRuntimeBinderNamespace
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        BreakpointsANDDiagnoticTools_Silent();
        DynamicTypeANDMicrosoftCSharpRuntimeBinderNamespace();

        Console.ReadLine();
    }
    static void BreakpointsANDDiagnoticTools_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   BreakpointsANDDiagnoticTools_Silent()\n");


        // В VS есть такие штуки - breakpoint'ы. Ты можешь ставить такие в узкой области, что левее номеров строчек кода. При тыканьи там
        //   появится жирная красная точка. На этой строчке кода затем при запуске проги в Debug режиме выполнение и приостановится. Чтоб
        //   продолжить выполнение просто нажми Enter в той же консоли. Ты можешь наставить таких красных точек хоть к каждой строке
        //   . Инфо о местонахождении breakpoint'ов и других штучек для пользователя записано в
        //   .\.vs\<ИмяПроекта>\v16\.suo (ты уже знаком с этим файлом)
        //
        // Run -> Toggle Breakpoint (или F9) - это поставит breakpoint на текущей линии (т.е. линии с курсором)(****это проверено только в
        //   VS Code. что там в VS?)
        //
        // Ты можешь расставить точки остановки в коде, чтобы при запуске приложение останавливалось в этом месте (требуется Debug режим).
        //   Это даст возможность исследовать значения в переменных и показатели потребления памяти (в других языках для этого обычно
        //   приходилось добавлять код, который должен записывал эти данные в файл или консоль). Для этого достаточно тыкнуть мышкой по серой
        //   полоске в левой части редактора (той, что находится выше показателя масштаба редактора). На этом месте должна появиться красная
        //   точка, указывающая строку остановки (примерно на этом месте. Если в этой строке кода нет, точка появится там, где он начинается)
        // Если точка остановки сработала, в редакторе VS ты можешь наводить мышь на переменные для получения подсказки со значением в них.
        //   Также окно Diagnostic Tools представит графики использования памяти и CPU, заканчивающиеся на точке остановки. Для продолжения
        //   выполнения кода достаточно тыкнуть по кнопке Continue (она появится на месте кнопки Start, также с зелёной стрелкой), ну или
        //   нажать на F5
        // Точку остановки легко убрать, тыкнув на неё ещё раз
        //
        // Как ты понял, breakpoint'ы сильно облегчат тебе жизнь в Debug режиме


        // breakpoint'ы в VS Code также имеются (и работают ровно также, как это было в VS. Разве что при нажатии на F5 VS Code по умолчанию
        //   запустит проект в своей встроенной Debug Console, а не во внешнем cmd)
        // Чтоб продолжить выполнение программы после breakpoint'а, достаточно использовать всплывшее вверху меню (там есть треугольник). Можно
        //   также нажать на F5
        //
        // Значения переменных при breakpoint'е ты можешь посмотреть, в том же Debug меню (Run And Debug -> Variables). Там будут выведены те,
        //   что были объявлены в методе текущего breakpoint'а (даже те, что по C# коду будут объявлены после breakpoint'а. Ведь по CIL коду,
        //   как ты помнишь, все переменные объявляются в начале метода. В этих переменных будут записаны их default значения)
        //   . Начинку каждой переменной ты также можешь посмотреть, просто наведя на неё мышкой. Ещё в самом Run and Debug отделе VS Code'а
        //   будет список всех этих переменных, прямо со значениями
        // Эта фича с выводом начинок переменных работает только при breakpoint'ах! Приостанавливание программы посредством Console.ReadLine()
        //   не пробудит VS Code делать это!
        //
        // Недостаточно удобно? Ты хочешь, чтоб breakpoint срабатывал только в определённой итерации или только когда пользователь что-то да
        //   ввёл? Не проблема! Каждый breakpoint в VS Code можно настроить на любое условие! Достаточно тыкнуть ПКМ по нужной красной точке ->
        //   Edit Breakpoint.... Между строк после строки с этим breakpoint'ом откроется линия ввода этого условия (слева от этой строки будет
        //   предложен выбор типа Edit'а breakpoint'а. По умолчанию там стоит Expression. И он то нам и нужен). Условие пишется на том же C#'пе
        //   . Если ты хочешь, чтоб breakpoint срабатывал, только когда какая-нибудь переменная name будет хранить в себе строку "Stalin", то
        //   так и пиши:    name == "Stalin"    . Если это действительно окажется так, то breakpoint сработает
        // Кроме Expression'а в меню Edit'а предлагается Hit Count. В этом режиме breakpoint сработает, если его строка кода повторится
        //   столько-то раз. Это число ты вставляешь в той же междустрочной линии. Если вставишь что-то не то, Debug Console не станет
        //   жаловаться, и breakpoint будет работать как обычный (т.е. срабатываеть с первого раза)
        // ****Ещё в муню Edit'а есть выбор Log Message. не могу прочитать логи, т.к. Permission Denied даже через root
        //     breakpoint'ы, кстати, меняют свой значок в зависимости от типа Edit'а
        //
        // При interupt'е breakpoint'а в верхнем всплывающей менюшке написаны все действия, что ты можешь совершить. Ты можешь продолжить (F5),
        //   или же пошагать вручную по каждой инструкции кода:
        //
        //   > Stet Over (F10)(с надмозгового - ступить сверху) - идёт сразу после кнопки Continue. С ней ты можешь просто проходить по
        //       методам, не заходя в их код
        //   > Step Into (F11)(с англ. - ступить в) - с этой кнопкой ты как раз будешь заходить в код реализации всех методов, что встретятся (правда методы
        //       из внешних сборок, т.е. те, код которых VS открыть на C#'пе не сможет, также пропускаются)
        //   > Step Out (Shift+F11)(с надмозг. - выступить) - этим можно выйти из метода, в который ты зашёл через F11. Если же ты ни в какой
        //     метод не заходил, ты просто пройдёшь до следующего breakpoint'а (если такого нет, то сразу в конец программы)
        //
        //   Последние 2-е конпки - Restart (Ctrl+Shift+F5)(рестартит Debug) и Stop (Shift+F5)


        // Ты можешь изменить и удалить breakpoint прямо во время действия его interupt'а (это точно работает в VS Code'е, в VS не проверялось)


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   BreakpointsANDDiagnoticTools_Silent()");
    }
    static void DynamicTypeANDMicrosoftCSharpRuntimeBinderNamespace()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   DynamicTypeANDMicrosoftCSharpRuntimeBinderNamespace()\n");


        /////////after reading:DynamicAssemblies/////////////////////////////////////////////////////
        // Не путать с "динамическими сборками" (или это только я такой, что умудрился их спустать?)
        //   !
        /////////////////////////////////////////////////////////////////////////////////////////////


        var a = new System.Collections.Generic.List<int>();   // var - как мы помним, var - это всего лишь приспособление языка,
        //a = "hello";  // "hello" - ошибка компиляции        //   созданное для упрощения жизни человека. Живёт это слово до компиляции,
                                                              //   позже компилятор поставит на его место тип, чей объект переменная должна
                                                              //   иметь (он стоит за =). Напомню, что это называлось неявной типизацией
        object b = new System.DateTime();                   // object - ещё похожий эффект даёт использование System.Object, что может
        Console.WriteLine("it's {0}", ((DateTime)b).Year);  //   ссылаться вообще на всё. Правда, как только тебе понадобится использовать
        b = "hello";  // "hello" - но мы уже умеем          //   какой-то нестандартный член, придётся выполнить явное приведение. Но
                      //   получить другие данные           //   опять-таки, это та же строгая типизация
        dynamic c = new System.Globalization.JapaneseCalendar();  // dynamic - а это уже правдивая динамическая. Она появилась в C# 4.0, т.к.
        Console.WriteLine("{0}\n", c.ToString());                 //   она может серьёзно облегчить некоторые задачи. Появилась вся нужная
        c = "hello";  // = "hello" - можно считать, что c'шка     //   инфраструктура + ключевое слово dynamic для её использования
                      //   сменила    свой тип                    // Если в кратце, то dynamic - это некая форма System.Object - в той
                      // c.ToString() - да, IntelliSense без      //   части, что такая переменная может принять любое значение. В
                      //   понятия о том, что следует выводить    //   остальном, для компилятора динамические данные выглядят так, что они
                      //   при операции точки                     //   могут примерять на себя любую форму (тип) вместе с присваиваемыми
                                                                  //   данными
                                                                  // Для использования членов динамического типа нужно подключить сборку
                                                                  //   Microsoft.CSharp.dll. Без неё компилятор выводит ошибку о пропущеном
                                                                  //   элементе (о этой сборке также написано ниже)


        // Конечно, C# с версии 4.0 не перестал быть сильно типизированным языком (или строго)(т.е. обычная переменная имеет свой конкретный
        //   тип, что не может быть сменён). Вообще, языки делятся на два больших лагеря: типизированные и нетипизированные
        //   (бестиповые) языки. К первому относятся C, Java, Python, Scala, C#, PHP и Lua, а ко второму - ассемблеры, Forth и Brainfuck.
        //   Если бестиповая типизация проста как пробка и дальше не делится на подвиды, то типизированные языки можно разделить ещё на
        //   несколько чётких категорий:
        //
        //   > Статическая/динамическая типизация. Статическая определяется тем, что к каждой переменной тип устанавливается ещё при
        //     компиляции. Т.е. уже компилятор уверен на 100% какого она типа. В динамической типизации тип выясняются на месте (т.е. при
        //     использовании этой переменной). К статическим относятся C, Java, C#, Haskell. К динамическим - Python, Ruby, JavaScript
        //   > Сильная/слабая типизация (также иногда говорят строгая/нестрогая). Сильная типизация выделяется тем, что ты не сможешь
        //     вмешивать в своём выражении различные типы, т.к. такой язык не будет сам пытаться приводить типы (выполнять неявные приведения)
        //     (например, ты не сможешь запихнуть long в int. Это уже обсуждалось в начальных главах). При слабой типизации же всё куда
        //     интереснее - в них языку не
        //     страшны неточность и переполнение. К сильнотипизированным относятся Java, Python, Haskell, Lisp, C#, к слабо - C, JavaScript,
        //     Visual Basic, PHP
        //   > Явная/неявная типизация. Здесь всё просто: в явной типизации ты должен писать имя типа при объявлении новой переменной,
        //     при неявной - не должен (за тебя это сделает компилятор/интерпретатор). Языки с явной типизацией: C, D, C# (без var). С
        //     неявной - PHP, Lua, JavaScript
        //
        //   Наш C# имеет статическую (и одновременно динамическую, благодаря псевдо-типу dynamic) сильную явную (и неявную с var)
        //   типизацию


        dynamic boolData = false;
        try
        {
            boolData.GetMyMoney();                                        // ..GetMyMoney() - при работе с членами dynamic переменной
        }                                                                 //   есть одно очень важное НО - компилятор не проверяет их
        catch (Microsoft.CSharp.RuntimeBinder.RuntimeBinderException ex)  //   допустимость! Он может знать члены только статических
        {                                                                 //   переменных и не возится с запоминанием текущего типа у
            Console.WriteLine("{0}", ex.Message);                         //   динамических
                                                                          //   /////////after reading:DynamicType//////////////////////////
                                                                          //   // . За этим следит среда DLR (о ней ниже) прямо в
                                                                          //   // runtime  (****но это неточно)
                                                                          //   /////////////////////////////////////////////////////////////
        }                                                                 //   
        Console.WriteLine();                                              // ..RuntimeBinderException - т.к. у System.Bool нет такого метода
                                                                          //  , выходит именно это исключение


        // А теперь о пространстве Microsoft.CSharp.RuntimeBinder. Как уже было написано, эта сборка (Mycrosoft.CSharp.dll) нужна для работы с
        //   динамическими переменными.
        //   Она автоматически подключается для всех новых проектов VS (за исключением Empty Project..). В этой сборке хранится исключение
        //   Microsoft.CSharp.RuntimeBinder.RuntimeBinderException (его мы и получили в прошлом методе), что генерируется при любой несостыковке
        //   твоих вызовов с реальными членами
        // Т.е., фактически, тебе не нужно это пространство, если ты не будешь ошибаться с их членами (ага, конечно, так и будет. На самом деле
        //   в некоторых случаях они неизбежны)
        // В этой сборке, вообще, 4-е типа (****из которых мне, почему-то, доступны только 2-а)


        // Если var может использоваться только там, где за знаком = стоит что-то, то dynamic может использоваться везде (точнее, там, где
        //   можешь вписать обычный тип)


        // С динамическими типа есть одна странная особенность - с его членами ты не можешь юзать анонимные методы (и, как сахар для них,
        //   лямбда-выражения)(это связано с тем, что, компилятор попросту игнорирует всё, что связано с dynamic, и поэтому не переводит
        //   расширяющий метод в нормальный делегат
        //   ):
        //
        //       dynamic a = GetDynamicObject();
        //       a.SomeMethod(i => 2 * i);  // 'нельзя использовать лямбда-выражение как аргумент..'
        //
        //   Этот код тупо не скомпилируется. В таких случая придётся работать с объектами delegate напрямую
        //   /////////after reading:DLR///////////////////////////////////////////////////////////////////
        //   // . Работу с dynamic кодом CLR затем скинет на свой модуль DLR
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // Ещё ограничение заключается в том, что динамический элемент не воспринемает расширяющие методы (по тем же причинам). И что также
        //   очень не приятно, т.к. API-интерфейс LINQ to Objects и другие LINQ технологии держатся на них, ты будешь сильно ограничен в их
        //   использовании:
        //
        //       dynamic b = GetDynamicObject();
        //       var data = from h in b select h;  // 'выражения запросов над .. типом dynamic или со входящей последовательностью типа
        //                                         //   dynamic не разрешены'


        // Не смотря на минусы (недосмотр компилятором и IntelliSense'ом, невозможность использования лямбда-выражений, невосприятие
        //   расширяющих методов), динамическая типизация в C# очень спасает в некоторых (хоть и редких) ситуациях. При работе с поздним
        //   связыванием ключевое слово dynamic может сократить время при наборе клавиш (очень сильно сократить). Та же ситуация и при
        //   работе с библиотеками COM (они, кстати, входят в состав в продукты MS Office) - dynamic может сильно упростить кодовую базу.
        //   Если ты часто будешь работать с сайтами, что применяют шаблон проектирования MVC, то нередко применяемый там тип ViewBag
        //   позволит тебе производить доступ к себе в такой же упращённой манере (т.е. через dynamic)
        //
        // Ещё стоит сказать, что (видимо) при введении в C# 4.0 инфраструктуры для динамической типизации, сборки C#
        //   стали совместимы со сборками от IronRuby и IronPython, где вообще нет статической типизации (2.5 анонимуса неимоверно рады!)
        //   /////////after reading:DLR///////////////////////////////////////////////////////////////////
        //   // (****интересно, а как там дела обстояли до добавления в .NET DLR?)
        //   /////////////////////////////////////////////////////////////////////////////////////////////


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   DynamicTypeANDMicrosoftCSharpRuntimeBinderNamespace()");
    }
}