/*
 * date    30 nov 2020
 * author  artur
 */
using System;
using System.Threading;
using static IssuesOfConcurrency_.IssuesOfConcurrency;

using System.Threading.Tasks;
using System.Linq;

namespace CLRThreadPool_TPL
{
    static class CLRThreadPool
    {
        static void Main()
        {
            Console.WriteLine("***** CLRThreadPool *****");

            Preview();

            Console.ReadLine();
        }
        static void Preview()
        {
            Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Preview()\n");


            // Следующей темой в этой книге, связанной с потоками, будет роль пула потоков CLR (что уже упоминался пару раз в этой главе). При
            //   асинхронном вызове метода (через BeginInvoke()) CLR не создаёт поток в прямом смысле слова. В целях эффективности
            //   BeginInvoke() задействует пул рабочих потоков, которая, если говорить вкратце, по своему организует потоки (автоматически).
            //   Для взаимодействия с этим пулом в том же пространстве System.Threading предлагается статический класс ThreadPool (по размерам
            //   он чуть меньше среднего)
            // Чтобы получить поток из пула для обработки какого-нибудь метода, можно использовать ThreadPool.QueueUserWorkItem(). Он имеет
            //   перегрузку, которая в дополнении к экземпляру делегата WaitCallback (что создан специально для работы с ThreadPool) может
            //   принимать необязательный параметр object для последующей передачи его в метод (в случае использования первой версии
            //   ThreadPool.QueueUserWorkItem() параметру object передаётся просто null). Если запрос прошёл хорошо, возвращается true. Если
            //   что-то пошло не так - сразу выбрасывается исключение System.NotSupportedException
            // Сами экземпляры делегата WaitCallback могут хранить любые функции и методы, что соответсвуют сигнатуру void (object)


            void PrintNumbersParameterized(object printer)  // PrintNumbersParameterized - да, это всего-лишь обёртка над метод из позапрошлого
            {                                               //   проекта, подстраивающая его под текущую ситуацию
                ((Printer)printer).PrintNumbers();          // (Printer)printer - вызывать метод PrintNumbers() мы будем из того объекта, что
            }                                               //   будет нам сослан

            Printer myPrinter = new Printer();
            for (int _ = 0; _ < 7; _++)
            {
                ThreadPool.QueueUserWorkItem(new WaitCallback(PrintNumbersParameterized), myPrinter);  // myPrinter - а использовать мы будем
            }                                                                                          //   один объект для всех вызовов

            Thread.Sleep(100);      // Thread.Sleep() - нам стоит приостановить основной поток, чтобы заврешились все второстепенные
            Console.Write("\n\n");


            // Чем же выгоднее использовать пул потокв, поддерживаемый средой CLR, по сравнению с ручным созданием объектов Thread? Вот
            //   преимущества, что обеспечиваются им:
            //
            //   > Пул потоков эффективно управляет потоками, сводя к минимуму их количество (как ты знаешь, каждый поток должен создаваться,
            //     запускаться и останавливаться, а ведь эти операции стоят процессорного времени)
            //   > Пул потоков берёт на себя управление потоковой инфраструктурой приложения, и ты можешь лучше сосредоточиться на решении
            //     своих задач
            //
            // Тем не менее, в некоторых случая лучше всё-таки управлять потоками вручную. Ниже есть примеры
            //
            //   > Когда нужны потоки именно переднего плана или должен устанавливаться приоритет потока. Потоки пула всегда фоновые и обладают
            //     стандартным приоритетом (т.е. ThreadPriority.Normal)
            //   > Когда требуется гибкость, вроде возможности прервать, приостановить или находить по имени отдельный поток
            //


            // Итак, на этом исследование пространства System.Threading завершено. Полученные в этой главе сведения несомненно ценны при
            //   написании многопоточных приложений (особенно ценна информация в разделе о проблеме праллелизма). А теперь давай переключим
            //   внимание на несколько новых аспектов, связанных с потоками, что появились в .NET 4.0. Для начала мы обратимся к альтернативной
            //   потоковой модели, что называется TPL (Task Parallel Library)


            Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Preview()");
        }
    }




    static class TPL
    {
        static void Main()
        {
            Console.WriteLine("***** TPL *****");

            Preview_Silent();
            SystemThreadingTasksParallel();
            SystemThreadingTasksParallelInvoke();

            Console.ReadLine();
        }
        static void Preview_Silent()
        {
            Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Preview_Silent()\n");


            // Ты уже знаешь две технологии програмирования для создания многопоточных приложений (асинхронный вызов и члены в пространстве
            //   System.Threading. Да, автор называет это технологиями), и обе они работают в любой версии .NET
            // Начиная с .NET версии 4 Microsoft ввели новый подход - применение библиотеки TPL. С помощью типов из System.Threading.Tasks
            //   (все они вместе и есть TPL) можно строить мелкомодульный масштабируемый код безо всякой необходимости работать с потоками
            //   напрямую (и с пулом потоков тоже). Это небольшое пространство, и в нём всего 2 несущих класса и набор вспомогательных к
            //   ним
            // На самом деле это не значит, что тебе не придётся использовать типы из System.Threading. Они всё ещё естественно сочетаются
            //   с TPL. Суть в том, что с TPL решать те же самые задачи гораздо проще (примитивы из System.Threading, вроде Monitor или
            //   Interlocked, файтически делают то же самое, что и древнейшие мьютексы из Си. System.Threading.Mutext, кстати, тоже есть)
            // Кстати, имей в виду, что ключевые слова async и await базируются на разнообразных членах пространтсва System.Threading.Tasks

            // Библиотека TPL (а если точнее, типы в ней) распределяют нагрузку приложения между доступными процессорами в динамическом
            //   режиме, т.к. применяет пул потоков CLR. Также TPL может разбить работу на части, планировать потоки, управлять их
            //   состоянием и управлять ещё многими другими низкоуровневыми деталями. Т.е. начиная с .NET 4 ты можешь полностью доверится
            //   TPL, получая при этом почти максимальную производительность при этом ничего не делая (т.е. делая даже меньше, чем при
            //   работе с потоковым пулом)
            // Вообще, пространство насчитывает 17 типов


            Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Preview_Silent()");
        }
        static void SystemThreadingTasksParallel()
        {
            Console.WriteLine(">->->->->->->->->->->->->->->->->->->   SystemThreadingTasksParallel()\n");


            // Основной класс TPL - это Parallel. Этот статиеческий тип имеет набор методов для итерации по коллекциям в параллельной
            //   манере. В нём определно всего 3 метода - Parallel.For(), Parallel.ForEach() и Parallel.Invoke() (но каждый из них имеет
            //   перегруженные версии. И часто много). Как ты понял, его главные методы повторяют семантику циклов for и foreach.
            //   Преимущество в том, что Parallel будет сам извлекать потоки из пула и управлять ими
            // И Parallel.For(), и Parallel.Foreach() требуют передачи совместимого с IEnumerable или IEnumerable<T> контейнера
            //   (Parallel.For() получает i начального элемента и i конечного, а Parallel.Foreach() просто проходит по контейнеру).
            //   Вдобавок понадобится применять делегаты System.Func<T> и System.Action<T>, т.к. именно они применяются для указания кода
            //   блока

            // Слышал ли ты когда-нибудь о "параллелизме данных"? Это когда коллекция данных делится на какие-то (обычно равные) части,
            //   каждую из которых обрабатывает свой отдельный процесс. Собственно, это и происходит в методах Parallel.For() и
            //   Parallel.ForEach()
            // В документации .NET Framework 4.7 SDK приведён пример решения задачи, когда требуется загрузить в память много *.jpg
            //   изображений, повернуть их и сохранить модифицированные копии в новое место. Мы решим её с использованием графического
            //   интерфейса, чтобы взглянуть на "анонимных делегатов" (так автор прозвал делегаты с анонимными методами), позволяющих
            //   вторичным потокам обновлять поток пользовательского интерфейса
            // На самом деле доступ к окну GUI может иметь только поток, в котором он создан, т.к. элементы упровления (это кнопки,
            //   текстовые поля, метки, индиакторы хода работ и т.п.)(довольно интересно, почему это так)(VS выведен исключение времени
            //   выполнения System.Runtime.InteropServices.ExternalException: 'A generic error occurred in GDI+.'). Здесь мы решим эту
            //   проблему через общие переменные, что будут изменятся вторичными потоками и читаться потоком, отвечающим за GUI. Конечно же
            //   , всё это в безопасной к потокам манере (хотя здесь это не столь критично). Когда мы узнаем побольше о async и await языка
            //   C#, будет предложен более простой подход
            // Подробнее о VS: при отладке многопоточного приложения VS часто способна перехватывать ошибки, когда вторичный поток обращается к
            //   элементам управления GUI, созданным в первичном потоке. Однако нередко при запуске того же приложения в не-Debug режиме,
            //   оно может выглядеть, как работающее корректно, не падая от этого исключения (или же ошибка может возникнуть позже). Не стоит
            //   оставлять программу с потенциальной ошибкой
            // Автор решает создать новый проект шаблона WPF App (.NET Framework). Изначально я планировал остаться здесь и зделать всю
            //   работу для использования графики вручную (так мы бы знали все аспекты, что задействованы в ней), но изрядно помучавшись,
            //   я решил всё-таки следовать книге. В папке 19.6.1 текущего проекта будет создан новый проект, и работа будет вестись в нём
            //   (но общее описания процесса проходит здесь, в этом файле)
            // Сама инфраструктура Windows Presentation Foundation будет подробно рассматриваться в гл.24-26, но все типы и их члены, что
            //   здесь применяется, имеют описание в моих комментариях

            // Для начала автор приказал поместить довольно большой код в файл MainWindows.xaml (этот файл появляется вместе с проектом),
            //   сказав не заморачиваться на счёт его содержимого сейчас (мы всё-таки немало времени проведём над этм вопросом в будущем).
            //   Видимо, это код разметки содержимого окна, что будет выводить наше новое приложение. Вообще, XAML -
            //   eXtensible Application Markup Language (т.е. расширяемый язык разметки приложений)
            // В этом файле этим кодом мы разметили окно, что будет содержать многострочное текстовое поле (в файле это область TextBox),
            //   и одну кнопку (область Button, имя кнопки - cmdProcess). Суть нашего GUI в том, что пользователь будет способен вводить
            //   туда что-то своё во время выполнения обработки картинок, и это должно демонстрировать многопоточность приложения

            // В файле MainWindow.xaml.cs (Solution Explorer -> .. -> MainWindow.xaml -> MainWindow.xaml.cs) написан код некоторой логики.
            //   Картинки я решил взять из папки, где винда хранит обои экрана блокировки (их там немного, но они красивые)

            // В отдном из методов применяется такой класс, как System.Windows.Threading.Dispatcher. В комментарии его метода уровня
            //   экземпляра Invoke() в общих чертах описана суть этого класса, но более обширное объяснение я напишу здесь. Все потоки
            //   приложения сгруппированы в apartments (или подразделения). Их два вида:
            //
            //   > Single-threaded apartments (STA)(однопоточные подразделения)
            //   > Multi-threaded apartments (MTA)(многопоточные подразделения)
            //
            // Как понятно из названия, в STA может использоваться только 1-н поток. Все объекты, что находятся в STA, могут использоваться
            //   только из него. Этим объектам не нужна синхронизация. Этому подразделению нужно иметь очередь, чтобы другие потоки также
            //   могли использовать объекты из него (они добавляют свои запросы в очередь, и код в этих запросах затем по очереди выполняет этот STA
            //   поток этого STA, когда добирается до неё).
            // MTA же хронит 1 и более потоков. Все объекты доступны всем этим потоком, и каждый из них сам ответственен за свою потоковую
            //   безопасность (это подразделение используется по умолчанию)
            // WPF приложения всегда запускается именно в STA, и поэтому ты не сможешь обратится к его объектам (объекту окон, как у нас,
            //   например) через потоки извне (даже созданные этим главным по подразделению потоком). Когда ты стартуешь WPF приложение, в
            //   нём автоматически создаётся объект System.Windows.Threading.Dispatcher и вызывается статический метод Run() этого же
            //   класса, что и инициализирует очередь (скорее всего, эти действия производит статический конструктор)
            // Ещё стоит сказать, что запуск WPF приложения проходит после создания средой CLR двух потоков для него:
            //
            //   > Render thread (этот поток просто рисует графику)
            //   > UI thread (а это уже поток, что выполняет прописанную тобой логику)
            //
            //   UI поток как раз отвечает за чтение ввода, обработку событий и вид элементов окна. WPF Dispatcher связывается именно с ним
            // Как все объекты в WPF приложении хранят ссылку к одной очереди? Так вот - класс System.Windows.Threading.DispatcherObject
            //   всем своим предкам предоставляет поле для хранения этой очереди (он абстрактный) в виде объекта класса
            //   System.Windows.Threading.Dispatcher (а этот - запечатанный), а каждый класс WPF с уровнем экземпляра (будь то окно, кнопка
            //   или textbox) имеет его в вершине своего древа. Когда создаётся новая кнопка, её конструктором вызывается защищённый
            //   конструктор из DispatcherObject, что и инициализирует свойство Dispatcher общим для всего приложения объектом Dispatcher
            // На самом деле напрямую работать с очередью тебе не придётся. От этого объекта Dispatcher нам нужны только два метода -
            //   Invoke() и BeginInvoke() (и оба будут описаны в книге. Invoke() уже описан)


            Console.WriteLine(">->->->->->->->->->->->->->->->->->->   SystemThreadingTasksParallel()");
        }
        static void SystemThreadingTasksParallelInvoke()
        {
            Console.WriteLine(">->->->->->->->->->->->->->->->->->->   SystemThreadingTasksParallelInvoke()\n");


            // Кроме возможности распараллелить обработку данных наш статический класс Parallel умеет и просто создавать кучу рабочих потоков
            //   для обработки кучи методов в асинхронной манере (каждому делегату будут выдано по потоку, если это возможно). Это делает метод
            //   System.Threading.Tasks.Parallel.Invoke()
            // Такой подход немного проще, чем использование делегатов или пространства System.Threading (т.к. не придётся создавать циклы для
            //   запуска кучи потоков). Минус этого метода в том, что ты теряешь львиную долю возможностей контроля над создаваемыми потоками
            //   (задание ParallelOptions - предел здесь)
            // Допустим, нам нужно загрузить публично доступную книгу из сайта проекта Гутенберга (www.gutenberg.com) и выполноть над ней
            //   некоторые действия (имей ввиду, что если ты не заходил раньше на этот ресурс, то с первого раза загрузить данные не получится,
            //   т.к. на этой странице выйдет ненужное нам окно с сообщением)


            System.Net.WebClient myWC = new System.Net.WebClient();  // WebClient - этот довольно большой класс предоставляет набор методов
            string theEBook = string.Empty;                          //   для отправки и получения данных по заданному URI ресурсу (uniform
            bool isComplete = false;                                 //   resource identifier) (URI вмещает в себя всем известный URL и ещё
            // isComplete - чтобы наш (главный) поток мог дождаться  //   URN). Определение этого типа находится в System.dll. На самом деле
            //   второстепенного, был создан этот маркер. Как        //   класс имеет не очень много основных методов, но каждый из них имеет
            //   оказалось, ..Monitor и ..Mutex не могут             //   ещё несколько специальных версий и события ..Completed). Например,
            //   заблокировать свой поток (если поставишь два        //   myWC.DownloadString() имеет версию myWC.DownloadStringAsync(),
            //       ..Monitor.WaitOne(...);    друг за другом, они  //   задействующую пул потоков (и мы её будем использовать). По завершению
            //   не остановят поток                                  //   этот асинхронный метод запустит события myWC.DownloadStringCompleted
                                                                     // На самом деле сейчас мы не станем разбирать инет-составляющую часть
                                                                     //   .NET, просто автор решил этим заглянуть наперёд

            myWC.DownloadStringCompleted += (sender, exArgs) =>      // myWC.DownloadStringCompleted - как понятно из названия, этот event
                {                                                    //   произойдёт, когда операция асинхронной загрузки завершится. Имя этого
                    theEBook = exArgs.Result;                        //   событие - DownloadStringCompletedEventHandler, а прототип -
                    Console.WriteLine("Download complete");          //   void ..(object sender, DownloadStringCompletedEventArgs e)
                    GetStats();                                      // exArgs.Result - сам по себе класс DownloadStringCompletedEventArgs
                };                                                   //   определяет одно свойство -    public string Result { get; }    (что
                                                                     //   возвращает прочтенную страницу в виде (обычно) гигантской строки.
                                                                     //   Остальные несколько свойств достаются от предков
                                                                     // myWC.DownloadStringAsync() - это один из основных методов объектов
                                                                     //   System.Net.WebClient. Он загружает данные по определённому URI в
                                                                     //   отдельном потоке (и поэтому возвращает void). Как раз для того, чтобы
                                                                     //   обработать результат, мы и подготовили event чуть выше

            myWC.DownloadStringAsync(new System.Uri("http://www.gutenberg.org/files/98/98-8.txt"));
            Console.WriteLine("Downloading the book...");            // myWC.DownloadStringAsync() - основная логика этого метода будет
                                                                     //   запущена во второстепенном потоке, который, в свою очередь,
                                                                     //   задействует множество других потоков для загрузки
            void GetStats()
            {
                string[] words = theEBook.Split(new char[] { ' ', '\u000A', ',', '.', ';', ':', '-', '?', '/' },
                    System.StringSplitOptions.RemoveEmptyEntries);   // theEBook.Split() - как понятно из названия, этот метод разделяет строку
                                                                     //   на множество мелких. Эта перегрузка принимает массив символов, по
                string[] tenMostCommon = null;                       //   которым строка и будет резаться, и значение перечисления
                string theLongestWord = string.Empty;                //   System.StringSplitOptions (в нём всего 2-а поля - наше и None)
                System.Threading.Tasks.Parallel.Invoke(              // \u000A - юникодовский (UTF-16) символ новой строки
                    () => tenMostCommon = FindTenMostCommon(words),
                    () => theLongestWord = FindLongestWord(words));

                System.Text.StringBuilder bookStats = new System.Text.StringBuilder("Ten Most Common Words are:\n");
                foreach (string curr in tenMostCommon)               // ..StringBuilder - ты не забыл про этот тип строк (pr.3.3)?
                {                                                    //   StringBuilder'ы способны меняться (и это небольшой класс)
                    bookStats.AppendLine(curr);                      // bookStats.AppendLine() - как Console.WriteLine(), но выход добавляется
                }                                                    //   в объект StringBuilder
                bookStats.AppendFormat("Longest word is: {0}", theLongestWord);
                bookStats.AppendLine();                              // bookStats.AppendFormat() - работает как String.Format() (и этим также
                                                                     //   похож на одну из перегрузкок Console.WriteLine())

                Console.Write("{0}\n", bookStats.ToString());        // Console.Write() - на самом деле автор имел в строке кода ещё и это:
                                                                     //       .., "Book info");    , что никак ни на что не влияет

                isComplete = true;
            }
            string[] FindTenMostCommon(string[] words)
            {
                var frequencyOrder = from word in words
                                     where word.Length > 6           // where word.Length > 6 - сразу отсеиваем некрупные слова
                                     group word by word into g
                                     orderby g.Count() descending    // g.Count() - этот расширяющий метод выдаст нам число символов в строке g
                                     select g.Key;                   //   . Исходит он из статического класса System.Linq.Enumerable. Как мы
                return frequencyOrder.Take(10).ToArray();            //   помним, такие классы могут иметь расширяющие методы
                                                                     // descending - как мы помним (гл.12), этим ключевым словом LINQ мы
                                                                     //   добиваемся сортировки контейнера от большего к меньшему
                                                                     // g.Key - выдаст элемент из контейнера, т.е. строку
                                                                     // frequencyOrder.Take() - этот расширяющий метод оставит нам столько
                                                                     //   элементов из всейго контейнера, сколько мы скажем (а сказали мы 10)
            }
            string FindLongestWord(string[] words)
            {
                return (from w in words orderby w.Length descending select w).FirstOrDefault();
            }                                                        // (from..).FirstOfDefault() - выдаст или первый элемент в контейнере, или
                                                                     //   значение по умолчанию того те типа (default(int), например.
                                                                     //   default(string) выдаст null. Да, мы раньше ты не видел этого)


            while (!isComplete)  // while (!isComplete) - пока что это всё, что мы можем
            {
                Thread.Sleep(50);
            }


            Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   SystemThreadingTasksParallelInvoke()");
        }
    }
}
