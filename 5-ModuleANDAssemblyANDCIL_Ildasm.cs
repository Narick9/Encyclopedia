/*
 * creation date  23 dec 2020
 * last change    12 aug 2021
 * author         artur
 */
using System;

class ModuleANDAssemblyANDCIL_Ildasm
{
    static void Main()
    {
        Console.WriteLine("***** Assembly *****");

        ModuleANDAssemblyANDCIL_Silent();
        Ildasm_Silent();

        Console.ReadLine();
    }
    static void ModuleANDAssemblyANDCIL_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   ModuleANDAssemblyANDCIL_Silent()");


        // "Модуль" - это отдельный .NET файл с концовкой .dll или .exe. Модуль можно получить, скомпилировав управляемый код. Да,
        //   подключаемые библиотеки кода здесь принято называть модулями
        // Исполняемый .exe файл плюс набор модулей, что он использует, - это "сборка" (или "assembly"). Важно отметить, что приложения с
        //   управляемым .NET кодом имеют те же расширения файлов, что и классические двоичные программы с неуправляемым кодом, хотя внутренне
        //   они устроены совершенно по-разному (ведь классические приложухи выполняет сразу писишник, а .NET сборки читать умеет лишь CLR)
        // И
        //   только уже CLR во время запуска переводит CIL код в сборках в машинный код)
        //****дальше автор (и я) называл сборкой любой .dll/.exe файл. может для всех это синонимы?
        // Среда CLR не переводит CIL код в сборках в иснтрукции, специфичные для текущей машины, до тех пор, пока
        //   не станет абсолютно необходимым (для перевода, точнее, компиляции, CLR задействует JIT компилер в себе). Обычно
        //   "абсолютная необходимость" наступает только тогда, кода его вызывают из другой части кода (т.е. метод сидит непереведённым до тех
        //   пор, пока его не вызовут)


        // В дополнение к инструкциям CIL сборки также содержат "метаданные", что детально описывают характеристики каждого типа,
        //   задействованного в коде. Среда CLR не читает определения типов, она сразу смотрит в подготовленный мануал к нему (на самом деле
        //   определения типов и переводятся компилятором в этот мануал. Определений типов в CIL коде не бывает). В этом мануале описаны все
        //   члены этого типа (имена членов,
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // реализуемые интерфейсы,
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   базовые классы, конструктора и т.п.). Неоднозначностей не возникает. Метаданные .NET всегда присутсвуют внутри сборки и
        //   автоматически генерируются компилятором языка .NET
        // Метаданные типов широко применяются не только исполняющей средой .NET, но и всякого рода инструментами разработчика. Например,
        //   средство IntelliSense из VS (что подсказывает тебе имеющиеся члены типов, и вообще всей начинки кода), стало возможожным (так
        //   говорит автор) именно благодаря чтению метаданных
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Как ты понял, метаданные типов стали принципиальной основой многих .NET технологий,
        //   //   включая WCF, рефлексию, позднее связывание и сериализацию
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // Хранение полного описания типов в метаданных - это ключевой элемент и отличительная черта .NET
        //
        /////////after reading:ildasm,System.Reflection****и что-то ещё,AssemblyInfo.cs////////////////////////////////////////////////////////////
        // Каждый тип, что определён в сборке, документируется в метаданных типов с применением маркера TypeDef #n (n это просто порядковый
        //   номер, который выставляет компилятор по мере чтения). Если описывается внешний тип, то он помечается маркером TypeRef #n.
        //   Например, вот так выглядит перечисление CarLibrary.EngineState из 14.2 в метаданных типов (через ildasm.exe):
        //
        //       TypeDef #3 (02000004)
        //       -------------------------------------------------------
        //             TypDefName: CarLibrary.EngineState  (02000004)                                // TypDefName - этим устанавливается
        //             Flags     : [Public] [AutoLayout] [Class] [Sealed] [AnsiClass]  (00000101)    //   имя заданного типа
        //             Extends   : 01000014 [TypeRef] System.Enum                                    // Extends - этот класс расширяется
        //             Field #1 (04000005)                                                           //   типом (интересно, а что там у
        //       	   -------------------------------------------------------                       //   System.Object? Описания внешних
        //                   Field Name: value__ (04000005)                                          //   типов немного другой структуры)
        //                   Flags     : [Public] [SpecialName] [RTSpecialName]  (00000606)          // Field #n - этим указывается каждое
        //                   CallCnvntn: [FIELD]                                                     //   поле перечисления
        //                   Field type: I4
        //       
        //             Field #2 (04000006)
        //         	   -------------------------------------------------------
        //                   Field Name: engineAlive (04000006)
        //                   Flags     : [Public] [Static] [Literal] [HasDefault]  (00008056)
        //             DefltValue: (I4) 0
        //                   CallCnvntn: [FIELD]
        //                   Field type: ValueClass CarLibrary.EngineState
        //
        //             Field #3 (04000007)
        //       	   -------------------------------------------------------
        //                   Field Name: engineDead (04000007)
        //                   Flags     :[Public] [Static] [Literal] [HasDefault]  (00008056)
        //             DefltValue: (I4) 1
        //                   CallCnvntn:[FIELD]
        //                   Field type:  ValueClass CarLibrary.EngineState
        //
        //   Как мы видим, это был третий тип, что увидел компилятор
        // А теперь посмотрим на метаданные класса Car (а точнее их часть):
        //
        //       TypeDef #2 (02000003)
        //       ------------------------------------------------------ -         // ..--- - - это не ошибка. Пробел здесь действительно есть
        //             TypDefName: CarLibrary.Car(02000003)
        //             Flags:[Public] [AutoLayout] [Class] [Abstract] [AnsiClass] [BeforeFieldInit]  (00100081)
        //             Extends: 01000010[TypeRef] System.Object                   // Extends - как мы видим, класс Car расширяет object
        //             ...                                                        // Flags - эти разнообразные флаги говорят о том, как
        //             Field #1 (04000001)                                        //   класс был сконструирован. Здесь видно, что этот
        //             -------------------------------------------------------    //   класс был открытым и абстрактным (и ещё много каким)
        //       	         Field Name: <PetName> k__BackingField (04000001)     // Field - здесь также есть поля
        //       	         Flags     : [Private]  (00000001)                    // <PetName> k_.. - заметь, это раньше было автомачиским
        //       	         CallCnvntn: [FIELD]                                  //   свойством. Здесь оно стало просто закрытым полем и
        //       	         Field type:  String                                  //   парой методов (и также записьё Property #n)
        //             ...
        //       	   Method #1 (06000004)                                                           // Method #.. - этим помечаются
        //       	   -------------------------------------------------------                        //   методы класса
        //       	         MethodName: get_PetName (06000004)                                       // MethodName - и также можно
        //       	         Flags     : [Public] [HideBySig] [ReuseSlot] [SpecialName] (00000886)    //   узнать много подробностей о
        //       	         RVA       : 0x0000208c                                                   //   каждом
        //       	         ImplFlags : [IL] [Managed] (00000000)
        //       	         CallCnvntn: [DEFAULT]
        //       	         hasThis
        //       	         ReturnType: String
        //       	         No arguments.
        //       	   ...
        //       	   Method #2 (06000005) 
        //       	   -------------------------------------------------------
        //       	         MethodName: set_PetName (06000005)
        //       	         Flags     : [Public] [HideBySig] [ReuseSlot] [SpecialName] (00000886)
        //       	         RVA       : 0x00002094
        //       	         ImplFlags : [IL] [Managed] (00000000)
        //       	         CallCnvntn: [DEFAULT]
        //       	         hasThis
        //       	         ReturnType: Void
        //       	         1 Arguments
        //       		           Argument #1:  String
        //       	         1 Parameters
        //       		           (1) ParamToken : (08000001) Name : value flags: [none] (00000000)
        //       	   ...
        //       	   Property #1 (17000001)                                   // Property #.. - само свойство также что-то да говорит
        //       	   -------------------------------------------------------  //   о себе
        //       	         Prop.Name : PetName (17000001)
        //       	         Flags     : [none] (00000000)
        //       	         CallCnvntn: [PROPERTY]
        //       	         hasThis
        //       	         ReturnType: String
        //       	         No arguments.
        //       	         DefltValue: 
        //       	         Setter    : (06000005) set_PetName                 //
        //       	         Getter    : (06000004) get_PetName                 // Setter/Getter - эти маркеры отсылают к методам
        //       	         0 Others
        //****всё, что здесь идёт дальше по метаданным, почему-то не относится к типам. может метаданные типов описывают не только типы?
        //    стоит проверить прокомпилировав
        // А вот так в метаданных описываются внешние сборки (сюда попадают только те, что использовались внутри исследуемой сборки):
        //
        //       TypeRef #14 (0100000e)
        //       ------------------------------------------------------ -
        //       Token:             0x0100000e
        //       ResolutionScope:   0x23000001
        //       TypeRefName:       System.Reflection.AssemblyFileVersionAttribute
        //             MemberRef #1 (0a00000d)
        //             -------------------------------------------------------
        //                   Member: (0a00000d) .ctor:
        //                   CallCnvntn:[DEFAULT]
        //                   hasThis
        //                   ReturnType: Void
        //                   1 Arguments
        //                         Argument #1:  String
        //
        //   Как мы видим, в сборке вызывался конструктор типа System.Reflection.AssemblyFileVersionAttribute (правда не нами. Скорее всего
        //   это делал компилятор во время чтения AssemblyInfo.cs)
        // В этом окне также (после всех TypeDef и TypeRef) можно найти информацию о самой сборке. Она исключительно помечается маркером
        //   Assembly:
        //
        //       Assembly
        //       -------------------------------------------------------
        //             Token: 0x20000001
        //             Name: 14.2
        //             Public Key    :
        //             Hash Algorithm : 0x00008004
        //             Version: 1.0.0.1
        //             Major Version: 0x00000001
        //             Minor Version: 0x00000000
        //             Build Number: 0x00000000
        //             Revision Number: 0x00000001
        //             Locale: <null>
        //             Flags : [none] (00000000)
        //       ...
        //
        //   Некоторые из этих данных ты также можешь просмотреть в окне MANIFEST. Здесь не включена часть с многочисленными кастомными
        //   атрибутами (о них чуть позже)
        // Дальше идут метаданные для внешних ссылок. Помечаются они маркером AssemblyRef #n и структурированы почти также, как и данные
        //   под маркером Assembly:
        // 
        //       AssemblyRef #2 (23000002)
        //       -------------------------------------------------------
        //             Token: 0x23000002
        //             Public Key or Token: b7 7a 5c 56 19 34 e0 89
        //             Name: System.Windows.Forms
        //             Version: 4.0.0.0
        //             Major Version: 0x00000004
        //             Minor Version: 0x00000000
        //             Build Number: 0x00000000
        //             Revision Number: 0x00000000
        //             Locale: <null>
        //             HashValue Blob:
        //             Flags:[none] (00000000)
        //
        //   Как мы помним, System.Windows.Forms применялся в объектах типов SportsCar и MiniVan
        // Ну и в самом конце задокументированы все строковые литералы, что использовались в коде сборки. Помечены они маркером UserStrings
        //   (в Си и, вроде как, в ассемблере литералы тоже вшивались в конечный бинарник):
        //
        //       User Strings
        //       -------------------------------------------------------
        //       70000001: (20) L"***** Assembly *****"
        //       7000002b: (47) L">->->->->->->->->->->->->->->->->->->   Demo()\n"
        //       7000008b: (46) L"<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Demo()"
        //       700000e9: (14) L"Ramming Speed!"
        //       70000107: (17) L"Faster is better!"
        //       7000012b: ( 4) L"Eek!"
        //       70000135: (27) L"Your engine block exploded!"
        //
        //   (поэтому никогда не храни пароли зашитыми прямо в сборке!)
        //
        // На самом деле ниже есть ещё одна штука:
        //
        //       Coff symbol name overhead:  0
        //       ===========================================================
        //       ===========================================================
        //       ===========================================================
        //
        //   Но автор ничего про это не упоминал
        //
        // Помимо чистого интереса всю эту информацию можно использовать и в реальных проектах, но сначала необходимо
        //   познакомиться со службами рефлексии .NET
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        // Наконец, каждая сборка хранит в себе также и подробное описания себя. Эти метаданные сборки официально зовутся "манифестом".
        //   Манифест содержит такие вещи, как версия этой сборки, сведения о культуре (для того, чтобы CLR использовала нужные шрифты
        //   локализации) и список всех внешних сборок (чей код используется в текущей сборке), и даже информацию об авторских правах (и ещё
        //   несколько малозначительных вещей)
        //   /////////after reading:ManifestANDGAC////////////////////////////////////////////////////////
        //   // . По большей части эти данные в манифест записываются из атрибутов, что ты записываешь
        //   // в файл .\Propterties\AssemblyInfo.cs своего проекта
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // Такая детализация также отбрасывает нужду в обращении к реестру Windows, что приходилось делать для выяснения местанахождения
        //   внешних .dll библиотек при использовании модели COM (да, раньше новоиспечённая сборка вносилась в реестр). Это было весьма
        //   неудобно. Позже же Microsoft'цы всё хорошенько обдумали, и теперь все разделяемые сборки лежат просто списком в одном месте
        //   /////////after reading:ManifestANDGAC////////////////////////////////////////////////////////
        //   // (в GAC'е)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   (на самом деле они опять спёрли идею из unix мира. Там либы также лежат просто списком в папке. Правда, в gnu/Linux'ах со временем
        //   этих папок стало больше одной, /lib/, /lib64/, /usr/lib/, /usr/lib64/, это сильно зависит от дистрибутива)
        // Все эти описания (т.е. метаданные) создаются компилятором
        //
        // Как уже говорилось, каждой сборке назначается номер версии. Стостоит он из четырёх частей в форме
        //   <старшийНомер>.<младшийНомер>.<номерCборки>.<номерРедакции> (по умолчанию VS выставляет сборке 1.0.0.0, если твой проект
        //   не создан как Empty Project). Есть индустриальный стандарт, что зовётся "semantic versioning":
        //
        //       > Major version - первое число (<старшийНомер>). Изменение здесь означает,
        //                         что код в сброке сильно поменялся, следует ожидать
        //                         того, что какие функции пропали или переименовались
        //       > Minor version - второе число (<младшийНомер>). Изменение говорит о том,
        //                         что в сборку просто добавили новых фич
        //       > Patch version - третье число (<номерСборки>). Изменение означает, что в коде
        //                         были сделаны какие-то незначительные поправки
        //
        //  ****с приходом .NET 5 теперь только 3 числа в версии?


        // Если собрать всё вместе, то структура сборки состоит из этих элементов:
        //   > заголовок файла Windows             - свидетельсвует от том, что сборку можно запускать в ОС Windows. Также этот заголовок
        //                                           идентифецирует тип приложения (консольное, с GUI или библиотека кода .dll), которое
        //                                           должно обслуживаться Windows (наверное, для функционирования каждого типа Windows
        //                                           должен подготовить что-то). Чтобы просмотреть информацию загаловка Windows сборки,
        //                                           нужно использовать утилиту dumpbin.exe (в консоли), указав флаг /headers и написав
        //                                           имя сборки с расширением .dll или .exe (этот инструмент находится в пакете со
        //                                           средствами профилирования C++)(также подойдёт corflags.exe
        //                                           /////////after reading////////////////////////////////////////////////////////////////////
        //                                           // или ildasm.exe
        //                                           //////////////////////////////////////////////////////////////////////////////////////////
        //                                           ). На самом деле, если ты не разрабатываешь компилятор .NET, то тебе незачем разбираться в
        //                                           тонкостях этого заголовка. Просто достаточно знать, что их использует Windows при
        //                                           загрузке сборки в память для запуске (но могу сказать, что PE означает, что это
        //                                           Portable Executable сборка)
        //   > заголовок файла CLR                 - есть у всех сборок .NET
        //                                           /////////after reading////////////////////////////////////////////////////////////////////
        //                                           // Хранит многочисленные флаги, с которым среда CLR может читать файл конфигураций (если
        //                                           // он есть)(его ещё называют управляемым файлом)
        //                                           //////////////////////////////////////////////////////////////////////////////////////////
        //                                           . Там хранится инфо о том, где внутри сборки лежат метаданные и другие ресурсы. Также там
        //                                           версия исполняющей среды (т.е. runtime'а), для которой была написана сборка,
        //                                           /////////after reading////////////////////////////////////////////////////////////////////
        //                                           // значение открытого ключа (если оно есть)
        //                                           //////////////////////////////////////////////////////////////////////////////////////////
        //                                           и т.д. Для просмотра всего этого также можно использовать тот же dumpbin.exe, но с
        //                                           флагом /clrheader (если верить одному чуваку, то    2.05 runtime version    на самом деле
        //                                           не показывает версию CLR, и вообще имеет с ним мало общего. Для .NET 4.x CLR имеет версию
        //                                           4.0.30319
        //                                           /////////after reading////////////////////////////////////////////////////////////////////
        //                                           // , и это можно посмотреть в манифесте с помощью ildasm.exe, где она подписывается как
        //                                           // Metadata version
        //                                           //////////////////////////////////////////////////////////////////////////////////////////
        //                                           ). И снова стоит понимать, что практической ценности знание деталей этого заголовока также
        //                                           не имеет (если, конечно, ты не причастен к разработке самого CLR)
        //   > код CIL                             - это, собственно, сам код сборки. Из себя, как говорилось в самом начале, он
        //                                           представляет промежуточный язык, полученный с помощью компилятора из какого-то .NET
        //                                           языка. Во время выполнения этот CIL-код с помощью JIT-компилятора (это часть CLR) на
        //                                           лету компилируются ещё раз, но теперь в инструкции, специфичные для текущей
        //                                           платформы (также дважды компилируется и код Java). Благодаря такой схеме твоя сборка
        //                                           может запускаться везде, где есть CLR
        //   > метаданные типов                    - полностью описывают формат внутренних и внешних типов (сюда попадают только те, что
        //                                           используются в сборке). Исполняющая среда использует это для выяснения местоположения
        //                                           типов (и их челнов) внутри файла сборки, для размещения их объектов в памяти и для
        //                                           упращения удалённого вызова их методов (в общем, когда ты используешь какой-то тип, инфо о
        //                                           нём берётся отсюда)
        //   > манифест сборки                     - также каждая сборка должна содержать манифест (ещё называемый метаданными сборки).
        //                                           Он документирует каждый модуль внутри сборки
        //                                           /////////after reading////////////////////////////////////////////////////////////////////
        //                                           // (но в ildasm, правда, этого я не видел)
        //                                           //////////////////////////////////////////////////////////////////////////////////////////
        //                                           , устанавливает её версию и указывает на требуемые внешние сборки. Среда CLR интенсивно
        //                                           использует этот манифест в процессе нахождения ссылок на внешние сборки
        //   > дополнительные встроенные ресурсы   - наконец, сборка может содержать любые другие ресурсы, вроде значка приложения,
        //                                           файлов изображений, звукозаписи и т.д. .NET поддерживает подчинённые сборки, которые
        //                                           созданы для хренения ресурсов локализации (т.е. языков) и ничего другого. Они
        //                                           используются, когда нужно отделить ресуры на разных языках при построении
        //                                           интернационального приложения. Создание подчинённых сборок выходит за рамки текущей
        //                                           книги (но всю информацию сожно найти в мануалах .NET 4.7 Framework)
        //   Первые два элемента обычно не трогают


        // Ты, возможно, уже понял, что все .NET приложения - это всего-лишь верхушка айсберга, т.к. держатся они на громадной BCL. Они не
        //   автономны (в отличие от многих Си-программ), и ось не сможет запустить их без задействования CLR и подключения пары-тройки
        //   .dll-шек (если на твоей оси, нет CLR, работать с приложухами на шарфике ты не сможешь)


        // Из-за того, что метаданные .NET (для типов и сборки) настолько основательны, сборки являются целиком самоописательными сущностями
        //   (они чётко говорят что им нужно и какой версии. Также в них написано что в них есть)


        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   ModuleANDAssemblyANDCIL_Silent()");
    }
    static void Ildasm_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Ildasm_Silent()\n");


        // Утилита ildasm.exe (Intermediate Language DisASseMbler) была создана для того, чтобы кто-то мог исследовать сборки .NET. Ты
        //   указываешь ей на сборку (введя отностельный или полный путь), и она выдаст тебе абсолютно всё её содержимое - включая манифест,
        //   метаданные типов и сам CIL код. Запускается она из коммандной строки Developer PowerShell for VS .. (обычный PowerShell не знает о
        //   ней), но к счастью для 95% разработчиков, утилита графическая, поэтому не придётся дальше возиться в cmd
        // Ты можешь указать сборку как в cmd, так и в самом графическом меню утилиты (через File -> Open)
        // Хотя для того, чтобы стать опытнам программистом, использовать ildasm.exe необязательно, автор настоятельно рекомендует время от
        //   времени использовать этот инструмент, т.к. через него ты увидишь, что действительно будет выполнятся во время запуска (правда,
        //   перед этим тебе стоит ещё познать и язык CIL)
        //
        // Пример того, что выдаёт ildasm.exe, ты можешь посмотреть в методе AssemblyANDCIL

        

        // ildasm.exe выдаст представление твоих типов в древовидной структуре. На высшем уровне находится манифест и первый уровень метаданных
        //   типов (на самом деле уровней у него нет, я просто так выразился) - это корневые пространства имён и классы, что
        //   не входят ни в одно пространство имён. Дальше, спустя вложенные пространства имён, находятся всякого рода типы. Во вложении
        //   каждого типа ты можешь посмотреть его начинку. Определение (красный треугольник) - это описание самого типа, ниже (розовый
        //   квадрат) - это конструктор. Дальше видны методы типа (розовый квадрат с буквой S посередине)
        // Дважды тыкнув на имя метода ты можешь узресть сам CIL код, описывающий этот метод и инструкции в его блоке

        // На самом деле метаданные типов можно посмотреть и в цельно (чтоб было понятно класс это или структура, увидеть модификатор доступа,
        //   ещё несколько атрибутов
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // (атрибутов в местном понятии. Вроде Serialization)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   , можно посмотреть на базовый класс)(но без кода). Для всего этого следует открыть окно View -> MetaInfo -> Show!
        // Эти метаданные служат основой для многочисленных технологий
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // (сериализации объектов, позднего связывания, расширяемых приложений и т.д.)
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // Также этой утилитой (в cmd режиме) можно просмотреть у нужной сборки заголовок Windows (****указав флаг /headers и путь к сборке?)


        // Если ты уже успел дважды тыкнуть на M A N I F E S T, то, наверное, заметил, что он также написан на CIL


        // Чтобы открыть нужную сборку, достаточно написать так:
        //
        //       ildasm <targetAssembly>.exe


        // Код CIL из сборок при желании можно сохранить в отдельный файл (который ты затем спокойно можешь читать и редактировать
        //   /////////after reading: CILExtra/////////////////////////////////////////////////////////////
        //   // . это, как ты помнишь, зовётся ревер-инжинерией
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   ). Открой нужный .exe/.dll в ildasm.exe, нажми File -> Dump -> OK, сохраняй низкоуровневый CIL-код в какой-нибудь *.il файл
        //   Вместе с *.il ildasm.exe сгенерирует ещё и одноимённый .res файл с низкоуровневой инфой для CLR, касающейся безопасности, и ещё с
        //   чем-то (этот файл можно спокойно удалить. ****Троелсен не захотел разбирать этот файл)
        //   Если ты откроешь этот *.il (в любом редакторе, там просто текст), то увидишь желанный CIL-код + всякие другие метаданные
        //   /////////after reading: CILExtra/////////////////////////////////////////////////////////////
        //   // (о том, как устроен CIL код (и файлы с ним, что выдаются из ildasm.exe), ты можешь снова
        //   // почитать в методе CILExtra_..())
        //   /////////////////////////////////////////////////////////////////////////////////////////////


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Ildasm_Silent()");
    }
}
