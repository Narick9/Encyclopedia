/*
 * creation date  12 dec 2020
 * last change    05 nov 2021
 * author  artur
 */
using System;

partial class ClassAndInterface_StructAndOOPAndSystemNullable
{
    static void Main()
    {
        Console.WriteLine("***** _ *****");

        ClassAndInterface_Silent();
        StructAndOOPAndSystemNullable_Silent();

        Console.ReadLine();
    }
    static void ClassAndInterface_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Class_Silent()\n");


        // В .NET классы - это всегда "ссылочный тип". Это значит, что их переменные - это всего лишь ссылки на сам объект класса,
        //   хранящегося в это время управляемой части кучи со сборкой мусора


        // Каждый .NET язык, по меньшей мере, поддерживает тип класса (ведь без BCL в .NET вообще никак). Класс - это краеугольный камень всего
        //   ООП (объектно-ориентированного программирования). Посмотри на класс Calc, чтобы увидеть пример определения класса в C#
        // Вот характеристики, что могут быть у местных классов:
        //
        //   >  Является ли класс запечатанным?             - запечатанные классы нельзя наследовать (их не могут расширять другие классы). Для
        //                                                    запечатывания класса нужно добавить ключевое слово sealed в определение класса
        //   >  Реализует ли класс какие-то интерфейсы?     - интерфейс - это коллекция членов, что класс обязательно должен иметь. В
        //                                                    интерфейсах определяются прототипы методов, но не полей
        //                                                    /////////after reading///////////////////////////////////////////////////////////
        //                                                    // Ещё в них могут определятся свойства
        //                                                    /////////////////////////////////////////////////////////////////////////////////
        //                                                    .NET-овцы решили отказаться от идеи множественного наследования в пользу этих
        //                                                    штук
        //   >  Является класс абстрактным или конкретным?  - абстрактные классы не допускают создания их экземпляра напрямую
        //                                                    /////////after reading///////////////////////////////////////////////////////////
        //                                                    // Но объявлять переменные абстрактных классов можно. Такие переменные способны
        //                                                    //   хранить объекты классов-потомков
        //                                                    /////////////////////////////////////////////////////////////////////////////////
        //                                                    . Они служат для задания поведения для своих потомков. Экземпляры конкретных
        //                                                    классов могу создаваться напрямую
        //   >  Какова видимость класса?                    - каждый класс находится в какой-нибудь области видимости. Есть несколько
        //                                                    "модификаторов доступа" (это ключевые слова), что управляют видимостью класса
        //                                                    (и вообще любого типа):
        //                                                    >  Если хочешь, чтобы класс был виден отовсюду в твоей сборке и всем другим
        //                                                       сборкам, что подключили твою как библиотеку, то следует указать в объявлении
        //                                                       класса перед ключевым словом class модификатором доступа public
        //                                                    >  Если класс не должен быть виден (и доступен) за пределами его скобок {}, то
        //                                                       используй модификатор private
        //                                                    >  Если твой класс должен быть виден отовсюду в твоей сборке, но не виден для
        //                                                       других сборок, используй модификатор internal (т.е. это как public, но в
        //                                                       пределах твоего приложения). internal, кстати, ставится по умолчанию для всех
        //                                                       типов в сборке
        //                                                    Модификаторы доступа можно не ставить. По умолчанию компилятор поставит private
        // Как ты помнишь, всё (в том числе и классы) неявно наследует класс System.Object (но это можно сделать и явно)
        /////////after reading///////////////////////////////////////////////////////////////////////
        // Эти характеристики в выходном CIL-коде зовутся атрибуты. Они там в определении типа просто идут списком 
        /////////////////////////////////////////////////////////////////////////////////////////////
        //
        // Сразу стоит отметить одну важную для мира .NET вещь - местные типа могут наследовать только один класс. В качестве других родителей
        //   предлагается использовать интерфейсы
        //
        // Что значит класс реализует интерфейс? Это когда класс полностью выполняет все требования этого интерфейса. Если Интерфейс требует
        //   метод такого-то имени с таким-то определением, то класс должен реализовать это открыто (т.е. через public). Если это не сделано,
        //   компилятор выдаст ошибку. Реализовывать интерфейсы могут не только классы, но и структуры
        // В языке C# интерфейсы объявляются ключевым словом interface. По всеобщему соглашению, имена интерфейсов начинаются с прописной буквы
        //   I (но это делать необязательно. Возмножно, раньше интерфейсы не подсвечивались отдельным цветом). Ниже определён интерфейс IDraw
        //   и класс Drawer, что его реализует
        //
        IDraw myDrawer = new Drawer();  // IDraw .. - да, имя интерфейса можно использовать как тип переменной для содержания ссылки на объект
        //                              //   подходящего типа. Разумеется, так через эту переменную ты можешь пользоваться только теми членами,
        //                              //   что декларируются интерфейсом
        //
        // Как ты, наверное, понял, сам по себе тип интерфейс мало полезен, и служит как лишняя подтяжка кода, чтобы человеки косячили меньше
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // Единственная ощутимая в коде польза от интерфейсов - это возможность хранить в переменных их типа ссылки на объекты
        //   //   поддерживающих их классов (и структур). Такой полиморфизм часто необходим
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //                                     
        // .NET содержит обширную коллекцию разнообразных интерфейсов, распределённых по своим целевым сборкам
        //
        // VS - также, как и для
        //   классов, VS может
        //   создавать файлы,
        //   специально созданные
        //   под интерфейсы (но я
        //   этим не пользуюсь)
        //
        // Как ты уже понял интерфейс - это то же, 
        //   что и структура, класс, перечисление и
        //   т.д. и использоваться его тип может на
        //   их местах
        //
        // VS - как только ты напишешь имя интерфейса в объявлении класса, VS сразу обругает тебя тем, что ты не реализовал этот интерфейс.
        //   IntelliSense будет предлогать ычлены этого интерфейса у объектов класса также только после того, как они будут реализованы
        //
        // VS - при нажатии ПКМ можно выбрать меню
        //   Quick Actions and Refactorings... для                          
        //   выбора таких интересных действий, как
        //   Extract Interface, создающий интерфейс
        //   из существующего класса
    
        

        //    // Все существующих модификаторы доступа в C#:
        //    //   public - как и в C++, даёт полное видение чего-то. Может применятся как внутри типа (класса, структуры, может пречисления)
        //    //     для его членов, так и для самого типа (чтобы его можно было использовать вне сборки, т.е. вне этого приложения или dll)
        //    //   private - как и в C++, закрывает видение чего-то извне. Может применятся внутри типа для его членов или вложенных в него
        //    //     типов
        //    //   protected - как и в C++, даёт видение чего-то только внутри определения типа и его потомоков. Извне через оператор точки
        //    //     это что-то получено быть не может. Другими словами protected позволяет хранить секреты семейства. Может применятся к
        //    //     членам типа и его вложенным типам
        //    //   internal - закрывает видение для типов или членов типа извне сборки. Можно считать, что это private, но на уровне сборки.
        //    //     Может комбинироваться с protected
        //    //         ****protected internal - не то, что ты думаешь (в MSDN есть отдельная страница про это)


        // Комментарии к классу FirstProgram расскажут тебе больше о главном классе программы


        // ##### readonly


        Calc myCalc = new Calc();  // new - просто объявив переменную типа Calc мы не создадим объект. Чтобы выделить память под него и сделать
                                   //   это, нам следует вызвать какой-нибудь конструктор этого типа
                                   // new Calc() - (как и в C++) компилятор снабдит каждый твой класс конструктором по умолчанию, если ты не
                                   //   определил в нём свой. Конструктор по умолчанию просто присвоит default значение каждому полю
                                   /////////after reading///////////////////////////////////////////////////////////////////////
                                   //   . Если тебе нужно другое поведение - реализуй в своём классе интерфейс
                                   //   System.ICloneable, задав нужные действия в методе Clone()
                                   /////////////////////////////////////////////////////////////////////////////////////////////


        // Кстати, класс Calc - вложенный тип. В комментариях к нему ниже ты можешь почитать дополнительную информацию о том, когда это полезно
        Calc someCalc;


        Calc calc1 = new Calc();
        Calc calc2 = calc1;  // = - при присаивании ссылочных типов просто копируется ссылка. Фактически создаётся второе имя для одного
                             //   участка памяти (как в C++). Это значит, что при посылании своих объектов классов в методы они могут изменить
                             //   их внутреннее состояние. Учти это


        void ChangePersonAge(Person person)    // person - этому параметру будут присваиваться различные аргументы, являющиеся классами,
        {                                      //   а это значит, что person будет вторым именем для аргументов, и он сможет не них влиять
            person.birthYear = 99;
            person = new Person("Nikki", 25);  // = - но при этом лучше на задавать иму новую ссылку, т.к. так мы потеряем связь с
        }                                      //   аргументом

        Person fred = new Person("Fred", 12);
        Console.Write("Before: ");
        fred.Display();

        ChangePersonAge(fred);                 // () - передаём наш ссылочный тип в метод, давая ему возможность изменить поля fred
        Console.Write("After: ");
        fred.Display();

        Console.WriteLine();

        void ChangePersonRef(ref Person person)  // ref - здесь получается, что мы принимаем ссылку на ссылку (помним, что ссылка - это
        {                                        //   тот же указатель, но уже разымёныванный). Это значит, что теперь мы можем подменить
            person.birthYear = 22;                     //   ссылку внешнего объекта на свою
            person = new Person("Jerry", 82);    // birthYear - тот объект в памяти, полю которого мы присвоили 22, будет нам больше не доступен и со
        }                                        //   временем исчезнет, т.к. на него больше ничего не будет указывать

        Person mel = new Person("Mel", 38);
        Console.Write("Before: ");
        mel.Display();

        ChangePersonRef(ref mel);
        Console.Write("After: ");
        mel.Display();

        Console.WriteLine();


        MotorcycleConstructs fredric = new MotorcycleConstructs("Fredric");  // new MotorcycleConstructs() - в комментариях к этому классу
        Console.WriteLine("Rider name is {0}\n", fredric.driverName);        //   объясняется что такое this, как строить цепочку
                                                                             //   конструкторов, а также для чего нужен статический конструктор

        //Console.WriteLine(fredric.driverIntensityAverbirthYear);               // fredric.driverIntensityAverbirthYear - это статическое поле
        //    находится на уровне типа, а не на уровне экземпляра. Оно
        //    появилось ещё до создания fredric'а, и доступ к нему открыт
        //    только через тип:
        //        MotorcycleConstructs.driverIntensityAverbirthYear


        TimeUtil.PrintDate();  // TimeUtil - а это статический класс. Все его члены - статические, и нельзя создать его экземпляр
        TimeUtil.PrintTime();
        //TimeUtil tu;         // tu - `cannot declare variable of static type..`
        Console.WriteLine();


        Employee marvin = new Employee("Marvin", 432, 30000);  // Employee - комментарии в этом классе расскажут тебе что такое свойства
        marvin.Display();
        Console.WriteLine();

        marvin.PayUpper(10000);
        marvin.Name = "Marv";                                  // = "Marv" - свойство сделает все нужные проверки
        marvin.Display();
        Console.WriteLine();

        marvin.Name = "The Mr. Super-Duper Mega-Dude";         // = ".. - а это имя не пройдёт
        marvin.Display();
        Console.WriteLine();


        Console.WriteLine("Employees standart passive salary murkup: {0}\n", Employee.PayPassiveMurkup);


        Person myPerson1 = new Person("Samantha", 56) { name = "Ashley" };
        //         // Заметь, что в стандартных классах .NET редко можно     // {} - так можно назначать поля и свойства (которые, в общем,
        //         //   увидеть конструкторы, задающие абсолютнго все поля   //   считаются также полями) в стиле Си, но без точки.
        //                                                                   //   "За кулисами" сначала вызывается конструктор, за которым
        //                                                                   //   следует присваивание за присваиванием, как если бы это
        //                                                                   //   делалось вручную (правда, здесь я решил этим способом задать
        //                                                                   //   только 1-о поле)
        //                                                                   // Person(..) - здесь не важно какой аргумент для _name был
        //                                                                   //   отправлен в конструктор, т.к. он будет перезаписан
        //                                                                   //   синтаксисом инициализвации объектов
        //                                                                   // Person() - если ты хочешь вызвать стандартный конструктор, то
        //                                                                   //   необязательно писать скобки:    .. new Person { .. };

        Person myPerson2 = new Person(null, 0)
        {
            name = new string(new char[] { 'T', 'h', 'o', 'm', 'a', 's', }),  // { .. = new .. } - чуть более сложный случай. Да, здесь он не
            birthYear = 71,                                                         //   оправдан, но для демонстрации сойдёт. На деле тебе часто
        };                                                                    //   придётся строить что-то подобное


        Console.WriteLine("PI is {0} (rounded)\n", MyMath.PI);  // ..PI - константы по умолчанию (а значит и всегда) - это статические члены
        //MyMath.PI = 3.16;                                     // ..PI = 3.16 - как и пологается, компилятор не даст изменить константу

        MyMath mazzy = new MyMath();
        Console.WriteLine("mazzy.E: {0}\n", mazzy.E);
        //mazzy.E = 235;                                        // = 235 - readonly может быть присвоен лишь однажды


        // Если ты посмотришь на использование класса Trolley, то не увидишь ничего нового. Но что, если я тебе скажу, что этот класс определён
        //   в нескольких файлах одновременно? Я думаю, тебе стало бы интересно посмотреть на него
        //
        Trolley regularEmp = new Trolley("Steve", 60_000);
        regularEmp.Display();  // regularEmp.Display() - вообще никакой разницы

        Console.WriteLine();


        Car myCar = new Car(80);        // Car - обычный, непримечательный класс
        myCar.Speed = 59;
        Console.WriteLine("My car is going {0} MPH\n", myCar.Speed);

        MiniVan myVan = new MiniVan();  // MiniVan - класс-потомок от Car
        myVan.Speed = 88;
        Console.WriteLine("My van is going {0} MPH\n", myVan.Speed);
        //                              // MiniVan() - конструктуры суперкласса не передаются по наследству дочернему, но при этом каждый
        //                              //   конструктор дочернего класса вызывает какой-нибудь конструктор суперкласса (по умолчанию это
        //                              //   стандартный). Здесь стандартный конструктор класса Car выставил лимит скорости в 55 MPH


        CompleteMiniVan myCompleteMini = new CompleteMiniVan();  // CompleteMiniVan - этот sealed класс - финальная версия минивена. В
                                                                 //   комментариях к этому классу ты узнаешь детали запечатывания классов через
                                                                 //   sealed


        // Получить начинку другого класса можно просто храня её экземпляр. Автор называет это моделью включения/делегации или агрегации (или
        //   просто отношением "имеет"). Например, у тебя может быть класс BenefitPackbirthYear, и ты хочешь, чтобы его члены были доступны
        //   через объекты уже знакомого класса Employee. Конечно, BenefitPackbirthYear мог быть родительским для Employee, но это было бы
        //   странно. Лучше просто объявить поле типа BenefitPackege в определении класса Employee
        // Примерно на такой схеме и основывалась иерархия структур в Си. Там наследования нет
        // Делегация - это когда ты имитируешь методы одного из внутренних объектов твоего класса


        // abstract - предотвращает создание экземпляров этого класса (именно этого, на его потомков не распространяется). В качестве примера
        //   посмотри на класс Cat
        //
        Sphynx musya = new Sphynx("Musya", 1912, 0.05);
        musya.PrintInfo();
        Cat tosya = new Sphynx("Tosya", 2017, 0.02);      // Cat .. = new Sphynx() - магия наследования. Класс Sphynx является классом Cat, а
        tosya.PrintInfo();                                //   это значит, что он совместим с переменными класса Cat, т.к. имеет всё для этого.
        //                                                //   Правда, Cat объект будет вести себя как (..) Cat объект. Формально это
        // Если ты попытаешься создать объект некого      //   называется неявным приведением (в данном случае - повышающим)
        //   класса и выполнить понижающее приведение     // tosya.DisplayInfo() - хоть ссылка tosya и указывает на объект Cat, произойдёт
        //   (оно, кстати, может проходить только явно),  //   вызов метода DisplayInfo() из класса Sphynx, ведь наш объект Cat на деле
        //   то получишь исключение                       //   оказывается объектом класса Sphynx. Всё как в C++
        //   System.InvalidCastException. У твоего        //
        //   объекта не будет хватать полей, что есть и   //
        //   этого класса. Приведения, кстати,            //
        //   выполняются в runtime, и поэтому ошибки не   //
        //   будет видно на этапе компиляции              //
        //
        Cat[] cats = new Cat[] { musya, tosya, new FelisCatus("Felicette", 1956, "First cat in space") };
        foreach (Cat curr in cats)
        {
            curr.PrintMeow();                             // curr.PrintMeow() - полиморфизм в действии (вызывая один метод у объектов разных
                                                          //   типов, ты получаешь различное поведение этого метода, заточенное под свой
                                                          //   объект).
        }
        Console.WriteLine();
        //
        // new - этим ключевым словом мы явно даём понять, что мы хотим скрыть реализацию этого
        //   метода в суперклассе и создать метод поновой. Это часто пригождается при
        //   использовании чужих сборок, код которых тебе недоступен (ты не можешь добавить
        //   virtual к объявлению нужного родительского метода). Эта возможность может
        //   применятся к любому члену класса (e.g. поле, метод, свойство ...), даже если в
        //   родительском классе нет такого же члена (в этом случае будет warning)
        // Класс MaineCoon имеет с своём составе член с ключевым сломо new в определении
        //
        MaineCoon lynx = new MaineCoon("Lynx", 1885, 0.16);
        //
        // В комментарии к этому классу ты также найдёшь описание действия ключевого слова sealed на методы (хотя, ты наверное уже понял о чём я
        //   говорю)


        object[] things = new object[] { false, tosya, musya, "Last thing", lynx };
        foreach (object item in things)
        {
            Cat target = item as Cat;          // as - если склад памяти оказался несовместим с Cat, target получит null, но если
            if (target == null)                //   всё впорядке, то target получит ссылку на этот участок памяти (который item)
            {
                Console.WriteLine("The item is not a cat");
            }
            else
            {
                target.PrintMeow();
            }
        }
        Console.WriteLine();



        object someCat = lynx;
        if (someCat is MaineCoon)              // is - это ключевое слово возвратит true, если emp окажется ссылкой на SalesPerson в памяти
        {                                      //   (или другой совместимый тип). Если нет, то вернётся false (на самом деле этого эффекта
                                               //   можно добится и с помощью записи    if (emp as SalesPerson != null)
            Console.WriteLine("Hey! You have a rare {0} breed. And she's name is {1}", nameof(MaineCoon), ((MaineCoon)someCat).Name);
        }
        else if (someCat is FelisCatus felis)  // felis - в C# 7 is научилось создавать новую переменную (это слегка сокращает код)
        {
            Console.WriteLine("It is a cat of {0} breed and her name is {1}!", nameof(FelisCatus), felis.Name);
        }
        Console.WriteLine();
        //
        bool isSphynx = someCat is Sphynx reallySphynx;
        //Console.WriteLine("isSphynx: {0}, reallySphynx: {0}", isSphynx, reallySphynx.Name);
        //                                     // reallySphynx - компилятор считает, что это не присвоенная переменная, поэтому
        //                                     //   выдаст ошибку
        int obj = 25;
        if (obj is var _)  // _ - автор заостряет внимание, что is с использованием var срабатывает в любом случае, поэтому следует
        {                  //   уделять внимание порядку цепочки if
        }


        // Что будет если несколько интерфейсов потребуют реализовать один и тот же метод (по прототипу и имени)? Посмотри на это:
        //
        Lizard1 lizzy = new Lizard1();
        lizzy.Name = "Lizzy";
        IDrawToMemory memoryL = lizzy;
        IDrawToConsole consoleL = lizzy;
        IDrawToPrinter printerL = lizzy;
        memoryL.Draw();                   // Draw() - вызов одного и того же метода, хоть и используя типы разных интерфейсов
        consoleL.Draw();                  // Конечно, интерфейс IDrawToMemory определяет метод Draw() с предположением, что его реализации
        printerL.Draw();                  //   будут работать с памятью, а IDrawToPrinter - с принтером. При этом без дополнительного
        Console.WriteLine();              //   синтаксиса мы не в состоянии расщепить Draw() для каждого интерфейса. Для этого используют явную
        //                                //   реализацию интерфейсов
        Lizard2 acacia = new Lizard2();
        acacia.Name = "Acacia";
        ((IDrawToMemory)acacia).Draw();   // Draw() - вызов метода, явно задав требуемую реализацию конкретного интерфейса. На самом
        ((IDrawToConsole)acacia).Draw();  //   деле лучше задавать более конкретные имена методов, чтобы избежать лишней работы
        ((IDrawToPrinter)acacia).Draw();  // (IDraw..)acacia - здесь я решил не тратить строчки, а воспользоваться явным приведением
        Console.WriteLine();              // Заметь, мы не можем вызвать Draw() без явного приведения к интерфейсу, т.к. мы явно прикрепили
                                          //   всех их к поддерживаемым интерфейсам


        // Наследование у интерфейсов? Прочитай комментарии к BitmapImage и его интерфейсам
        BitmapImage myBitmap;


        // Вот как выглядит обобщение класса
        /////////after reading///////////////////////////////////////////////////////////////////////
        //  (со структурами работает также)
        /////////////////////////////////////////////////////////////////////////////////////////////
        //   :
        Container<decimal> myDecimal = new Container<decimal>(52.5m);  // Container<T> - если при обобщённых методах ты мог не писать параметры
                                                                       //   типа (т.е. часть со <>-ми), то обобщённым типам задавать их уже
                                                                       //   придётся всегда (ведь компилятору неоткуда будет взять тип, если ты
                                                                       //   решишь не присваивать новой переменной что-то)


        PickyCollection myLongs = new PickyCollection();     // PersonCollection - здесь я сделал класс коллекции, что имеет в своём
        Console.WriteLine("myLongs[0] is {0}", myLongs[0]);  //   определнии такую штуку, как "индексаторный метод" (или просто "индексатор"),
                                                             //   что даёт возможность получать и задавать элементы по индексу (т.е. с [])
                                                             // Почему Picky? Потому что в свой контейнер объекты этого класса берут не всё
                                                             //   подряд, а только подходящие элементы
                                                             /////////after reading/////////////////////////////////////////////////////////
                                                             // На самом деле, есть полно коллекции, которые могут предоставить ту же
                                                             //   индексацию , но без затраченного времени
                                                             ///////////////////////////////////////////////////////////////////////////////
                                                             //
        myLongs[1] = 5;                                      // Конечно, стоит понимать, что это также создано для упрощения рутинной задачи,
        myLongs[2] = 4;                                      //   ведь почти того же было добиться с помощью методов
        myLongs[3] = 3;                                      //
        myLongs[4] = 42;   // .. = 52 - а это значение не проходит условие в индексаторе, и потому в контейнер не попадёт
        myLongs[5] = 1;
        myLongs[6] = 6;    // ..[6] - индекс выходит за рамки вместимости, но в нидексаторе имеется код на этот случай. Мы всего лишь получаем
                           //   сообщение об этом в cmd
                           //
                           //
        myLongs["4"] = 2;  // [".."] - а здесь применяется другая версия индексаторного метода


        Point_WithOperators ptLeft = new Point_WithOperators(100, 100);      // Point_WithOperators - тот тип поддерживает некоторые операторы
        Point_WithOperators ptRight = new Point_WithOperators(40, 30);       //
        Console.WriteLine("Left is {0}", ptLeft);                            //
        Console.WriteLine("Right is {0}", ptRight);                          //
                                                                             //
        Console.WriteLine("Left + Right is {0}", ptLeft + ptRight);          // + - также, как и в C++, за кулисами здесь вызывается связанный
        Console.WriteLine("Left - Right is {0}\n", ptLeft - ptRight);        //   метод (или, если угодно, оператор)
                                                                             //
        Console.WriteLine("Left + 5 is {0}\n", ptLeft + 5);                  // ptLeft + 5 - используется нужная нам перегрузка(версия) метода
        //Console.WriteLine("4 + Left is {0}", 4 + ptLeft);                  // 4 + ptLeft - если компилятор не найдёт нужную реализацию для
                                                                             //   оператора ни в одном из задействованных типов, то он не
                                                                             //   выдаст ошибку (уже определённая реализация не подходит, т.к.
                                                                             //   она принимает Point_.. и int, т.е. слева от + должен стоять
                                                                             //   объект типа Point_.., а справа - int)
                                                                             //
        Console.WriteLine("ptRight += 4 is {0}", ptRight += 4);              // += - такие сокращения даются бонусом после реализации
        Console.WriteLine("ptRight is {0}", ptRight);                        //   соответственных итераторных методов (в C++ они реализовались
        Console.WriteLine("ptRight -= ptRight is {0}", ptRight -= ptRight);  //   отдельно)
        Console.WriteLine("ptRight is {0}\n", ptRight);


        // Ты можешь очень удивится, но    short + short = int    (т.к. возможно переполнение)(то же отностися и ко многим другим числам), но
        //     int + int = int    (int здесь остаётся исключением)
        //
        // И ещё (ещё более удивитильная вещь) - если
        //       short = short + short  // Error : Cannot implicitly convert type 'int' to 'short'..
        //   , то
        //       short += short;        // legal
        //   Почему? Потому что
        //
        //     The C# specification states in section 7.17.2
        //
        //       Otherwise, if the selected operator is a predefined operator, if the return type of the
        //       selected operator is explicitly convertible to the type of x, and if y is implicitly
        //       convertible to the type of x or the operator is a shift operator, then the operation is
        //       evaluated as x = (T)(x op y), where T is the type of x, except that x is evaluated only once.
        //


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Class_Silent()");
    }
    internal class Calc               // class - этим ключевым словом классы определяются в C# (и в C++, и в Python)
    {                                 // ..{ .. clas .. } - классы можно вкладывать друг в друга (как и в каждом известном мне языке ООП языке)
        public int Add(int x, int y)  // public - у членов классов и структур модификаторы доступа также ставятся. public говорит о том, что
        {                             //   этот метод можно использовать через будущие объекты этого типа:    myCals.Add(..)
            return x + y;
        }                             // Calc - заметь, что это вложенный тип. Он видит всё, что видит его класс-владелец плюс свои
                                      //   собственные члены. При этом его самого может видеть только блок кода, в который он вложен,
                                      //   если не задан модификатор public или protected (по умолчанию ставится internal, но я сделал это
                                      //   явно). Внутренние типы довольно полезны как вспомогательные для внешнего класса  и не предназначены
                                      //   для внешнего мира. Как ты понял, объекты закрытого вложенного типа не должны быть видны извне (иначе
                                      //   - ошибка)
    }
    interface IDraw             // IDraw - классы и структуры, что подпишут так называемый контракт с этим интерфейсом, должны будут выполнить
    {                           //   все условия, описанные внутри него
        void Draw();            // Draw() - открытый метод с таким прототипом (прототип - это всё имя метода. Здесь это    void Draw()    )
    }                           //   должен иметься у всех классов, имеющих дело с интерфейсом IDraw
    class Drawer : IDraw        // : - после этого символа (и после имени суперкласса, если ты наследуешь от чего-то явно) должны перечислятся
    {                           //   интерфейсы, что класс реализует. Здесь можно было написать
                                //       class Drawer : System.Object : IDraw {..}
        public void Draw() { }  // ..Draw() {} - мы реализовали интерфейс, и не важно, что именно мы поместили в метод (но лучше следовать
                                //   имени метода, ведь всем этим затем будет управлять человек, а человек, вызывающий метод Draw() будет
                                //   думать, что что-то нарисуется)
                                // public .. - интерфейс (в смысле элементы управления) должен быть публичным
    }
    class FirstProgram                   // FirstProgram - каждый класс, где есть входная точка Main, зовётся объектом приложения
    {
        static void Main(string[] args)  // static - т.к. функция Main() должна находится в классе (C# не поддерживает глобальную область
        {                                //   видимости для методов и переменых, и поэтому вся начинка дложна находится в классах), а создать
                                         //   объект класса FirstProgram никто не может, то Main() должна быть отвязана от объектов. static
                                         //   переносит её на уровень класса
                                         // Main() - в одной программе может быть несколько точек входа,
                                         //   но тогда нужно явно задасть компилятору ту, что надо юзать.
                                         //   Делается это в Project->* Properties...
                                         // void - в C# нет необходимости возвращать значение для Main(). Но можно делать и по канону Си - с
                                         //   int и return. Если Main() прототипирован как void, то для системы всё-равно вернётся 0. В Windows
                                         //   возврат последнего запущенного приложения хранится в переменной %ERRORLEVEL%. Ещё этот этот код
                                         //   можно получить с помощью System.System.Diagnostics.Process.ExitCode
        }
    }
    class Person
    {
        public string name;                          // name - набор полей экземпляра класса обычно называется его состоянием
        public int birthYear;
        public Person(string _name, int _birthYear)  // public Person() - если ты хочешь иметь возможность создавать объекты этого типа, оставь
        {                                            //   хотя бы один конструктор открытым. Кстати, создав этот конструктор мы потеряли
                                                     //   стандартный
            name = _name;                            // name - поля, которым ты не задал значение задействованным конструктором, получат своё
            birthYear = _birthYear;                  //   default значение
        }                                            // {} - кстати, в C# 7 расширили сферу применения =>. Теперь он применим к конструкторам:
                                                     //      CarConstructs(string _petName) => petName = _petName;
                                                     /////////after reading////////////////////////////////////////////////////////////////////
                                                     //   Ещё эта возможность стала доступной финализаторам, а также к средствам доступа
                                                     //   get/set для свойств и индексаторов
                                                     //////////////////////////////////////////////////////////////////////////////////////////
                                                     // ctor - snippet, создающий
                                                     //   конструктор в типе по
                                                     //   умолчанию с курсором в теле
                                                     //   метода
                                                     //

        //public Person() {}                         // Person() - так можно явно возродить конструктор по умолчанию. Члены объекта, которым
        //                                           //   явно не выдали значения, получат значения по умолчанию от компилятора
        public void Display()
        {
            Console.WriteLine("name: {0}, birthYear: {1}", name, birthYear);
        }
        public void SetName(string name)       // name - метод берёт во внимание тот объект, что инициализируется в нём, не видя
        {                                      //   одноимённое поле класса
            this.name = name;                  // this - это ссылка на объект владельца (в C++ это был указатель). Она может быть полезна
        }                                      //   в некоторых случаях (здесь мы можем получить доступ к полю класса, к которому нельзя
                                               // IntelliSense - с помощью этого  //   обратится напрямую)
                                               //   this может выдать список      //
                                               //   всех членов класса. Это может //
                                               //   помочь                        //
    }
    class MotorcycleConstructs
    {
        public int driverIntensity;
        public string driverName;
        public static float driverIntensityAverbirthYear = 0F;  // static float - ты это знаешь, но вот как на деле создаются static члены
        public MotorcycleConstructs() { }
        public MotorcycleConstructs(int driverIntensity) : this(driverIntensity, "") { }
        public MotorcycleConstructs(string driverName) : this(0, driverName) { }
        public MotorcycleConstructs(int _driverIntensity, string _driverName)
        {                                                 // this - даёт возможность вызывать конструкторы внутри класса (других способов нет).
            if (_driverIntensity > 10)                    //   Работает это только с конструкторами и для конструкторов. После того, как
            {                                             //   вызванный конструктор завершит свою работу, курсор выполнения перейдёт к
                _driverIntensity = 10;                    //   командам в теле текущего ctor
            }                                             // MotorcycleConstructs(..) - такой подход (или паттерн), когда конструкторы вызывают
            driverIntensity = _driverIntensity;           //   друг друга, называется цепочкой конструкторов. В нашем случае есть один главный
            driverName = _driverName;                     //   конструктор, определяющий все поля, и его вызывают другие. Это сильно экономит
                                                          //   объёмы кода. Ещё больше всё упростят уже знакомые возможности необязательных и
                                                          //   именованных аргументов (из C# 4). Ну и да, закрытые конструктора можно
                                                          //   использовать только в такой цепочке конструкторов, больше никак
        }
        static MotorcycleConstructs()                    // static ..() - это статический конструктор. Он идеально подходит для того, чтобы
        {                                                //   задавать значения статическим полям класса, если они не известны на этапе
            Console.WriteLine("In Static Ctor!");        //   компиляции. Вызывается он единожды прямо перед первым использованием класса
            driverIntensityAverbirthYear = 0.8F;         //   (это может объявление его экземпляра или применение его static поля или метода).
        }                                                //   Он не приемлет никакаких модификаторов доступа (вроде public)(т.к. он не должен
                                                         //   вызываться вручную), а также в нём нельзя использовать this (по понятным
    }                                                    //   причинам)
    class Employee
    {
        private string empName;
        private float currPay;
        public string Name              // Name - это свойство. Вместо того, чтобы на каждое поле добавлять по паре методов get_.. и set_.. для
        {                               //   соблюдения инкапсуляции, в языках .NET предпочли использовать "свойства". Вызывающий код
            get { return empName; }     //   пользуется свойствами как простыми полями
            set                         /////////after reading///////////////////////////////////////////////////////////////////////
            {                           //   . В CIL-коде можно увидеть, что на самом деле для каждого свойства создаётся всё то же приватное
                                        //   поле плюс пара методов set_[имя свойства] и get_[имя свойства]
                                        /////////////////////////////////////////////////////////////////////////////////////////////
                                        // get - эта часть вызывается, когда мы получаем значение свойства. Если этой части не будет - со
                                        //   свойства нельзя будет считать значение
                                        // set - а эта часть задействуется при присваивании через =. set также можно опускать, но тогда ты
                                        //   лишишься возможности задавать значение полю через свойство
                                        // В свойствах нельзя выполнять команды за пределами блоков get/set
                if (value.Length > 15)
                    Console.WriteLine("ERROR: new name length exceeds 15 symbols");
                else
                    empName = value;    // value - это контекстное ключевое слово области set (т.е. вне set оно не будет ключевым). Здесь оно
            }                           //   служит неявным параметром, которым становится присваиваемый объект:
        }                               //      mirvin.Name = sometext;
                                        //   sometext будет скопирован в value, и мы сможем использовать его значение. Стоит отметить, что
                                        //   value всегда имеет тот же тип, что и у свойства
        public Employee() { }
        public Employee(string _empName, int _empId, float _currPay)
        {
            Name = _empName;
            ID = _empId;
            Pay = _currPay;
        }
        public int ID { get; set; }    // get, set - если ничего, кроме чтения и записи в свойстве не нужно, но решено использовать именно
        // prop - этот snippet от VS   //   свойство, то оно может выглядить даже так. Это называется автосвойство, т.к. мы перекладываем
        //   для создания автополей.   //   обязанность создания приватного поля и громоздкой механики get и set на компилятор (созданное им
        //   В нём работает переход    //   поддерживающее поле нельзя будет получить из кода)
        //   между подсвеченными       /////////after reading///////////////////////////////////////////////////////////////////////
        //   частями с помощью Tab     //   (его имя можно узнать только с ildasm.exe)
        //                             /////////////////////////////////////////////////////////////////////////////////////////////
        //                             // set - у автосвойств есть 2-е особенности. 1-я - даже если у них опущен set;, ты всё-ещё можешь
        //                             //   задавать им значение в конструкторах. 2-я особенность это то, что у них нельзя опускать get;
        //                             //   (почему? ****не знаю?)
        //                             /////////after reading///////////////////////////////////////////////////////////////////////
        //                             //   . По CIL коду видно, что в таком случае (когда set_.. метода для поля свойства нет) конструктор
        //                             //   ведёт запись нового значения прямо в поле свойства. Другие члены не могут похвастаться такой
        //                             //   возможностью обращения к этому полю, и они просят определения set_.. метода
        //                             /////////////////////////////////////////////////////////////////////////////////////////////
        public string IsAutoProp { get; set; } = "I'm a default string";
        //                             // = - так можно задавать стандартное значение для
        //                             //   будущей переменной, что создат компилятор
        public float Pay
        {
            get => currPay;            // => - задействовать сахар здесь тоже можно
            set => currPay = value;    // set - если ты не хочешь, чтобы кто-то изменял значение, то можешь простой опустить область set (ну
        }                              //   или get, если не хочешь, чтобы его считывали)
        public string Description => "A man who works";
        //                             // Description => .. - => может применяеться в свойствах и так. Прочитав это, компилятор выдаст get-only
        //                             //   свойство
        public void PayUpper(float amount)
        { Pay += amount; }             // += - помним, что это развёртывается в Pay = Pay + amount. Это не отдельный оператор
        public void Display()
        {
            Console.WriteLine("Name: {0}", Name);
            Console.WriteLine("ID: {0}", ID);
            Console.WriteLine("Pay: {0}", Pay);
        }                              // Name, ID, .. - хорошим тоном считается повсеместное использование свойств, а не
                                       //   прямое обращение к полям


        private static double empPayPassiveMarkup = 50;
        public static double PayPassiveMurkup  // static {} - не стоит забывать и про статические поля
        {
            get { return empPayPassiveMarkup; }
            set { empPayPassiveMarkup = value < 1000 ? value : 1000; }
        }
    }
    static class TimeUtil  // static class - такие классы зовутся обслуживающими, т.к. создавать их экземпляры нельзя, но можно
    {                      //   пользоваться их начинкой. В .NET множество обслуживащих классов, таких как Console. Статические классы
                           //   не могут быть базовыми для классов-потомков (они неявно запечатаны, и сами не могут наследовать что-то, кроме
                           //   как System.Object (т.к. в нет смысла наследовать только статические члены. Получится та же пачка методов в
                           //   другой оболочке)
        public static void PrintTime()
        { Console.WriteLine(DateTime.Now.ToShortTimeString()); }
        public static void PrintDate()
        { Console.WriteLine(DateTime.Now.ToShortDateString()); }
    }
    class MyMath
    {
        public const double PI = 3.14;             // PI - т.к. это поле const, то оно ещё и неявно статическое (явно задать static не
        public readonly double E;                  //   получится)
                                                   // readonly - а это как const, но с возможностью отложенного присваивания. Оно уже не
                                                   //   становится статическим по умолчанию. Обычно readonly используют в классах вместе со
                                                   //   статическим конструктором . Похожего можно добится, используя свойства с опущенными
                                                   //   областями set
        public MyMath()
        {
            Console.Write("What is E?: ");
            E = double.Parse(Console.ReadLine());  // E = - в классах readonly может получить значение или только при инициализации, или в
        }                                          //   конструкторе (ведь такое поля может получить значение лишь раз, а конструктора всегда
                                                   //   присваивают всем без исключения полям кикие-то да значения)
    }
    partial class Trolley    // partial - это частичный класс. Это означает, что класс (или структура, интерфейс или метод) справа может
    {                        //   дополнятся из других файлов (здесь объявлены поля и свойства класса, а в Trolley5.4.cs конструкторы и
        string trolName;     //   методы). Это может быть очень полезно на производственном уровне
        double trolWeight;
        public string Name
        {
            get => trolName;
            set
            {
                if (value.Length < 16)
                    trolName = value;
                else
                    Console.WriteLine("ERROR: new name for {0} must have less then 16 symbols", trolName);
            }
        }
        public double Weight
        {
            get { return trolWeight; }
            set { trolWeight = value; }
        }
    }
    class Car                          // Car - здесь это базовый, родительский или суперкласс для MiniVan
    {
        public readonly int maxSpeed;
        int currSpeed;
        public int Speed
        {
            get => currSpeed;
            set => currSpeed = value <= maxSpeed ? value : maxSpeed;
        }
        public Car()
        {
            maxSpeed = 55;
        }
        public Car(int _maxSpeed)
        {
            maxSpeed = _maxSpeed;
        }
    }
    class MiniVan : Car                                              // MiniVan - производный, дочерний класс или класс-потомок. Автор
    {   // : - здесь также ипользуется двоеточие для базового класса //   зовёт классическое наследование отношением "является". Все
        //   . Стоит сказать, что C# не приемлет множественное       //   объекты из суперкласса (кроме конструкторов) наследуются сюда, хоть и
        //   наследование классов. Вместо этого предлагается         //   доступны здесь будут только члены с модификаторами public или
        //   использовать интерфейсы. Кстати, они должны следовать   //   protected
        //   за базовым классом после знака :                        //
        //       MiniVan : Car, IBus { .. }                          //
        // MiniVan() - видишь стандартный конструктор? Нет? А он     //
        //   есть, и он вызывает стандартный консруктор свого        //
        //   базового класса. Вот как выглядит стандартный           //
        //   конструктор для класса MiniVan, поставляемый            //
        //   компилятором:                                           //
        //       public MiniVan() : base() {}                        //
        //   Что за base? Это как-бы ссылка на унаследованную часть  //
        //   класса, как this на текущую. Если в базовом классе не   //
        //   окажется конструктора без аргументов то да, компилятор  //
        //   выдаст ошибку                                           //
        //public MiniVan(int _maxSpeed) : base(_maxSpeed)            // MiniVan(..) : base(..) - а вот так это делается явно. Этот конструктор
        //{                                                          //   закоментирован, чтобы компилятор снабдил нас своим стандартным
        //}                                                          //   конструктором
        //public MiniVan() : this(5)                                 // MiniVan() : this(..) - этим мы можем вызвать другой конструктор
        //{                                                          //   текущего класса (здесь бы вызвался тот закоментированный коструктор с
        //}                                                          //   int, что выше)
    }
    sealed class CompleteMiniVan : MiniVan          // sealed - это слово означает, что класс запечатан, от него нельзя наследовать (в C++ этим
    {                                               //   использовалось слово final, кстати). В namespace System множество запечатанных классов
    }                                               //   (e.g. String). Помним, что static классы сами по себе неявно запечатаны, также, как и
                                                    //   структуры
    //class CompleteMiniVanMode : CompleteMiniVan   // CompleteMiniVanMode - `cannot derive from sealed type..`
    public abstract class Cat                                   // .. abstract class - в C++ отдельного вида абстрактных классов не было, да
    {
        protected string petName;
        protected uint birthYear;
        public Cat(string _petName, uint _birthYear)     // Cat() - этот конструктор не сможет вызываться для создания экземпляров класса Cat.
        {                                                //   Зато его могут вызывать конструкторы классов-потомков для облегчения себе работы
            Name = _petName;
            Age = _birthYear;
        }
        public string Name { get => petName; set => petName = value; }
        public uint Age { get => birthYear; set => birthYear = value; }
        public virtual void PrintInfo()                  // virtual - зато в C++ всё было готово для их поддерживания. В C#, как и в C++,
        {                                                //   виртуальные методы могут быть переопределены в производных классах, но
            Console.WriteLine("Name: {0}", Name);        //   переопределение необязательно (а ещё виртуальные методы здесь не могут быть)
            Console.WriteLine("Birth year: {0}", Age);   //   private)
        }
        public abstract void PrintMeow();                // abstract - так мы говорим классам-потомкам, что они должны назначить свою версию
                                                         //   метода PrintMeow(), желательно заточенную под них самих. Абстрактные члены
                                                         //   обитают только в абстрактных классах. Если какой-то класс-потомок также является
                                                         //   абстрактным, то он может не создавать свою реализацию метода PrintMeow() (зачем
                                                         //   это ему, если от него нельзя создавать экземпляры?
                                                         // Ну и также стоит сказать, что и виртуальные, и абстрактные члены не должны быть под
                                                         //   private (мы же не хотим, чтобы методы, которые были созданы для наследования, не
                                                         //   могли наследоваться)
    }
    class Sphynx : Cat
    {
        public Sphynx(string _petName, uint _birthYear, double hairPercent) : base(_petName, _birthYear)
        {
            HairPercent = hairPercent;
        }
        public double HairPercent { get; set; } = 0F;             // HairPercent - новый член класса, что может быть только у сфинксов
        public override void PrintInfo()                          // override - ты должен использовать это ключевое слово при перезаписи
        {                                                         //   методов. Знай, что ты не можешь изменить модификатор доступа при
            base.PrintInfo();                                     //   перезаписи. Метод PrintInfo() может дальше переопределятся классами ниже
            Console.WriteLine("Hair percent: {0}", HairPercent);  //   по иерархии. IntelliSense - очень помогает тем, что выводит список
                                                                  //   допускающих переопредиление методов сразу после ввода override. При
        // На самом деле можно не писать ключевое слово           //   выборе нужного метода появится готовый макет, вызывающий выбранный метод
        //   override в опредилении метода, но тогда              //   из суперкласса
        //   компилятор выдаст предупреждение                     // base.PrintInfo() - чтобы не делать лишнюю работу мы можем вызвать
        //                                                        //   реализацию метода PrintInfo() в классе-предке
        }
        public override void PrintMeow() { Console.WriteLine("Merw"); }
        // .. override void PrintMeow() - если класс-потомок не перезапишет ещё
        //   нереализованный абстрактный член класса-предка, выйдет ошибка компиляции
    }
    public class FelisCatus : Cat
    {
        public string Description { get; }
        public FelisCatus(string _petName, uint _birthYear, string description) : base(_petName, _birthYear)
        {
            Description = description;
        }
        public override void PrintInfo()
        {
            base.PrintInfo();
            Console.WriteLine($"{nameof(Description)}: {Description}");
        }
        public override void PrintMeow() => Console.WriteLine("Miaou");
    }
    public class MaineCoon : Cat
    {
        public double averageHairLength;
        public MaineCoon(string _petName, uint _birthYear, double _averageHairLength) : base(_petName, _birthYear)
        {
            averageHairLength = _averageHairLength;
        }
        public override void PrintInfo()
        {
            base.PrintInfo();
            Console.WriteLine("Average hair length: {0}", averageHairLength);
        }
        public override sealed void PrintMeow()                   // sealed - запечатывать можно не только классы, но и методы. Так этот метод
        { Console.WriteLine("ewr"); }                             //   потеряет возможность быть перезаписаным. Иногда все-же предпочтительнее
                                                                  //   делать именно это. Здесь мы не хотим, чтобы кто-то изменял звук мейн
                                                                  //   куна дальше
    }
    interface IDrawToMemory { void Draw(); }
    interface IDrawToConsole { void Draw(); }
    interface IDrawToPrinter { void Draw(); }  // IDraw... - все эти интерфейсы требуют реализцаию метода с одинаковой сигнатурой
    class Lizard1 : IDrawToMemory, IDrawToConsole, IDrawToPrinter
    {
        public string Name { get; set; }
        virtual public void Draw() => Console.WriteLine($"{Name} the Lizard");  // Draw() - этим методом класс удовлетворяет все интерфейсы
    }
    class Lizard2 : IDrawToMemory, IDrawToConsole, IDrawToPrinter
    {
        public string Name { get; set; }
        void IDrawToMemory.Draw() => Console.WriteLine($"Drawing {Name} to memory...");
        void IDrawToConsole.Draw() => Console.WriteLine($"{Name} the Lizard2");
        void IDrawToPrinter.Draw() => Console.WriteLine($"Drawing {Name} to printer...");
    }   //  // Draw() - теперь мы явно задали реализацию для интерфейса. Такой синтаксис работает только с интерфейсами, при применении его
        //  //   для явного переопределение базовых методов получишь ошибку компиляции
        //  // .. void - такой синтаксис также не приемлет модификаторов доступа. Явные реализации всегда закрыты. Доступ к ним можно получить
        //  //   получить только явно указав тип их интерфейса, дабы не вызывать неоднозначности
    interface IDrawable                      // IDrawable - у нас также есть IDraw, но он далеко
    {
        void Draw();
    }
    interface IDrawableAdvanced : IDrawable  // : - интерфейсы также имеют собственное наследование. Интерфейс может наследовать только
    {   // Зачем тогда вообще нужны          //   другой интерфейс. Здесь мы получаем интерфейс из требований IDrawable плюс несколько
        //   абстрактные классы? Как         //   новых местных определений. В отличие от классов, интерфейсы поддерживают множественное
        //   минимум это классы, а значит    //   наследование:    IDrawableEnhanced : IDrawable, IDrawableAdvanced    . Да, здесь может
        //   они поддерживают наследования   //   возникнуть тот эффект, о котором ты уже знаешь (конфликта имён не будет). Разрешить его можно
        //   классов, внутренние типы и      //   с помощью того же явного прикрепления члена к интерфейсу или оставив одну реализацию
        //   другие фишки классов            //   метода на двоих
        void DrawInBoundingBox(int top, int left, int bottom, int right);
        void DrawUpsideDown();
    }
    class BitmapImage : IDrawableAdvanced
    {
        public void Draw() => Console.WriteLine("Drawing...");
        public void DrawInBoundingBox(int top, int left, int bottom, int right) => Console.WriteLine("Drawing in box...");
        public void DrawUpsideDown() => Console.WriteLine("Drawing upside down...");
    }
    class Container<T>                // ..<T> - в отличие от C++, никаких typename'ов здесь нет
    {
        public T content;
        public Container()
        {
            content = default(T);     // default(T) - это ключевое слово перегружено для работы с обобщением
            //conent = default;       // default - на самом деле даже можно использовать и новый синтаксис
        }
        public Container(T _content)
        {
            content = _content;
        }
    }
    class PickyCollection
    {
        long[] numbers = new long[] { 1L, 2L, 3L, 4L, 5L };  // numbers - нашим внутренним контейнером будет служить массив из 5-ти значений
                                                             //   long, с самого начала хранящий набор значений по умолчанию
        public long this[int i]                              // this[] - так мы можем реализовать индексацию этого типа. Да, здесь это не
        {                                                    //   считается оператором, как это было в C++. Индексатор здесь почти как свойство
                                                             //   , но с this[..]
                                                             // this[int i] - как и в C++, мы можем принимать в качестве индекса что угодно
                                                             //   (string? int? Lizard2? Тебя ничто не ограничивает). Можно принимать даже
                                                             //   больше 1-го индекса:    this[int x, int y]
            get
            {
                if ((i >= 0 && i < numbers.Length) == false)
                    return default;                          /////////after reading////////////////////////////////////////////////////////////
                return numbers[i];                           // return defualt; - на самом деле при некорректном индексе правильнее было бы
                                                             //   сразу выбросить System.ArgumentOutOfRangeException
                                                             //////////////////////////////////////////////////////////////////////////////////
                                                             // numbers[i] - да, здесь решено просто использовать индексаторный метод из
                                                             //   ArrayList, ведь там он уже готов. Если бы мы строили свою реализацию списка,
                                                             //   нам бы пришлось строить уже что-то посложнее
            }
            set
            {
                if (value >= 0 && value <= 10 && i >= 0 && i < numbers.Length)
                    numbers[i] = value;
                else
                    Console.WriteLine("ERROR: your value is not valid");
            }
        }
        public long this[string key]                         // this[string] - да, индексаторы можно перегружать
        {
            get => numbers[int.Parse(key)];
            set => numbers[int.Parse(key)] = value;
        }
    }
    public class Point_WithOperators
    {
        public int X { get; set; }
        public int Y { get; set; }
        public Point_WithOperators() { }
        public Point_WithOperators(int x, int y)
        {
            X = x;
            Y = y;
        }
        public static Point_WithOperators operator +(Point_WithOperators left, Point_WithOperators right) =>
            new Point_WithOperators(left.X + right.X, left.Y + right.Y);
        public static Point_WithOperators operator -(Point_WithOperators left, Point_WithOperators right) =>
            new Point_WithOperators(left.X - right.X, left.Y - right.Y);  // operator - как и многие продвинутые языки, C# имеет
                                                                          //   возможность определять поведение при таких базовых лексемах
                                                                          // Определения операторов должны быть открытыми и статичными,
        // Вот таблица всех операций в C#:                                //
        //   >  +, -, !, ~, ++, --, true, false  - унарные операции
        //   >  +, -, *, /, %, &, |, ^, <<, >>   - бинарные операции
        //   >  ==, !=, <, >, <=, >=             - операции сравнения. Они должны быть определены попарно (если есть <, должен быть и >)
        //   >  []                               - эту операцию уже нельзя определить, для этого ввели итераторный метод
        //   >  ()                               - эта операция также не определяется
        //                                         /////////after reading//////////////////////////////////////////////////////////////////////
        //                                         , но ту же функциональность предоставляют специальные методы преобразования
        //                                         ////////////////////////////////////////////////////////////////////////////////////////////
        //   >  +=, -=, *=, /=, %=, &=, |=, ^=,  - сокращённые операции с присваиванием тоже не перегружаются, т.к. появляются они сами
        //      >>=, <<=                           при определении поведения для своего оператора
        public static Point_WithOperators operator +(Point_WithOperators left, int right) =>  // + - бинарные операторы должны иметь два
            new Point_WithOperators(left.X + right, left.Y + right);                          //   параметра, а каких - тебе решать (правда
                                                                                              //   , один параметр должен быть того типа, в
                                                                                              //   котором этот оператор определён. Здесь
                                                                                              //   это Point_..)
        public static Point_WithOperators operator ++(Point_WithOperators pt) => new Point_WithOperators(pt.X + 1, pt.Y + 1);
        public static Point_WithOperators operator --(Point_WithOperators pt) => new Point_WithOperators(pt.X - 1, pt.Y - 1);
        // В C#, как и в других, т.с., обезопасенных // ++/-- - так мы можем реализовывать унарные операции инкремента и декремента
        //   языках, следует возвращать новый объект //   (да, мы реализуем для сразу и префиксную форму, и постфиксную форму. C# не
        //   при всех операторах, а не изменять      //   позволяет задать отдельное поведение дли них, как это делалось в C++, но
        //   существующий (****почему же структуры   //   обрабатываеются они в коде корректно)
        //   стандартных типов делают иначе?)        //
    }
    static void StructAndOOPAndSystemNullable_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   StructAndOOPAndSystemNullable_Silent()\n");


        // Структура в классическом (Си) виде представляла из себя кастомный (т.е. создаваемый под определённые нужды) тип, состоящий просто из
        //   пачки переменных уже имеющихся типов (int, long, double, ... и уже созданных структур), участки памяти которых примыкают друг к
        //   другу (если твоя структура - это int и int, то переменная твоей структуры будет занимать 4 + 4 байта, т.е. 8 байт. Если, конечно
        //   int на твоей машине занимает 4 байта. Не гарантирую, что то же происходит и в C#). Объявив переменную структуры, ты выделяешь
        //   память на все его внутренние поля. Это очень удобно
        // Ну так вот, ООП и его классы - это следующая ступень развития структур. Класс по факту - это та же структура (т.е. умеет хранить в
        //   себе пачку переменных других типов), но с дополнением в виде возможности объявлять внутри себя функции (функции в классах затем
        //   прозвали методами) и поддержикой такой штуки, как "наследование" (когда один класс копирует другой, с возможностью добавить или
        //   изменить что-то)
        // На более низком уровне классы - это всё-таки те же старые структуры, а методы их реализованы как функции, принимающие (обычно)
        //   первым параметром указатель (адрес байта в RAM) на участок памяти, где расположена эта структура

        // Концепция структуры также формализована в CTS. На самом деле в .NET структуры откололись от классов, и гораздо более напоминают их
        //   легковестную версию. Местные структуры таки умеют хранить методы, но на этом всё. Наследование от них отключили, но оставили
        //   возможность реализовывать интерфейсы.
        // Структуры в .NET сильно отличаются от классов тем, что они хранятся в стёке, в то время как объект классов всегда хранятся только в
        //   управляемой куче. Т.е. структуры умерают сразу, как только заканчивается их блок {}, а при присваивании одной переменной структуры
        //   другой - происходит копирование (это, кстати, происходит при передаче и получении значений от методов и локальных функций)
        // В итоге оказывается, что структуры в C# - это ещё одна затяжка для кода (т.к. всё, что умеют делать структуры, умеют и классы),
        //   отличающаяся только местом жизни и известной датой смерти
        // Ниже объявлена структура Point


        int myInt = 29;
        object obj = myInt;     // object = int - как мы помним, в C# есть две категории типов: ссылочные типы и типы значений. Иногда хочется
                                //   сменить категорию. Для этого в C# существуют механизмы, называемые упаковкой ("boxing")(для перевода
        int theInt = (int)obj;  //   стёкового значения структуры в управляемую кучу) и распоковкой ("unboxing")(обратно). Например, здесь мы
        //                      //   хотим int присвоить ссылочному object. При этом приведении среда CLR создёт в куче новый новый int
        //                      //   экземпляр и копирует в него значения из int myInt, который в куче. Конечно, всё это занимает процессорное
        //                      //   время
        //                      // (int)obj - когда требуется получить это значение задействуется распаковка (она тоже выглядит как
        //                      //   простое приведение). Среда CLR сначала проверяет упакован ли там int, и, если это так, копирует
        //                      //   значение в переменную в стёке (без присваивания не обойтись, т.к. нужное какое-то действие, чтобы это
        //                      //   считалось командой). Если из коллекции удалят этот объект, то его память со временем будет
        //                      //   освобождена сборщиком мусора CLR. Всё это также отнимает время. Соотвественные команды box и unbox
        //                      //   можно встретить в CIL коде
        //
        // Ну и стоит сказать, что CLR умеет переносить типы значений из стёка в управляемую кучу, но не умеет
        //   переносить ссылочные типы из кучи в стёк (ведь уровни стёка при своей гибели тянут и все связанные с ними
        //   переменные. Если в стёке умрёт твой объект, на который ссылаются ещё несколько ссылок с других частей кода
        //   , то получится т.н. undefined behavior, UB. C# такого не терпит)


        // При работе с ref/out также задействуется boxing/unboxing


        //      // Стоить знать, что, хоть в System нет единого класса System.Structures, все структуры неявно наследуются от
        //      //   абстрактного класса System.ValueType, чьё единственное значение - это переопредиление виртуальных методов
        //      //   System.Object для обеспечения размещения экземпляров производных типов в стёке, а не в куче, и настройки их
        //      //   семантики на работу на основе значений, а не ссылок. От этого получаем, что экземпляры структур работают также
        //      //   эффективно, как и базовые типы (это тоже структуры), т.к. имеют предсказуемую длительность жизни и обрабатываются
        //      //   автоматическим сборщиком мусора стёка. Данные, размещённые в куче, же отслеживаются сборщиком мусора .NET, и их
        //      //   время жизни зависит от многих факторов


        Point2D myPoint;              // myPoint - мы не можем использовать структуру, пока она имеет неназначенные поля
        myPoint = new Point2D(4, 2);


        Point2D defaultPoint = new Point2D();  // new Point2D() - как оказалось, так используется конструктор по умолчанию, неявно имеющийся у
                                               //   всех структур и не исчезающий даже после появления кастомных конструкторов (у классов он
                                               //   исчезает). Так мы можем задать значения default для всех полей структуры. Как ты понмишь,
                                               //   нельзя использовать переменные, не имеющих заданные значения. default тоже работает, даже
                                               //   если в структуре есть члены не value типа. На самом деле ты не можешь переопределить
                                               //   стандартный конструктор структур


        Point2D p1 = new Point2D(10, 10);
        Point2D p2 = p1;                   // = - структуры копируются почленно. Именно копируются, в то время, как переменные классов
                                           //   копируют ссылки. Помни, что если твоя структура хранит в себе поле ссылочного типа, то
                                           //   скопируется именно ссылка, и ты получишь две переменные структуры, поля которых будут указывать
                                           //   на один объект в памяти


        string myString = null;                                // null - в C# null далеко не то же самое, что NULL в Си. Здесь он служит
                                                               //   простой заглушкой для ссылочных типов данных, и не может быть присвоен
                                                               //   типам значений (тем, что исходят из System.ValueType)
                                                               //   bool myBool = null;   `...bool is a non-nullable value type`

        int? nullableInt = 25;                                 // ? - при этом поддерживается концепция типов данных, допускающих null (т.к.
        char? nullableChar = 'N';                              //   это очень удобная вещь). На самом деле символ ? - это всего лишь сокращение
        double? nullableDouble = 32.5;                         //   для cоздания экземпляра обобщённой структуры System.Nullable<T>, дающая тот
        bool? nullableBool = null;                             //   же тип, но с добавлением некоторых членов для поддержки null (таких, как
        int?[] nullableInts = new int?[10];                    //   свойство HasValue). Если простой bool может хранить {true, false}, то
                                                               //   Nullable<bool> будет хранить {true, false, null}
                                                               // int? - на самом деле это даже не часть языка. У типа System.Nullable<T> есть
                                                               //   static операторы со знаком ?

        DataBase mainData = new DataBase();
        int? i = mainData.GetNumValue();
        if (i.HasValue)                                        // HasValue - свойство, возвращающее true, если объект хранит не null
            Console.WriteLine("Value of i is {0}.", i.Value);  // Value - тоже свойство, возвращает значение. Если экземпляр не хранит
        else                                                   //   его, а содержит null, то выбрасывается исключение
            Console.WriteLine("Value of i is undefined.");     //   InvalidOperationException

        bool? b = mainData.GetBoolValue();
        if (b != null)                                         // != - нет, логические операторы здесь не переопределены - переопределён метод
            Console.WriteLine("Value of b is {0}.", b.Value);  //   b.Equals() в типе System.Nullable<>
        else
            Console.WriteLine("Value of b is undefined.");

        Console.WriteLine();


        // В структурах ты также легко можешь определять итераторные методы и операторы (как ты понял, структура, по факту, - специальный вид
        //   класса)


        StructWithAutoProperty _;  // StructWithAutoProperty - комментарий к этому классу


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   StructAndOOPAndSystemNullable_Silent()");
    }
    struct Point2D              // struct - обычный класс на минималках, как и в C++ (не поддерживает наследование).  Все структуры и классы
    {                           //   исходят из общего для всего System.Object
        public int xPos, yPos;  // .. struct - т.к. здесь нет модификатора доступа, структура Point будет private
                                // .. { .. struct .. } - структуры, как и классы, можно вкладывать друг в друга
                                // В отличие от полей классов, поля структур не могут быть инициализированы прямо в определении (т.е. у полей
                                //   структур C# не бывает значений по умолчанию)
                                // public - есть полная поддержка приблуд классов

        public Point2D(int _x, int _y)
        {                       // Point2D() - конструктора структур должны задать значения всем полям. Если кто-то из них не будет делать
            xPos = _x;          //   этого, выйдет ошибка компиляции
            yPos = _y;
        }


        static int totalPointAmount = 0;
        //                      // static int .. = - а вот статическим поля структур значение по умолчанию можно задавать
    }
    class DataBase  // DataBase - простая эмуляция базы данных
    {
        int? numValue = null;
        bool? boolValue = true;
        public int? GetNumValue()
        { return numValue; }
        public bool? GetBoolValue()
        { return boolValue; }
    }
    struct StructWithAutoProperty
    {
        public int Number { get; set; }  // ..{ get; set; } - Автор уверяет, что при использовании в структуре автоматических свойств каждый
                                         //   специальный конструктор должен вызывать сначала станадртный (с помощью : this()) для
                                         //   инициализации их закрытых поддерживающих полей значением по умолчанию. Но, как ты видишь, всё
                                         //   работает и без этого
    }
}