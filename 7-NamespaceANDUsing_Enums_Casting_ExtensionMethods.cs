/*
 * creation date  28 dec 2020
 * last change    26 jun 2021
 * author  artur
 */
using System;
using static ClassAndInterface_StructAndOOPAndSystemNullable;

class NamespaceANDUsing_Enums_Casting_ExtensionMethods
{
    static void Main()
    {
        Console.WriteLine("*****_*****");

        NamespaceANDUsing_Silent();
        Enums();
        Casting();  //after using static
        ExtensionMethods();

        Console.ReadLine();
    }
    static void NamespaceANDUsing_Silent()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   NamespaceANDUsing_Silent()\n");


        // Как и в C++, пространства имён в .NET в общем и в C# в частности - это упаковка для типов, призванная группировать их по смыслу.
        //   И название для постранств имён обычно говорят о их содрежимом. Местные пространства имён также могут быть определены частями в
        //   нескольких сборках
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // . На самом деле в самом CIL-языке нет никаких пространств имён. Там это часть имени типов
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        // Например, есть основное для BCL пространство - пространство System. Как ты понял, оно хранит типы, что как-то связаны с системой. В
        //   нём определно другое пространство - пространство System.IO (да, это вложенное пространство), что содержит типы для файлового
        //   ввода-вывода, пространство System.Data - типы для работы с базами данных
        //
        // Число пространств и вложенных пространств неограниченно (собственно, такое же положение и во всех других частях программирования)
        //       namespace Chapter14            // namespace - да, как ты уже, наверное, давно понял, пространства имён могут находится внутри
        //       {                              //   других пространств имён. Зачастую это делается для группировки уже внутрениих типов
        //            namespace InnerNamespace
        //            {
        //                using MyShapes;       // using MyShapes - можно было подумать, что после этой записи из пространства InnerNamespace
        //            }                         //   станет доступно всё, что доступно из пространства MyShapes, но это не так (помним, что
        //        }                             //   using создан всего лишь для сокращения имён, а не полного импорта начинки пространства,
        //                                      //   что делает #include из Си)
        //        namespace Chapter14.InnerNamespace
        //        {                             // Chapter14.InnerNamespace - так тоже можно. Здесь получится ровно то же самое (т.е. два
        //        }                             //   разных пространства, одно из которых вложено в другое)
        //
        // Все эти пространства и члены в них возможно использовать из любого .NET языка, т.к. они CLS совместимы
        //
        // Ты можешь использовать пространства имён из из файлов того же проекта или подключённых к проекту сборок
        //
        // Ты можешь просмотреть пространства имён подключённых к проекту сборок в окне VS View -> Object Browser
        //
        // С точки срезния программиста какой-нибудь System.Console рассматривается как класс Console, помещённый в пространство System. С
        //   точки срезния .NET иначе - он видит отдельный класс по имени System.Console, т.е. он видит т.н. "полностью заданные имена"


        // (как и в C++) В C# необязательно иметь базовое пространство, чтобы типы были доступны для другой сборки (собственно, класс, в
        //   котором ты читаешь этот комментарий, также не вложен в пространство)
        // На самом деле существует пространство имён по умолчанию, куда и попадают созданные так типы (вроде этого) и другие пространства. Это
        //   , так сказать, пространство всей сборки, и по умолчанию оно получает имя твоего проекта (или его немного модифицированную копию,
        //   если имя твоего проекта содержит числа. Например, проект с названием 14.1 получит пространство _14._1)
        /////////after reading///////////////////////////////////////////////////////////////////////
        //   . Стандартное пространство имён (как и имя проекта) можно изменить в VS, пройдя по окну свойств проекта -> Application ->
        //   Default namespace
        /////////////////////////////////////////////////////////////////////////////////////////////
        //   ****при этом VS в окне Error List этому базовому пространсту даёт имя '<global namespace>'. Ошибка у меня была:
        //       Error CS0101 The namespace '<global namespace>' already contains a definition for 'Car'



        // В языке C# есть ключевое слово using, что используется в паре с каким-нибудь пространством имён (да, ты видишь его в каждом моём .cs
        //   файле). Суть в том, что для использования типа из этого пространства тебе не нужно будет писать его полное имя (в C++ ровно то же
        //   действия выполняет конструкция using namespace). Как ты (наверное) понял, использование using может сильно сократить расходы
        //   горизонтальной недвижимости на экране, а также времени
        // Например, в каждой моей функции (вроде NamespaceANDUsing_Silent()) пару раз да используется тип System.Console. Т.к. в начале файла я
        //   прописал    using System;    , мне не обязательно уточнять то, что этот тип находится в пространстве System. Также без уточнения я
        //   могу использовать и все остальные типы из этого пространства. Если бы я не импортировал это пространство, компилятор выдал бы
        //   ошибку
        // using создан для облегчения жизни именно человека. Компилятор же всегда выдаёт CIL код с полностью заданными именами. Как оказалось,
        //   using должен быть впереди всего. А ещё его можно использовать в начале каждого пространства имён (перед началом определения типов)
        // Ещё есть using static. Например,    using static System.Console;    - так можно импортировать статические члены классов, чтобы не
        //   писать префикс в виде Console для его членов, а сразу пользоваться его членами:    WriteLine("It works!");
        //
        // using можно использовать как в начале файла, так и в начале и в начале любого пространства имён (главное, чтобы всё остальное, вроде
        //   типов или других пространств имён, определялось позже):
        //       namespace SomeNamespace
        //       {
        //           using SomeOtherNamespace;
        //           ..
        //       }
        //
        // При работе ты, как и везде, должен следить за тем, чтобы не было конфликтов имён (т.е. чтобы каждый класс, метод, имя переменной
        //   имели своё уникальное имя)
        // Если у тебя подключено System, и ты объявишь у себя метод с именем Console(), то в коде дальше компилятор будет думать, что Console
        //   - это имя метода, а не класса System.Console. Ошибки не происходит, но ты можешь спутаться. В таком случае, чтобы использовать
        //   класс Console, ты должен будешь писать его полностью заданное имя (т.е. System.Console)(на самом деле это единственный случай, где
        //   полностью заданное имя может пригодиться). А лучше и вообще изменить имя метода
        //
        // Напомню, что в CIL-коде всегда применяются полностью заданные имена. Это значит, что твои старания по написанию полностью заданных
        //   имён никак не повлияют на работу программы (хотя я в своей энциклопедии я буду чаще исползовать именно их, ведь так ты и я
        //   повышаешь шансы запомнить пространство имён типов. Это поможет в формировании ментальной карты)


        //****using - интересно, что он не работает для сокращений названий пространств имён


        // Ты можешь объявлять части одного и того же пространства имён в разных сборках, файлах и даже в разных местах одного и того же файла.
        //   Ты можешь спуститься в конец этого файла, и увидедь две части одного пространства имён. В CIL-коде это всё-равно никак не
        //   отразится (там и пространств имён то нет)
        Int32 myInt;  // Int32 - то же, что и int. В CIL коде этот тип здесь будет выглядить как System.Int32


        // Circle.cs - конечно, все классы можно упаковать в один файл, что приемлемо здесь, но что если в
        //   других проектах тебе будет нужна только небольшая часть из них? Чтобы не получать доступ ко
        //   всем сразу, можно разнести классы по нескольких файлам, добавляя в текущий проект только нужные


        //using The3DSquare = My3DShapes.Square;  // using The3DSquare = .. - чтобы избежать конфликтов имён можно использовать псевдонимы. Это
                                                  //   средство языка работает как директивы #define языка Си, но только для имён (в CIL-коде
        // Получается, что это третье назначение  //   этот псевдоним разворачивается в полное имя) (да, фокусы с using, как с #define в Си
        //   ключевого слова using (и всех их     //   здесь не будут работать)
        //   обрабатывает компилятор, не          // The3DSquare - конечно, ты мог бы выбрать и более подходящее для тебя имя. Например, 3Sq
        //   программа)                           //


        // public - как оказалось, если пространство имён не имеет никаких типов в себе, для него нельзя использовать
        //   using в других проектах, подключающих этот (но внутри его файла можно)


        // В самом низу ты можешь увидеть namespace'ы Angle (с англ. угол, не ангел). Да, там 2-а пространства разделяют одно имя (также
        //   и в C++, да и вообще, наверное, в любом языке)


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   NamespaceANDUsing_Silent()");
    }
    static void Enums()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Enums()\n");


        // Перечисления в .NET также перекочевали из Си. Это такой тип, что хранит в себе пары имяПоля-значение. Например, у тебя есть 3-и
        //   режима твоего редактора. Вместо того, чтобы в кода использовать числа 0, 1, 2 (такие непонятные для другого человека вещи зовутся
        //   "магическими числами"), лучше использовать перечисление Modes
        // Как и в Си, можно создавать переменные перечислений, хранящие одно из доступных значений
        // Т.к. перечисления - это отдельный тип в CTS, они не могут свободно контактировать с другими определёнными там типами (вроде структур
        //   и классов)
        //   /////////after reading///////////////////////////////////////////////////////////////////////
        //   // но благодоря обобщённым расширяющим операторным методам перечисление может работать с числами своего типа.
        //   /////////////////////////////////////////////////////////////////////////////////////////////
        //   При этом перечисления отлично работают с оператором switch
        // В отличие от Си (где числа в перечислении всегда имели тип int), в .NET разработчик волен сам задать используемый тип полей в
        //   перечислениях (этот тип должен быть целочисленным, т.е. int, uint, short, ushort, ..)
        // Ты можешь посмотреть на объявление перечисления Modes ниже
        // Ну и ещё - спецификация CTS требует, чтобы перечисления были производными от класса System.Enum (System - это пространство имён)
        //   (т.е. в своей глубине тип перечисления - это тоже обрубок от класса)


        /////////after reading:System.Reflection//////////////////////////////////////////////////////////
           Console.WriteLine("Modes use {0} for storbirthYear\n", Enum.GetUnderlyingType(typeof(Modes)));
        //      // System.Enum.GetUnderlyingType() - т.к. перечисления получают свою фунционалость от
        //      //   класса System.Enum, то с помощью его статических методов (другие мы получить не
        //      //   можем) можно получить некоторую метаинформацию. ..GetUnderlyingType() выдаёт тип
        //      //   внутренних членов перечисления, принимая System.Type
        //      // Если подсунуть в ..GetUndderlyingType() тип неперечисления, метод выбросит исключение:
        //      //       Enum.GetUnderlyingType(typeof(int));  `System.ArgumentException`
        //////////////////////////////////////////////////////////////////////////////////////////////////


        Modes currentMode = Modes.Command;                                   //
                                                                             //
        Console.WriteLine("myJob:  {0}", currentMode);                       // currentMode - особенностью перечислений из C# является то, что
        Console.WriteLine("myJob.ToString(): {0}", currentMode.ToString());  //   его члены возвращают не объекты внутреннего типа, а тип
        Console.WriteLine("(byte)myJob:  {0}\n", (byte)currentMode);         //   самого перечисления:
                                                                             //       byte buffer = myJob;   `cannot convert 'StaffIm...'    .
                                                                             //   Но можно его можно легко конвертировать явно.


        //****Enum.Format(). У тебя этого нет


        /////////after reading:System.Reflection/////////////////////////////////////////////////////////////////////////////////////////////
           Console.WriteLine("Info about {0}", currentMode.GetType());          // currentMode.GetType() - как и везде, выдаст объект класса
                                                                                //   System.Type (с инфо о нашем перечислении)
           Array enumData = Enum.GetValues(currentMode.GetType());              // GetValue() - выдаст массив с членами данного перечисления
           Console.WriteLine("The enum has {0} length", enumData.Length);       //   (перегрузок нет)
           for (int i = 0; i < enumData.Length; i++)
           {
               Console.WriteLine("Name: {0},  Value: {0:d}", enumData.GetValue(i));
           }                                                                    // :d - вместо использования конвертирования
           Console.WriteLine();                                                 //   (или Enum.Format()) можно воспользоваться средствами
                                                                                //   Console.WriteLine()
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Enums()");
    }
    enum Modes : int  // enum - именно с использованием этого ключевого слова объявляются перечисления
    {                 // : int - да, именно так и задаётся тип данных полей. Тип данных, на самом деле, ставить необязательно, по умолчанию
                      //   компилятор поставит int. Перечисления .NET работают со всеми стандартными целыми (!) числами BCL
        Command = 0,  // = 0, - также, как и в Си, совсем не обязательно расставлять числа для полей. По умолчанию они получат значения 0, 1, 2
                      //   , ..
        Insert,       // Insert, - ты также можешь делать пропуски. Insert здесь получит значение 1, т.к. выше него Command получил 0
        Visual = 1,   // , - последнему элементу запятую ставить также необязательно (но лучше подготовить всё для следующего поля. Вдруг
                      //   понадобится)
    }
    static void Casting()  // after class, struct, namespaceANDusing
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   Casting()\n");


        // Ты уже видел, как в C# работает приведение (точнее, casting)(здесь был пример со структурами int и long). Ну так вот - за
        //   преобразования между типами в .NET отвечают те же операторы, правда, особого вида (ты, возможно, удивишься, но если порассуждать -
        //   приведение типа это тоже операция)
        // Стоит помнить, что всякие операторы это всего-лишь сокращения для вызовов нормальных функций, и того же результата всегда
        //   можно добится другими путями
        //
        //
        // Объекты классов, кстати, могут явно (т.е. с указанием впереди конечного типа в ()) приводится к типам, что находятся ниже или выше
        //   по древу наследования и без операторов (главное, не забредать на соседние ветки)
        //
        FelisCatus marsFelisCatus = new FelisCatus("mars", 1973, "he was born");
        Cat marsCat = marsFelisCatus;
        FelisCatus marsFelicCatus1 = (FelisCatus)marsCat; // FelisCatus = Cat - если ты хочешь хранить объект базового класса в ссылке
        //                                                //   производного типа, то ты также должен выполнить явное приведение
        //
        // Здесь приведение между типами Cat и FelisCatus работает потому, что
        //   объект в памяти является ими обоими
        /////////after reading:Exceptions////////////////////////////////////////////////////////////
        //   , но если это будет не так, то во время выполнения выскочит System.InvalidCastException
        /////////////////////////////////////////////////////////////////////////////////////////////
        //   . По этой же причине структуры из-за отсутсвия наследования не могут выполнять
        //   приведение между собой (но той же цели можно добится используя методы). Точнее не
        //   могли бы, если бы C# не позволял строить специальные процедуры преобразования (те
        //   самые операторы для преобразования, дейстующие при операции приведения (т.е. при ())
        //
        //


        Rectangle myRect = new Rectangle(15, 4);
        Console.WriteLine(myRect);
        //
        Square mySquare = (Square)myRect;                  // (Square)myRect - здесь мы пользуемся определённым вручную оператором для
        Console.WriteLine("{0}\n", mySquare);              //   приведения. Ошибки на этапе debug'а (и runtime'а) не происходит
        //                                                 // Примерно то же реализуют и знакомые нам числовые типы, и ты это уже видел
        //
        Square mySquare2 = (Square)45;                     // (Square)45 - это не слишком понятное, но работающее приведение. На самом
        Console.WriteLine("mySquare2 is {0}", mySquare2);  //   деле врядли кто-то будет делать подобное в серьёзных проектах
        uint myUInt = (uint)mySquare2;
        Console.WriteLine("myUint is {0}\n", myUInt);




        //Square mySquare = 15;  // Square = int - здесь была попытка привести тип int к Square неявно. Да, у нас есть нужные команды
        //                       //   для этой конвертации, но они определены для явного приведения. Здесь компилятор выдаст ошибку


        Square mySquare10 = new Square(length: 7);
        Rectangle myRect11 = mySquare;  // mySquare - как и можно было ожидать, операторы неявного поведения выполняются неявно (нет чёткой
        Console.WriteLine(myRect);      //   пометки того, что мы хотим преобразовать объект типа Square в тип Rectangle. Хотя эту пометку
        //                              //   всё-ещё можно сделать)


        // На деле операции преобразования чаще всего делают только для структур, т.к. они не поддерживают наследование, и это становится их
        //   единственным путём


        // На самом деле эта возможность может спасти тебя он написания перегруженных функций для отедльного типа или её обобщения


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   Casting()");
    }
    struct Square
    {
        public uint Length { get; set; }
        public Square(uint length)
        {
            Length = length;
        }
        public static explicit operator Square(Rectangle rect) => new Square(rect.Width >= rect.Height ? rect.Width : rect.Height);
        public override string ToString() => $"Square with length of {Length}";  // Square(Rectangle ..) - так ты можешь задать действия при 
        // explicit - при описании специальной процедуры преобразования ты       //   преобразовании. Здесь оператор принимает объект
        //   всегда должен явно указывать вид этого преобразования. Всего видов  //   Rectangle и строит из него новый выходной объект
        //   два: explicit помечает оператор для работы при явном приведении, а  //   типа Square (этот оператор нацелен на такой случай)
        //   implicit - при неявном (их поведения понятны из их названия), но    // Оператор приведения должен включать в себя тип, в котором
        //   на оба типа (между которыми и происходит движение) в одну сторону   //   он и определяется (у нас это Square)
        //   может быть определена только одна процедура, и если ты выбрал явный //
        //   вид, то конвертация без оператора () действовать не будет           //
        //
        public static explicit operator Square(uint num) => new Square(num);     // Square(uint)/uint(Square) - вот ещё несколько интересных
        public static explicit operator uint(Square square) => square.Length;    //   специальных методов преобразования
    }
    struct Rectangle
    {
        public uint Width { get; set; }
        public uint Height { get; set; }
        public Rectangle(uint width, uint height)  
        {                                          
            Width = width;                         
            Height = height;                       
        }
        public override string ToString() => $"Rectangle with Width of {Width} and Height of {Height}";
        public static implicit operator Rectangle(Square square) => new Rectangle(square.Length * 2, square.Length);
        //                              // implicit - для задания явных специальных преобразования достаточно просто сменить метку
    }
    static void ExtensionMethods()
    {
        Console.WriteLine(">->->->->->->->->->->->->->->->->->->   ExtensionMethods()\n");


        Console.WriteLine("\n1234 after reverse: {0}\n", 1234.ReverseDigits());  // 1234 - в static классе MyExtensions мы модернезировали int.
                                                                                 //   Как это возможно? Почитай комментарии к MyExtensions
                                                                                 // 1234.ReverseDigits() - как и ожидалось, у объектов int
                                                                                 //   появился наш метод для реверса цифр


        /////////after reading///////////////////////////////////////////////////////////////////////
        // Расширяющие методы играют ключевую роль в API-интерфейсах LINQ. Там очень многое (****возможно всё) построено именно на расширенях
        //   IEnumerable
        /////////////////////////////////////////////////////////////////////////////////////////////


        Console.WriteLine("<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<-<   ExtensionMethods()");
    }
}
    static class MyExtensions
    {
        public static int ReverseDigits(this int num)      // this - в .NET 3.5 появилась концепция расширяющих методов, позволяющая добавлять
        {                                                  //   новые методы и свойства к уже имеющимся типам. Зачем это нужно, если ты можешь
            char[] digits = num.ToString().ToCharArray();  //   изменить эти типы напрямую? Как оказывается, не всегда. Например, автор
            Array.Reverse(digits);                         //   приводит ситуацию, когда ты не можешь их изменять из-за возможных проблем
            return int.Parse(new string(digits));          //   сомвестимости со старой кодовой базой (они могут не скомпилироваться с твоим
        }   // MyExtensions - расширяющие методы должны    //   улучшением). Конечно, можно просто сделать потомка от этого типа, и
            //   находится в каком-нибудь статическом      //   использовать его, смирясь с лишним кодом, но что если у тебя структура или
            //   и невложенном классе, и иметь первый      //   запечатанный класс?
            //   параметр, помеченный ключевым словом this // this int .. - здесь мы расширяем структуру. Если же ты решишь расширить
            //   (тип этого параметра и будет расширен     //   какой-нибудь класс, то это расширение по всем законам наследования будет
            //   этим методом, а сам объект будет          //   действовать и на его потомков. Интерфейсы также легко расширяются
            //   представлять .. объект, из которого метод // Если ты попытаешься объявить несколько статических классов, имеющих одинаковые
            //   будет возможно вызывать). Да, похоже на   //   расширяющие методы, то компилятор выдаст ошибку неоднозначности
            //   ООП в Python. Только один параметр может  // MyExtensions - т.к. это всё-таки класс, его расширяющие методы будут доступны
            //   быть помечен как this, все последующие    //   только там, где виден он. Обычной практикой считается изоляция расширяющих
            //   будут обычными, как в других методах      //   методов не только в отдельном пространстве имён, но и в отдельной библиотеке
            // Расширяющие методы имеют больший приоритет  //   классов (т.е. в отедльном .dll). В этом случае к ним можно будет обращатся
            //   , поэтому если ты создашь такой с копией  //   путём явной ссылки на подходящую библиотеку и импортирования нужного
            //   прототипа существующего метода (да, это   //   пространства имён
            //   не приводит к ошибке компиляции), то      // VS - чтобы избежать возможной путаницы, средство IntelliSense помечает
            //   выполнится будет именно расширяющий       //   доступные расширяющие методы немного иначе, чем обычные в своём окошке
            //   (готов спорить, что компилятор просто)    //
            //   читает расширяющие методы позже обычных)  //
    }
namespace Angle //****скорее всего к этим namespace'ам был намёк где-то в комментариях, но я его не нашёл. может стоит добавить?
{
}
namespace Angle
{  // namespace .. - как видишь, разрывать пространство имён можно на ровном месте
}